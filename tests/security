<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Security Implementation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 2rem;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 { margin-bottom: 2rem; }
        h2 { 
            margin-top: 2rem; 
            margin-bottom: 1rem;
            color: #60a5fa;
        }
        .code-block {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }
        pre {
            color: #a5f3fc;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .security-flow {
            background: #111827;
            border: 1px solid #1f2937;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
        }
        .flow-step {
            display: flex;
            align-items: start;
            margin-bottom: 1.5rem;
        }
        .step-number {
            background: #3b82f6;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            flex-shrink: 0;
        }
        .verification-ui {
            background: #1f2937;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        .fingerprint-display {
            background: #111827;
            padding: 1rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 1.25rem;
            text-align: center;
            margin: 1rem 0;
            letter-spacing: 0.1em;
        }
        .trust-indicator {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            margin: 0.5rem 0;
        }
        .trust-new { background: #1e40af; }
        .trust-verified { background: #059669; }
        .trust-warning { background: #dc2626; }
        .emoji-verify {
            font-size: 2rem;
            text-align: center;
            padding: 1rem;
            background: #111827;
            border-radius: 8px;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê P2P Security Implementation with DH Key Exchange</h1>
        
        <h2>Architecture Overview</h2>
        <div class="security-flow">
            <p>Three-layer security model:</p>
            <ol style="margin-left: 2rem; margin-top: 1rem;">
                <li><strong>Workspace Layer:</strong> Shared encryption key from invite</li>
                <li><strong>Connection Layer:</strong> DTLS certificates per WebRTC connection</li>
                <li><strong>Message Layer:</strong> Ephemeral keys per conversation</li>
            </ol>
        </div>

        <h2>1. WebRTC with Built-in DH Exchange</h2>
        <div class="code-block">
            <pre>// Core P2P Connection with automatic ECDH
class SecureP2PConnection {
  constructor(workspaceKey) {
    this.workspaceKey = workspaceKey;
    this.peerConnections = new Map();
    this.trustedFingerprints = new Map(); // Persistent storage
    this.verificationState = new Map();
  }

  async createConnection(peerId) {
    // Generate certificate with 30-day expiry (WebRTC handles ECDH)
    const certificate = await RTCPeerConnection.generateCertificate({
      name: 'ECDSA',
      namedCurve: 'P-256'
    });

    const pc = new RTCPeerConnection({
      iceServers: [/* your STUN/TURN servers */],
      certificates: [certificate]
    });

    // Store connection
    this.peerConnections.set(peerId, pc);
    
    // Set up verification handlers
    pc.onsignalingstatechange = () => {
      if (pc.signalingState === 'stable') {
        this.verifyConnection(peerId);
      }
    };

    return pc;
  }

  async verifyConnection(peerId) {
    const pc = this.peerConnections.get(peerId);
    const stats = await pc.getStats();
    
    let localFingerprint, remoteFingerprint;
    
    stats.forEach(report => {
      if (report.type === 'certificate') {
        localFingerprint = report.fingerprint;
      }
      if (report.type === 'remote-certificate') {
        remoteFingerprint = report.fingerprint;
      }
    });

    // Generate SAS (Short Authentication String) for verification
    const sas = await this.generateSAS(
      localFingerprint, 
      remoteFingerprint, 
      this.workspaceKey
    );

    // Check trust status
    const trustStatus = this.checkTrust(peerId, remoteFingerprint);
    
    return {
      localFingerprint,
      remoteFingerprint,
      sas,
      trustStatus
    };
  }

  async generateSAS(localFp, remoteFp, workspaceKey) {
    // Combine fingerprints deterministically
    const combined = [localFp, remoteFp].sort().join('') + workspaceKey;
    
    // Generate hash
    const encoder = new TextEncoder();
    const data = encoder.encode(combined);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    
    // Create multiple verification formats
    return {
      numbers: this.toNumberCode(hashArray),     // "7823"
      words: this.toWordCode(hashArray),         // "castle-dragon-sunset"
      emoji: this.toEmojiCode(hashArray),        // "üè∞ üêâ üåÖ"
      hex: this.toHexCode(hashArray)            // "A7:B2:C3:D4"
    };
  }

  checkTrust(peerId, fingerprint) {
    const stored = this.trustedFingerprints.get(peerId);
    
    if (!stored) {
      return { status: 'NEW', message: 'First time connecting' };
    }
    
    if (stored === fingerprint) {
      return { status: 'VERIFIED', message: 'Previously verified' };
    }
    
    return { 
      status: 'WARNING', 
      message: 'FINGERPRINT CHANGED - Possible MITM attack!' 
    };
  }

  toNumberCode(bytes) {
    // 4-digit code for voice verification
    const num = (bytes[0] << 8 | bytes[1]) % 10000;
    return num.toString().padStart(4, '0');
  }

  toWordCode(bytes) {
    // PGP word list style
    const words = [
      ['aardvark', 'absurd', 'accrue', 'acme'],
      ['adrift', 'adult', 'afflict', 'ahead'],
      ['aimless', 'algol', 'allow', 'alone'],
      // ... full word list
    ];
    
    return [
      words[0][bytes[0] % 4],
      words[1][bytes[1] % 4],
      words[2][bytes[2] % 4]
    ].join('-');
  }

  toEmojiCode(bytes) {
    // Visual verification with emoji
    const emojis = ['üè∞', 'üêâ', 'üåÖ', 'üåä', '‚ö°', 'üî•', '‚ùÑÔ∏è', 'üåü'];
    return [
      emojis[bytes[0] % 8],
      emojis[bytes[1] % 8],
      emojis[bytes[2] % 8]
    ].join(' ');
  }

  toHexCode(bytes) {
    // Traditional fingerprint
    return bytes.slice(0, 4)
      .map(b => b.toString(16).padStart(2, '0').toUpperCase())
      .join(':');
  }
}</pre>
        </div>

        <h2>2. User Flow for Maximum Security + Usability</h2>
        
        <div class="security-flow">
            <div class="flow-step">
                <div class="step-number">1</div>
                <div>
                    <strong>First Connection (TOFU - Trust On First Use)</strong>
                    <div class="verification-ui">
                        <div class="trust-indicator trust-new">
                            ‚ö†Ô∏è New Connection with "Alice"
                        </div>
                        <p style="margin: 1rem 0;">Verify using any method:</p>
                        <div class="fingerprint-display">7823</div>
                        <p style="text-align: center; color: #888;">Say "My code is seven-eight-two-three"</p>
                        <div class="emoji-verify">üè∞ üêâ üåÖ</div>
                        <p style="text-align: center; color: #888;">Or compare these symbols</p>
                        <button style="width: 100%; padding: 0.75rem; margin-top: 1rem; background: #3b82f6; border: none; border-radius: 6px; color: white; cursor: pointer;">Mark as Verified</button>
                    </div>
                </div>
            </div>

            <div class="flow-step">
                <div class="step-number">2</div>
                <div>
                    <strong>Subsequent Connections</strong>
                    <div class="verification-ui">
                        <div class="trust-indicator trust-verified">
                            ‚úì Verified Connection with "Alice"
                        </div>
                        <p style="color: #10b981; margin-top: 0.5rem;">Previously verified on Oct 15, 2024</p>
                    </div>
                </div>
            </div>

            <div class="flow-step">
                <div class="step-number">3</div>
                <div>
                    <strong>Security Warning (Key Change Detected)</strong>
                    <div class="verification-ui">
                        <div class="trust-indicator trust-warning">
                            üö® SECURITY WARNING
                        </div>
                        <p style="margin: 1rem 0;">Alice's security fingerprint has CHANGED!</p>
                        <p style="color: #f87171;">This could mean:</p>
                        <ul style="margin-left: 1.5rem; color: #fbbf24;">
                            <li>Alice got a new device</li>
                            <li>Alice reinstalled the app</li>
                            <li>Someone is intercepting your connection</li>
                        </ul>
                        <p style="margin-top: 1rem;">New verification code:</p>
                        <div class="fingerprint-display" style="border: 2px solid #dc2626;">9347</div>
                        <button style="width: 100%; padding: 0.75rem; margin-top: 1rem; background: #dc2626; border: none; border-radius: 6px; color: white; cursor: pointer;">Verify & Continue</button>
                        <button style="width: 100%; padding: 0.75rem; margin-top: 0.5rem; background: transparent; border: 1px solid #666; border-radius: 6px; color: white; cursor: pointer;">Disconnect</button>
                    </div>
                </div>
            </div>
        </div>

        <h2>3. Progressive Security Model</h2>
        <div class="code-block">
            <pre>// Different verification levels based on context
class SecurityPolicy {
  constructor() {
    this.policies = {
      casual: {
        requireVerification: false,
        autoTrust: true,
        warnOnChange: true
      },
      standard: {
        requireVerification: 'first-time',  // Only on first connection
        autoTrust: false,
        warnOnChange: true,
        blockOnChange: false
      },
      paranoid: {
        requireVerification: 'always',
        autoTrust: false,
        warnOnChange: true,
        blockOnChange: true,
        reverifyInterval: 7 * 24 * 60 * 60 * 1000  // Weekly
      }
    };
  }

  async handleNewConnection(peerId, verification, policy = 'standard') {
    const settings = this.policies[policy];
    
    if (verification.trustStatus.status === 'NEW') {
      if (settings.requireVerification) {
        return await this.showVerificationUI(peerId, verification);
      } else if (settings.autoTrust) {
        await this.trustAutomatically(peerId, verification);
      }
    }
    
    if (verification.trustStatus.status === 'WARNING') {
      if (settings.blockOnChange) {
        throw new Error('Connection blocked: Fingerprint changed');
      } else if (settings.warnOnChange) {
        return await this.showWarningUI(peerId, verification);
      }
    }
    
    return { allowed: true };
  }
}</pre>
        </div>

        <h2>4. Message-Level Encryption (Double Ratchet)</h2>
        <div class="code-block">
            <pre>// Additional layer: Forward-secret message encryption
class MessageEncryption {
  constructor(sharedSecret) {
    this.rootKey = sharedSecret;
    this.sendChainKey = null;
    this.receiveChainKey = null;
    this.messageKeys = new Map();
  }

  async deriveNextKey(chainKey) {
    // Ratchet forward for each message
    const nextKey = await crypto.subtle.digest('SHA-256', chainKey);
    return {
      messageKey: new Uint8Array(nextKey, 0, 32),
      nextChainKey: new Uint8Array(nextKey, 32, 32)
    };
  }

  async encryptMessage(plaintext) {
    // Generate ephemeral key for this message
    const { messageKey, nextChainKey } = await this.deriveNextKey(this.sendChainKey);
    this.sendChainKey = nextChainKey;
    
    // Encrypt with unique key
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      await this.importKey(messageKey),
      new TextEncoder().encode(plaintext)
    );
    
    return { encrypted, iv, keyId: this.getKeyId() };
  }
}</pre>
        </div>

        <h2>5. Complete Integration</h2>
        <div class="code-block">
            <pre>// Putting it all together
class SecureWorkspace {
  constructor() {
    this.connection = null;
    this.encryption = null;
    this.verificationUI = new VerificationUI();
  }

  async joinWorkspace(inviteData) {
    // 1. Extract workspace key from invite
    const workspaceKey = inviteData.key;
    
    // 2. Create P2P connection (automatic ECDH via WebRTC)
    this.connection = new SecureP2PConnection(workspaceKey);
    
    // 3. Connect to peer
    const pc = await this.connection.createConnection(inviteData.hostId);
    
    // 4. Verify connection (first time or changed)
    const verification = await this.connection.verifyConnection(inviteData.hostId);
    
    // 5. Show appropriate UI
    if (verification.trustStatus.status === 'NEW') {
      const userChoice = await this.verificationUI.promptVerification(verification);
      if (userChoice.verified) {
        await this.saveTrust(inviteData.hostId, verification.remoteFingerprint);
      }
    } else if (verification.trustStatus.status === 'WARNING') {
      const userChoice = await this.verificationUI.promptWarning(verification);
      if (!userChoice.proceed) {
        throw new Error('User rejected changed fingerprint');
      }
    }
    
    // 6. Establish message encryption
    this.encryption = new MessageEncryption(
      await this.deriveSharedSecret(verification)
    );
    
    // Ready for secure communication!
    return { verified: true, connection: pc };
  }
}</pre>
        </div>

        <h2>Security Properties Achieved</h2>
        <div class="security-flow">
            <p><strong>‚úì Forward Secrecy:</strong> WebRTC generates new DTLS keys per session</p>
            <p><strong>‚úì Authentication:</strong> Fingerprint verification prevents MITM</p>
            <p><strong>‚úì Perfect Forward Secrecy:</strong> Message keys ratchet forward</p>
            <p><strong>‚úì Denial of Service:</strong> No central server to attack</p>
            <p><strong>‚úì Metadata Protection:</strong> Direct P2P hides who talks to whom</p>
            <p><strong>‚úì Offline Capability:</strong> Store-and-forward through trusted peers</p>
        </div>
    </div>
</body>
</html>
