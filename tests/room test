<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decentralized Encrypted Chat</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
            overflow: hidden;
        }
        
        /* Auth Screen */
        .auth-container {
            padding: 40px;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .auth-container h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .auth-subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .auth-form input {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .auth-form input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .auth-form button {
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .auth-form button:hover {
            background: #5a67d8;
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: 20px;
            color: #666;
        }
        
        .auth-toggle a {
            color: #667eea;
            text-decoration: none;
            cursor: pointer;
        }
        
        /* Main Chat Interface */
        .chat-container {
            display: none;
            height: 600px;
            display: flex;
            flex-direction: column;
        }
        
        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
        }
        
        .user-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .user-badge {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .user-details {
            display: flex;
            flex-direction: column;
        }
        
        .user-name {
            font-weight: bold;
            font-size: 16px;
        }
        
        .user-id {
            font-size: 10px;
            opacity: 0.8;
            font-family: monospace;
        }
        
        .storage-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            font-size: 12px;
        }
        
        .storage-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .room-controls {
            display: flex;
            gap: 10px;
        }
        
        .room-controls input {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.2);
            color: white;
            placeholder-color: rgba(255,255,255,0.6);
        }
        
        .room-controls input::placeholder {
            color: rgba(255,255,255,0.6);
        }
        
        .room-controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.3);
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .room-controls button:hover {
            background: rgba(255,255,255,0.4);
        }
        
        .chat-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .room-info-bar {
            background: #f5f5f5;
            padding: 10px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .room-name {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .encryption-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background: #7b1fa2;
            color: white;
            border-radius: 12px;
            font-size: 11px;
        }
        
        .encryption-badge.double {
            background: #ff6b35;
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: white;
        }
        
        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .message-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .message-author {
            font-weight: bold;
            color: #333;
        }
        
        .message-time {
            font-size: 11px;
            color: #999;
        }
        
        .message-verified {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 6px;
            background: #e8f5e9;
            color: #2e7d32;
            border-radius: 10px;
            font-size: 10px;
        }
        
        .message-text {
            color: #555;
            line-height: 1.4;
        }
        
        .message.own {
            flex-direction: row-reverse;
        }
        
        .message.own .message-content {
            align-items: flex-end;
        }
        
        .message.own .message-text {
            background: #e3f2fd;
            padding: 8px 12px;
            border-radius: 12px 12px 4px 12px;
            display: inline-block;
        }
        
        .message.system {
            justify-content: center;
            font-style: italic;
            color: #999;
            font-size: 13px;
        }
        
        .message-input-container {
            padding: 20px;
            background: #f5f5f5;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        .message-input {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            font-size: 14px;
        }
        
        .message-input:focus {
            border-color: #667eea;
        }
        
        .send-button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .send-button:hover:not(:disabled) {
            background: #5a67d8;
        }
        
        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .chat-sidebar {
            width: 250px;
            background: #f9f9f9;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .sidebar-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .peer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            border-radius: 6px;
            margin-bottom: 5px;
        }
        
        .peer-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
        }
        
        .history-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 13px;
            color: #666;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
        }
        
        .stat-value {
            font-weight: bold;
            color: #333;
        }
        
        /* Invite Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .invite-link-box {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
            margin-bottom: 15px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .button-primary {
            background: #667eea;
            color: white;
        }
        
        .button-secondary {
            background: #e0e0e0;
            color: #333;
        }
        
        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 11px;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .debug-panel h4 {
            margin-bottom: 10px;
            color: #4ade80;
        }
        
        .debug-line {
            margin-bottom: 3px;
            opacity: 0.8;
        }
        
        .hide {
            display: none !important;
        }
        
        /* Room Lobby */
        .room-lobby {
            padding: 40px;
            max-width: 600px;
            margin: 0 auto;
            display: none;
        }
        
        .room-lobby.active {
            display: block;
        }
        
        .lobby-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .lobby-title {
            font-size: 24px;
            color: #333;
            margin-bottom: 10px;
        }
        
        .lobby-subtitle {
            color: #666;
            font-size: 14px;
        }
        
        .room-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .room-option {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .room-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .room-option h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .room-option p {
            color: #666;
            font-size: 13px;
        }
        
        .saved-rooms {
            background: #f0f7ff;
            padding: 20px;
            border-radius: 8px;
        }
        
        .saved-rooms h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .room-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .room-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .room-item:hover {
            transform: translateX(5px);
        }
        
        .room-item-info {
            display: flex;
            flex-direction: column;
        }
        
        .room-item-name {
            font-weight: bold;
            color: #333;
        }
        
        .room-item-meta {
            font-size: 11px;
            color: #999;
        }
        
        .room-item-badge {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <!-- Auth Screen -->
    <div class="container" id="authScreen">
        <div class="auth-container">
            <h1 id="authTitle">Welcome Back</h1>
            <div class="auth-subtitle">Decentralized E2E Encrypted Chat</div>
            
            <form class="auth-form" onsubmit="handleAuth(event)">
                <input type="text" id="authUsername" placeholder="Username" required>
                <input type="password" id="authPassword" placeholder="Password" required>
                <input type="text" id="authRoomId" placeholder="Room ID (optional - leave empty for lobby)">
                <input type="password" id="authRoomPassword" placeholder="Room Password (if needed)">
                <button type="submit" id="authButton">Sign In</button>
            </form>
            
            <div id="recentRooms" class="hide" style="margin-top: 20px; padding: 15px; background: #f9f9f9; border-radius: 8px;">
                <div style="font-weight: bold; margin-bottom: 10px; color: #333;">Recent Rooms:</div>
                <div id="recentRoomsList" style="display: flex; flex-direction: column; gap: 5px;">
                </div>
            </div>
            
            <div class="auth-toggle">
                <span id="authToggleText">Don't have an account?</span>
                <a onclick="toggleAuthMode()" id="authToggleLink">Create one</a>
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: #f0f7ff; border-radius: 8px; font-size: 12px; color: #666;">
                <strong>🔒 Privacy First:</strong><br>
                • All data stored locally in your browser<br>
                • Encrypted with your password<br>
                • No servers, no tracking<br>
                • You own your data
            </div>
        </div>
    </div>
    
    <!-- Main Chat Interface -->
    <div class="container hide" id="chatScreen">
        <!-- Room Lobby (shown when no room selected) -->
        <div class="room-lobby" id="roomLobby">
            <div class="lobby-header">
                <div class="lobby-title">Welcome, <span id="lobbyUsername">--</span>!</div>
                <div class="lobby-subtitle">Choose a room to join or create a new one</div>
            </div>
            
            <div class="room-options">
                <div class="room-option" onclick="showCreateRoom()">
                    <h3>🚀 Create Room</h3>
                    <p>Start a new encrypted chat room</p>
                </div>
                <div class="room-option" onclick="showJoinRoom()">
                    <h3>🔗 Join Room</h3>
                    <p>Join using invite link or room ID</p>
                </div>
            </div>
            
            <div class="saved-rooms" id="savedRoomsSection">
                <h3>📚 Your Saved Rooms</h3>
                <div class="room-list" id="savedRoomsList">
                    <div style="color: #999; font-size: 13px;">No saved rooms yet</div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="signOut()" style="padding: 8px 16px; background: #e0e0e0; border: none; border-radius: 6px; cursor: pointer;">Sign Out</button>
            </div>
        </div>
        
        <div class="chat-container hide" id="chatContainer">
            <!-- Header -->
            <!-- Header -->
            <div class="chat-header">
                <div class="user-info">
                    <div class="user-badge">
                        <div class="user-avatar" id="userAvatar">--</div>
                        <div class="user-details">
                            <div class="user-name" id="userName">--</div>
                            <div class="user-id" id="userId">--</div>
                        </div>
                    </div>
                    <div class="storage-indicator">
                        <div class="storage-dot"></div>
                        <span id="storageStatus">Local Storage Active</span>
                    </div>
                </div>
                
                <div class="room-controls">
                    <input type="text" id="roomIdInput" placeholder="Enter room ID or leave empty for new">
                    <input type="password" id="roomPasswordInput" placeholder="Room password (optional)">
                    <button onclick="createOrJoinRoom()">Create/Join Room</button>
                    <button onclick="backToLobby()">Back to Lobby</button>
                    <button onclick="signOut()">Sign Out</button>
                </div>
            </div>
            
            <!-- Chat Body -->
            <div class="chat-body">
                <!-- Main Chat Area -->
                <div class="chat-main">
                    <div class="room-info-bar">
                        <div class="room-name">
                            <span id="roomName">No Room</span>
                            <span id="encryptionBadge" class="encryption-badge hide">🔐 Encrypted</span>
                        </div>
                        <button onclick="showInviteModal()" id="inviteButton" disabled>Invite</button>
                    </div>
                    
                    <div class="messages-container" id="messagesContainer">
                        <div class="message system">
                            <div>Create or join a room to start chatting</div>
                        </div>
                    </div>
                    
                    <div class="message-input-container">
                        <input type="text" class="message-input" id="messageInput" 
                               placeholder="Type a message..." disabled>
                        <button class="send-button" id="sendButton" onclick="sendMessage()" disabled>
                            Send
                        </button>
                    </div>
                </div>
                
                <!-- Sidebar -->
                <div class="chat-sidebar">
                    <div class="sidebar-section">
                        <div class="sidebar-title">Connected Peers</div>
                        <div id="peersList">
                            <div style="color: #999; font-size: 13px;">No peers connected</div>
                        </div>
                    </div>
                    
                    <div class="sidebar-section">
                        <div class="sidebar-title">Local Storage</div>
                        <div class="history-stats">
                            <div class="stat-item">
                                <span>Total Messages:</span>
                                <span class="stat-value" id="totalMessages">0</span>
                            </div>
                            <div class="stat-item">
                                <span>Storage Used:</span>
                                <span class="stat-value" id="storageUsed">0 KB</span>
                            </div>
                            <div class="stat-item">
                                <span>Rooms Saved:</span>
                                <span class="stat-value" id="roomsSaved">0</span>
                            </div>
                            <div class="stat-item">
                                <span>Verified Msgs:</span>
                                <span class="stat-value" id="verifiedMessages">0</span>
                            </div>
                        </div>
                    </div>
                    </div>
                    </div>
                </div>
            </div>
        </div> <!-- End chatContainer -->
    </div> <!-- End chatScreen container -->
    
    <!-- Invite Modal -->
    <div class="modal" id="inviteModal">
        <div class="modal-content">
            <div class="modal-title">Invite to Room</div>
            <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
                Share this link with others to let them join the room:
            </div>
            <div class="invite-link-box" id="inviteLinkBox">--</div>
            <div id="passwordWarning" class="hide" style="background: #fff3cd; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 13px;">
                ⚠️ This room requires a password. Share it separately: <strong id="roomPasswordDisplay">--</strong>
            </div>
            <div class="modal-buttons">
                <button class="button-secondary" onclick="closeInviteModal()">Close</button>
                <button class="button-primary" onclick="copyInviteLink()">Copy Link</button>
            </div>
        </div>
    </div>
    
    <!-- Debug Panel -->
    <div class="debug-panel" id="debugPanel">
        <h4>🔍 Debug Info</h4>
        <div id="debugContent"></div>
    </div>

    <script>
        // ============= GLOBAL STATE =============
        let currentUser = null;  // Decrypted user identity
        let currentRoom = null;  // Current room info
        let masterKey = null;    // Derived from user password
        let signaler = null;     // BroadcastChannel for WebRTC
        let peers = new Map();   // Connected peers
        
        // Encryption keys for current room
        let inviteKey = null;
        let passwordKey = null;
        
        // Auth state
        let isSignUp = false;
        
        // ============= CRYPTO UTILITIES =============
        
        async function deriveKeyFromPassword(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }
        
        async function generateKeyPair() {
            return crypto.subtle.generateKey(
                {
                    name: 'ECDSA',
                    namedCurve: 'P-256'
                },
                true,
                ['sign', 'verify']
            );
        }
        
        async function encryptData(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encodedData = new TextEncoder().encode(JSON.stringify(data));
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                key,
                encodedData
            );
            
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            return btoa(String.fromCharCode(...combined));
        }
        
        async function decryptData(encryptedString, key) {
            const combined = Uint8Array.from(atob(encryptedString), c => c.charCodeAt(0));
            const iv = combined.slice(0, 12);
            const ciphertext = combined.slice(12);
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                key,
                ciphertext
            );
            
            return JSON.parse(new TextDecoder().decode(decrypted));
        }
        
        async function signMessage(message, privateKey) {
            const encoder = new TextEncoder();
            const data = encoder.encode(JSON.stringify(message));
            
            const signature = await crypto.subtle.sign(
                { name: 'ECDSA', hash: 'SHA-256' },
                privateKey,
                data
            );
            
            return btoa(String.fromCharCode(...new Uint8Array(signature)));
        }
        
        async function verifySignature(message, signature, publicKey) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(JSON.stringify(message));
                const sig = Uint8Array.from(atob(signature), c => c.charCodeAt(0));
                
                return await crypto.subtle.verify(
                    { name: 'ECDSA', hash: 'SHA-256' },
                    publicKey,
                    sig,
                    data
                );
            } catch (e) {
                return false;
            }
        }
        
        async function exportKey(key) {
            const exported = await crypto.subtle.exportKey(
                key.type === 'public' ? 'spki' : 'pkcs8',
                key
            );
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }
        
        async function importKey(keyData, isPublic = true) {
            const keyBytes = Uint8Array.from(atob(keyData), c => c.charCodeAt(0));
            return crypto.subtle.importKey(
                isPublic ? 'spki' : 'pkcs8',
                keyBytes,
                { name: 'ECDSA', namedCurve: 'P-256' },
                true,
                isPublic ? ['verify'] : ['sign']
            );
        }
        
        // ============= LOCAL STORAGE =============
        
        async function saveUserIdentity(identity, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const key = await deriveKeyFromPassword(password, salt);
            
            const encrypted = await encryptData(identity, key);
            
            localStorage.setItem('chat_user', JSON.stringify({
                encrypted: encrypted,
                salt: btoa(String.fromCharCode(...salt))
            }));
            
            debug('User identity saved to localStorage');
        }
        
        async function loadUserIdentity(username, password) {
            const stored = localStorage.getItem('chat_user');
            if (!stored) return null;
            
            try {
                const { encrypted, salt } = JSON.parse(stored);
                const saltBytes = Uint8Array.from(atob(salt), c => c.charCodeAt(0));
                const key = await deriveKeyFromPassword(password, saltBytes);
                
                const identity = await decryptData(encrypted, key);
                
                // Check username matches
                if (identity.username !== username) {
                    return null;
                }
                
                // Restore key objects
                identity.keyPair = {
                    publicKey: await importKey(identity.publicKeyData, true),
                    privateKey: await importKey(identity.privateKeyData, false)
                };
                
                masterKey = key;  // Store for room data encryption
                
                debug('User identity loaded from localStorage');
                return identity;
            } catch (e) {
                debug('Failed to decrypt identity: ' + e.message);
                return null;
            }
        }
        
        async function saveRoomHistory() {
            if (!currentUser || !currentRoom || !masterKey) return;
            
            const roomData = {
                roomId: currentRoom.roomId,
                roomName: currentRoom.roomName || 'Unnamed Room',
                created: currentRoom.created,
                lastAccessed: new Date().toISOString(),
                messages: currentRoom.messages || [],
                hasPassword: currentRoom.hasPassword
            };
            
            // Load existing rooms
            let rooms = {};
            const stored = localStorage.getItem('chat_rooms');
            if (stored) {
                try {
                    rooms = await decryptData(stored, masterKey);
                } catch (e) {
                    debug('Could not decrypt existing rooms');
                }
            }
            
            // Update room
            rooms[currentRoom.roomId] = roomData;
            
            // Save encrypted
            const encrypted = await encryptData(rooms, masterKey);
            localStorage.setItem('chat_rooms', encrypted);
            
            updateStorageStats();
            debug(`Saved room history: ${currentRoom.messages?.length || 0} messages`);
        }
        
        async function loadRoomHistory(roomId) {
            if (!masterKey) return null;
            
            const stored = localStorage.getItem('chat_rooms');
            if (!stored) return null;
            
            try {
                const rooms = await decryptData(stored, masterKey);
                return rooms[roomId] || null;
            } catch (e) {
                debug('Failed to load room history: ' + e.message);
                return null;
            }
        }
        
        function updateStorageStats() {
            if (!currentUser) return;
            
            // Calculate storage used
            let totalSize = 0;
            for (let key in localStorage) {
                if (key.startsWith('chat_')) {
                    totalSize += localStorage[key].length;
                }
            }
            
            document.getElementById('storageUsed').textContent = 
                (totalSize / 1024).toFixed(1) + ' KB';
            
            // Count rooms
            const roomsData = localStorage.getItem('chat_rooms');
            if (roomsData && masterKey) {
                decryptData(roomsData, masterKey).then(rooms => {
                    document.getElementById('roomsSaved').textContent = 
                        Object.keys(rooms).length;
                    
                    // Count total messages
                    let totalMessages = 0;
                    let verifiedMessages = 0;
                    
                    for (let roomId in rooms) {
                        const room = rooms[roomId];
                        totalMessages += room.messages?.length || 0;
                        verifiedMessages += room.messages?.filter(m => m.verified).length || 0;
                    }
                    
                    document.getElementById('totalMessages').textContent = totalMessages;
                    document.getElementById('verifiedMessages').textContent = verifiedMessages;
                }).catch(e => {
                    debug('Could not decrypt rooms for stats');
                });
            }
        }
        
        // ============= AUTH FUNCTIONS =============
        
        function toggleAuthMode() {
            isSignUp = !isSignUp;
            document.getElementById('authTitle').textContent = 
                isSignUp ? 'Create Account' : 'Welcome Back';
            document.getElementById('authButton').textContent = 
                isSignUp ? 'Sign Up' : 'Sign In';
            document.getElementById('authToggleText').textContent = 
                isSignUp ? 'Already have an account?' : "Don't have an account?";
            document.getElementById('authToggleLink').textContent = 
                isSignUp ? 'Sign in' : 'Create one';
        }
        
        async function handleAuth(event) {
            event.preventDefault();
            
            const username = document.getElementById('authUsername').value;
            const password = document.getElementById('authPassword').value;
            const roomId = document.getElementById('authRoomId').value.trim();
            const roomPassword = document.getElementById('authRoomPassword').value;
            
            if (isSignUp) {
                // Create new identity
                const keyPair = await generateKeyPair();
                const userId = 'U' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                
                const identity = {
                    userId: userId,
                    username: username,
                    created: new Date().toISOString(),
                    publicKeyData: await exportKey(keyPair.publicKey),
                    privateKeyData: await exportKey(keyPair.privateKey)
                };
                
                // Save encrypted
                await saveUserIdentity(identity, password);
                
                // Set current user
                currentUser = {
                    ...identity,
                    keyPair: keyPair
                };
                
                // Derive master key
                const salt = crypto.getRandomValues(new Uint8Array(16));
                masterKey = await deriveKeyFromPassword(password, salt);
                
                debug('New account created: ' + userId);
                
                // Handle room if specified
                if (roomId) {
                    showChatScreen();
                    document.getElementById('roomIdInput').value = roomId;
                    document.getElementById('roomPasswordInput').value = roomPassword;
                    await createOrJoinRoom();
                } else {
                    showLobby();
                }
                
            } else {
                // Sign in
                const identity = await loadUserIdentity(username, password);
                
                if (identity) {
                    currentUser = identity;
                    debug('Signed in: ' + identity.userId);
                    
                    // Handle room if specified
                    if (roomId) {
                        showChatScreen();
                        document.getElementById('roomIdInput').value = roomId;
                        document.getElementById('roomPasswordInput').value = roomPassword;
                        await createOrJoinRoom();
                    } else {
                        showLobby();
                    }
                } else {
                    alert('Invalid username or password');
                }
            }
        }
        
        function showLobby() {
            document.getElementById('authScreen').classList.add('hide');
            document.getElementById('chatScreen').classList.remove('hide');
            document.getElementById('roomLobby').classList.add('active');
            document.getElementById('chatContainer').classList.add('hide');
            
            // Update lobby UI
            document.getElementById('lobbyUsername').textContent = currentUser.username;
            
            // Load saved rooms
            loadSavedRooms();
        }
        
        async function loadSavedRooms() {
            if (!masterKey) return;
            
            const stored = localStorage.getItem('chat_rooms');
            if (!stored) return;
            
            try {
                const rooms = await decryptData(stored, masterKey);
                const roomsList = document.getElementById('savedRoomsList');
                
                if (Object.keys(rooms).length === 0) {
                    roomsList.innerHTML = '<div style="color: #999; font-size: 13px;">No saved rooms yet</div>';
                } else {
                    roomsList.innerHTML = '';
                    
                    // Sort by last accessed
                    const sortedRooms = Object.values(rooms).sort((a, b) => 
                        new Date(b.lastAccessed) - new Date(a.lastAccessed)
                    );
                    
                    sortedRooms.forEach(room => {
                        const roomEl = document.createElement('div');
                        roomEl.className = 'room-item';
                        roomEl.onclick = () => rejoinRoom(room.roomId, room.hasPassword);
                        
                        const msgCount = room.messages?.length || 0;
                        const lastAccessed = new Date(room.lastAccessed).toLocaleDateString();
                        
                        roomEl.innerHTML = `
                            <div class="room-item-info">
                                <div class="room-item-name">${room.roomId}</div>
                                <div class="room-item-meta">${msgCount} messages • Last: ${lastAccessed}</div>
                            </div>
                            <div class="room-item-badge">${room.hasPassword ? '🔐🔐' : '🔐'}</div>
                        `;
                        
                        roomsList.appendChild(roomEl);
                    });
                }
                
                // Also show recent rooms on login screen
                updateRecentRoomsOnLogin();
                
            } catch (e) {
                debug('Could not load saved rooms: ' + e.message);
            }
        }
        
        async function updateRecentRoomsOnLogin() {
            // Only show for returning users
            if (!isSignUp) {
                const stored = localStorage.getItem('chat_user');
                if (!stored) return;
                
                // Try to get basic room info without password (just show they exist)
                const recentSection = document.getElementById('recentRooms');
                const recentList = document.getElementById('recentRoomsList');
                
                try {
                    // Just show that user has saved rooms
                    const roomsData = localStorage.getItem('chat_rooms');
                    if (roomsData) {
                        recentSection.classList.remove('hide');
                        recentList.innerHTML = '<div style="color: #666; font-size: 12px;">Your saved rooms will be available after login</div>';
                    }
                } catch (e) {
                    // Ignore
                }
            }
        }
        
        async function rejoinRoom(roomId, hasPassword) {
            let roomPassword = '';
            if (hasPassword) {
                roomPassword = prompt('Enter room password:');
                if (!roomPassword) return;
            }
            
            showChatScreen();
            document.getElementById('roomIdInput').value = roomId;
            document.getElementById('roomPasswordInput').value = roomPassword;
            await createOrJoinRoom();
        }
        
        function showCreateRoom() {
            const roomId = prompt('Enter room name (or leave empty for random):');
            const roomPassword = prompt('Enter room password (or leave empty for single encryption):');
            
            showChatScreen();
            document.getElementById('roomIdInput').value = roomId || '';
            document.getElementById('roomPasswordInput').value = roomPassword || '';
            createOrJoinRoom();
        }
        
        function showJoinRoom() {
            const invite = prompt('Enter invite link or room ID:');
            if (!invite) return;
            
            showChatScreen();
            document.getElementById('roomIdInput').value = invite;
            createOrJoinRoom();
        }
        
        function showChatScreen() {
            document.getElementById('authScreen').classList.add('hide');
            document.getElementById('chatScreen').classList.remove('hide');
            document.getElementById('roomLobby').classList.remove('active');
            document.getElementById('chatContainer').classList.remove('hide');
            
            // Update UI with user info
            const initials = currentUser.username.substring(0, 2).toUpperCase();
            document.getElementById('userAvatar').textContent = initials;
            document.getElementById('userName').textContent = currentUser.username;
            document.getElementById('userId').textContent = currentUser.userId.substring(0, 8) + '...';
            
            updateStorageStats();
        }
        
        function signOut() {
            // Clean up connections
            if (signaler) {
                signaler.close();
                signaler = null;
            }
            
            peers.clear();
            currentUser = null;
            currentRoom = null;
            masterKey = null;
            
            // Clear form fields
            document.getElementById('authUsername').value = '';
            document.getElementById('authPassword').value = '';
            document.getElementById('authRoomId').value = '';
            document.getElementById('authRoomPassword').value = '';
            
            // Reset UI
            document.getElementById('authScreen').classList.remove('hide');
            document.getElementById('chatScreen').classList.add('hide');
            document.getElementById('roomLobby').classList.remove('active');
            document.getElementById('chatContainer').classList.add('hide');
            
            debug('Signed out');
        }
        
        function backToLobby() {
            // Clean up current room
            if (signaler) {
                signaler.close();
                signaler = null;
            }
            
            peers.clear();
            currentRoom = null;
            
            // Clear messages
            document.getElementById('messagesContainer').innerHTML = 
                '<div class="message system"><div>Create or join a room to start chatting</div></div>';
            
            // Reset room UI
            document.getElementById('roomName').textContent = 'No Room';
            document.getElementById('encryptionBadge').classList.add('hide');
            document.getElementById('inviteButton').disabled = true;
            document.getElementById('messageInput').disabled = true;
            document.getElementById('sendButton').disabled = true;
            
            // Show lobby
            document.getElementById('roomLobby').classList.add('active');
            document.getElementById('chatContainer').classList.add('hide');
            
            // Reload saved rooms
            loadSavedRooms();
            
            debug('Returned to lobby');
        }
        
        // ============= ROOM FUNCTIONS =============
        
        async function createOrJoinRoom() {
            const roomIdInput = document.getElementById('roomIdInput').value.trim();
            const roomPassword = document.getElementById('roomPasswordInput').value;
            
            // Parse invite link if provided
            if (roomIdInput.includes('#')) {
                await joinRoomFromInvite(roomIdInput);
                return;
            }
            
            // Create new room or join by ID
            const roomId = roomIdInput || 'room-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
            
            // Generate invite key
            inviteKey = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            
            // Setup room
            currentRoom = {
                roomId: roomId,
                roomName: roomId,
                created: new Date().toISOString(),
                hasPassword: !!roomPassword,
                messages: [],
                peers: new Map()
            };
            
            // Generate password key if needed
            if (roomPassword) {
                const salt = crypto.getRandomValues(new Uint8Array(16));
                passwordKey = await deriveKeyFromPassword(roomPassword, salt);
                currentRoom.passwordSalt = btoa(String.fromCharCode(...salt));
                currentRoom.password = roomPassword;  // Store for display
            }
            
            // Load history if exists
            const history = await loadRoomHistory(roomId);
            if (history) {
                currentRoom.messages = history.messages || [];
                addSystemMessage(`Loaded ${currentRoom.messages.length} messages from history`);
                
                // Restore messages to UI
                currentRoom.messages.forEach(msg => {
                    displayMessage(msg, false);  // false = don't save again
                });
            }
            
            // Update UI
            document.getElementById('roomName').textContent = roomId;
            document.getElementById('encryptionBadge').classList.remove('hide');
            document.getElementById('encryptionBadge').className = 
                roomPassword ? 'encryption-badge double' : 'encryption-badge';
            document.getElementById('encryptionBadge').textContent = 
                roomPassword ? '🔐🔐 Double Encrypted' : '🔐 Encrypted';
            
            document.getElementById('inviteButton').disabled = false;
            document.getElementById('messageInput').disabled = false;
            document.getElementById('sendButton').disabled = false;
            
            // Start WebRTC signaling
            startSignaling();
            
            debug(`Created/joined room: ${roomId}`);
        }
        
        async function joinRoomFromInvite(inviteUrl) {
            try {
                const hash = inviteUrl.split('#')[1];
                const inviteData = JSON.parse(atob(hash));
                
                // Import invite key
                const keyData = Uint8Array.from(atob(inviteData.key), c => c.charCodeAt(0));
                inviteKey = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    'AES-GCM',
                    true,
                    ['encrypt', 'decrypt']
                );
                
                currentRoom = {
                    roomId: inviteData.roomId,
                    roomName: inviteData.roomId,
                    created: new Date().toISOString(),
                    hasPassword: inviteData.hasPassword,
                    messages: [],
                    peers: new Map()
                };
                
                // Handle password if needed
                if (inviteData.hasPassword) {
                    const password = prompt('This room requires a password:');
                    if (!password) {
                        alert('Password required');
                        return;
                    }
                    
                    const saltBytes = Uint8Array.from(atob(inviteData.salt), c => c.charCodeAt(0));
                    passwordKey = await deriveKeyFromPassword(password, saltBytes);
                    currentRoom.password = password;
                }
                
                // Load history
                const history = await loadRoomHistory(inviteData.roomId);
                if (history) {
                    currentRoom.messages = history.messages || [];
                    addSystemMessage(`Loaded ${currentRoom.messages.length} messages from history`);
                    currentRoom.messages.forEach(msg => {
                        displayMessage(msg, false);
                    });
                }
                
                // Update UI
                document.getElementById('roomName').textContent = inviteData.roomId;
                document.getElementById('encryptionBadge').classList.remove('hide');
                document.getElementById('encryptionBadge').className = 
                    inviteData.hasPassword ? 'encryption-badge double' : 'encryption-badge';
                document.getElementById('encryptionBadge').textContent = 
                    inviteData.hasPassword ? '🔐🔐 Double Encrypted' : '🔐 Encrypted';
                
                document.getElementById('inviteButton').disabled = false;
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
                
                startSignaling();
                
                debug(`Joined room from invite: ${inviteData.roomId}`);
            } catch (e) {
                alert('Invalid invite link');
                debug('Failed to join: ' + e.message);
            }
        }
        
        // ============= MESSAGING =============
        
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            if (!text || !currentRoom) return;
            
            // Create message object
            const message = {
                id: 'msg-' + Date.now() + Math.random().toString(36).substr(2, 5),
                userId: currentUser.userId,
                username: currentUser.username,
                content: text,
                timestamp: new Date().toISOString()
            };
            
            // Sign message
            message.signature = await signMessage(
                { content: message.content, timestamp: message.timestamp },
                currentUser.keyPair.privateKey
            );
            
            // Display locally
            displayMessage({ ...message, verified: true }, true);
            
            // Send to peers
            broadcastToPeers({
                type: 'message',
                message: message,
                publicKey: currentUser.publicKeyData
            });
            
            input.value = '';
            debug('Message sent and signed');
        }
        
        async function handleIncomingMessage(data, peerId) {
            const { message, publicKey } = data;
            
            // Import sender's public key
            const senderKey = await importKey(publicKey, true);
            
            // Verify signature
            const verified = await verifySignature(
                { content: message.content, timestamp: message.timestamp },
                message.signature,
                senderKey
            );
            
            // Display with verification status
            displayMessage({ ...message, verified }, true);
            
            if (!verified) {
                debug(`⚠️ Signature verification failed for message from ${message.username}`);
            } else {
                debug(`✓ Verified message from ${message.username}`);
            }
        }
        
        function displayMessage(message, save = true) {
            const container = document.getElementById('messagesContainer');
            
            const messageEl = document.createElement('div');
            messageEl.className = 'message';
            
            if (message.userId === currentUser?.userId) {
                messageEl.classList.add('own');
            }
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = message.username.substring(0, 2).toUpperCase();
            
            const content = document.createElement('div');
            content.className = 'message-content';
            
            const header = document.createElement('div');
            header.className = 'message-header';
            
            header.innerHTML = `
                <span class="message-author">${message.username}</span>
                <span class="message-time">${new Date(message.timestamp).toLocaleTimeString()}</span>
                ${message.verified ? '<span class="message-verified">✓ Verified</span>' : ''}
            `;
            
            const text = document.createElement('div');
            text.className = 'message-text';
            text.textContent = message.content;
            
            content.appendChild(header);
            content.appendChild(text);
            
            messageEl.appendChild(avatar);
            messageEl.appendChild(content);
            
            container.appendChild(messageEl);
            container.scrollTop = container.scrollHeight;
            
            // Save to room history
            if (save && currentRoom) {
                currentRoom.messages.push(message);
                saveRoomHistory();
            }
        }
        
        function addSystemMessage(text) {
            const container = document.getElementById('messagesContainer');
            
            const messageEl = document.createElement('div');
            messageEl.className = 'message system';
            messageEl.innerHTML = `<div>${text}</div>`;
            
            container.appendChild(messageEl);
            container.scrollTop = container.scrollHeight;
        }
        
        // ============= WEBRTC FUNCTIONS =============
        
        function startSignaling() {
            if (!currentRoom) return;
            
            signaler = new BroadcastChannel(`chat-${currentRoom.roomId}`);
            
            signaler.onmessage = async (event) => {
                const { from, data } = event.data;
                
                if (from === currentUser.userId) return;
                
                await handleSignal(from, data);
            };
            
            // Announce presence
            announcePresence();
            setInterval(() => {
                if (currentRoom) announcePresence();
            }, 3000);
            
            debug('WebRTC signaling started');
        }
        
        function announcePresence() {
            if (!signaler || !currentRoom) return;
            
            signaler.postMessage({
                from: currentUser.userId,
                data: {
                    type: 'announce',
                    username: currentUser.username,
                    publicKey: currentUser.publicKeyData,
                    hasPassword: currentRoom.hasPassword
                }
            });
        }
        
        async function handleSignal(from, data) {
            switch (data.type) {
                case 'announce':
                    if (!peers.has(from)) {
                        // Verify encryption match
                        if (currentRoom.hasPassword !== data.hasPassword) {
                            debug(`Encryption mismatch with ${data.username}`);
                            return;
                        }
                        
                        await createPeerConnection(from, data.username, data.publicKey, true);
                    }
                    break;
                    
                case 'offer':
                    if (!peers.has(from)) {
                        await createPeerConnection(from, data.username, data.publicKey, false);
                        const peer = peers.get(from);
                        await peer.pc.setRemoteDescription(data.offer);
                        
                        const answer = await peer.pc.createAnswer();
                        await peer.pc.setLocalDescription(answer);
                        
                        signaler.postMessage({
                            from: currentUser.userId,
                            data: {
                                type: 'answer',
                                answer: answer,
                                target: from,
                                username: currentUser.username
                            }
                        });
                    }
                    break;
                    
                case 'answer':
                    if (data.target === currentUser.userId && peers.has(from)) {
                        const peer = peers.get(from);
                        await peer.pc.setRemoteDescription(data.answer);
                    }
                    break;
                    
                case 'ice':
                    if (data.target === currentUser.userId && peers.has(from)) {
                        const peer = peers.get(from);
                        await peer.pc.addIceCandidate(data.candidate);
                    }
                    break;
            }
        }
        
        async function createPeerConnection(peerId, username, publicKey, createOffer) {
            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });
            
            const peer = {
                id: peerId,
                username: username,
                publicKey: publicKey,
                pc: pc,
                channel: null
            };
            
            peers.set(peerId, peer);
            
            pc.onicecandidate = (event) => {
                if (event.candidate && signaler) {
                    signaler.postMessage({
                        from: currentUser.userId,
                        data: {
                            type: 'ice',
                            candidate: event.candidate,
                            target: peerId
                        }
                    });
                }
            };
            
            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'connected') {
                    updatePeersList();
                } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    peers.delete(peerId);
                    updatePeersList();
                }
            };
            
            if (createOffer) {
                peer.channel = pc.createDataChannel('chat');
                setupDataChannel(peer);
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                signaler.postMessage({
                    from: currentUser.userId,
                    data: {
                        type: 'offer',
                        offer: offer,
                        username: currentUser.username,
                        publicKey: currentUser.publicKeyData
                    }
                });
            } else {
                pc.ondatachannel = (event) => {
                    peer.channel = event.channel;
                    setupDataChannel(peer);
                };
            }
        }
        
        function setupDataChannel(peer) {
            const channel = peer.channel;
            
            channel.onopen = () => {
                addSystemMessage(`${peer.username} joined`);
                updatePeersList();
                
                // Send history sync offer
                if (currentRoom.messages.length > 0) {
                    // We'll implement this in Phase 2
                }
            };
            
            channel.onmessage = async (event) => {
                try {
                    // Decrypt (double if password)
                    let decrypted = event.data;
                    
                    if (inviteKey) {
                        const keyData = Uint8Array.from(atob(await exportKeySimple(inviteKey)), c => c.charCodeAt(0));
                        const key = await crypto.subtle.importKey(
                            'raw',
                            keyData,
                            'AES-GCM',
                            true,
                            ['encrypt', 'decrypt']
                        );
                        decrypted = await decryptData(event.data, key);
                        
                        if (decrypted.doubleEncrypted && passwordKey) {
                            decrypted = await decryptData(decrypted.data, passwordKey);
                        }
                    }
                    
                    if (decrypted.type === 'message') {
                        await handleIncomingMessage(decrypted, peer.id);
                    }
                } catch (e) {
                    debug('Decryption error: ' + e.message);
                }
            };
            
            channel.onclose = () => {
                addSystemMessage(`${peer.username} left`);
                peers.delete(peer.id);
                updatePeersList();
            };
        }
        
        async function broadcastToPeers(data) {
            let encrypted = data;
            
            // Encrypt with room keys
            if (passwordKey) {
                encrypted = await encryptData(data, passwordKey);
                encrypted = { doubleEncrypted: true, data: encrypted };
            }
            
            if (inviteKey) {
                const keyData = Uint8Array.from(atob(await exportKeySimple(inviteKey)), c => c.charCodeAt(0));
                const key = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    'AES-GCM',
                    true,
                    ['encrypt', 'decrypt']
                );
                encrypted = await encryptData(encrypted, key);
            }
            
            // Send to all peers
            let sent = 0;
            peers.forEach(peer => {
                if (peer.channel && peer.channel.readyState === 'open') {
                    peer.channel.send(encrypted);
                    sent++;
                }
            });
            
            debug(`Broadcast to ${sent} peers`);
        }
        
        async function exportKeySimple(key) {
            const exported = await crypto.subtle.exportKey('raw', key);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }
        
        function updatePeersList() {
            const container = document.getElementById('peersList');
            
            if (peers.size === 0) {
                container.innerHTML = '<div style="color: #999; font-size: 13px;">No peers connected</div>';
            } else {
                container.innerHTML = '';
                peers.forEach(peer => {
                    const item = document.createElement('div');
                    item.className = 'peer-item';
                    item.innerHTML = `
                        <div class="peer-status"></div>
                        <span>${peer.username}</span>
                    `;
                    container.appendChild(item);
                });
            }
        }
        
        // ============= UI FUNCTIONS =============
        
        async function showInviteModal() {
            if (!currentRoom) return;
            
            const inviteData = {
                roomId: currentRoom.roomId,
                key: await exportKeySimple(inviteKey),
                hasPassword: currentRoom.hasPassword
            };
            
            if (currentRoom.hasPassword) {
                inviteData.salt = currentRoom.passwordSalt;
                document.getElementById('passwordWarning').classList.remove('hide');
                document.getElementById('roomPasswordDisplay').textContent = currentRoom.password;
            } else {
                document.getElementById('passwordWarning').classList.add('hide');
            }
            
            const inviteLink = window.location.origin + window.location.pathname + '#' + btoa(JSON.stringify(inviteData));
            document.getElementById('inviteLinkBox').textContent = inviteLink;
            document.getElementById('inviteModal').classList.add('active');
        }
        
        function closeInviteModal() {
            document.getElementById('inviteModal').classList.remove('active');
        }
        
        function copyInviteLink() {
            const link = document.getElementById('inviteLinkBox').textContent;
            navigator.clipboard.writeText(link).then(() => {
                alert('Invite link copied!');
            });
        }
        
        function debug(message) {
            console.log('[DEBUG]', message);
            
            const debugContent = document.getElementById('debugContent');
            const line = document.createElement('div');
            line.className = 'debug-line';
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugContent.appendChild(line);
            
            // Keep only last 10 lines
            while (debugContent.children.length > 10) {
                debugContent.removeChild(debugContent.firstChild);
            }
        }
        
        // ============= INITIALIZATION =============
        
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        
        // Check for room in URL
        function checkURLForRoom() {
            const hash = window.location.hash;
            if (hash) {
                // Could be an invite link or just a room ID
                if (hash.includes('{')) {
                    // It's an invite link
                    document.getElementById('authRoomId').value = window.location.href;
                } else {
                    // Just a room ID
                    document.getElementById('authRoomId').value = hash.substring(1);
                }
            }
        }
        
        // Check for existing session and URL params
        window.addEventListener('load', () => {
            debug('App initialized - Decentralized Chat v1.0');
            checkURLForRoom();
            
            // Show recent rooms hint for returning users
            const stored = localStorage.getItem('chat_user');
            if (stored && !isSignUp) {
                updateRecentRoomsOnLogin();
            }
        });
        
        // Handle username focus
        document.getElementById('authUsername').addEventListener('blur', () => {
            if (!isSignUp) {
                updateRecentRoomsOnLogin();
            }
        });
    </script>
</body>
</html>
