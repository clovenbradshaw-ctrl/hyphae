<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relay Mesh Chat - Fixed</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .network-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .content {
            padding: 20px;
        }
        
        .button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .button.success {
            background: #10b981;
            color: white;
        }
        
        .button.secondary {
            background: #f3f4f6;
            color: #374151;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        input, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 1em;
        }
        
        .room-display {
            background: linear-gradient(135deg, #ec4899 0%, #f97316 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
        }
        
        .room-code {
            font-size: 2.5em;
            font-weight: bold;
            letter-spacing: 3px;
            margin: 10px 0;
        }
        
        .connection-box {
            background: #f9fafb;
            border: 2px dashed #9ca3af;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            position: relative;
        }
        
        .connection-code {
            font-family: monospace;
            font-size: 0.85em;
            word-break: break-all;
            max-height: 120px;
            overflow-y: auto;
            padding: 10px;
            background: white;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .step {
            background: #f9fafb;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        
        .step-number {
            display: inline-block;
            width: 30px;
            height: 30px;
            background: #667eea;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .peers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .peer-card {
            background: #f3f4f6;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            position: relative;
        }
        
        .peer-card.connected {
            background: #d1fae5;
            border: 2px solid #10b981;
        }
        
        .peer-card.pending {
            background: #fef3c7;
            border: 2px solid #f59e0b;
        }
        
        .peer-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            margin: 0 auto 10px;
        }
        
        .peer-name {
            font-weight: bold;
            color: #1f2937;
        }
        
        .peer-status {
            font-size: 0.85em;
            color: #6b7280;
            margin-top: 5px;
        }
        
        .connection-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .chat-container {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            height: 400px;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        }
        
        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: white;
        }
        
        .message {
            margin-bottom: 15px;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateY(10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        .message-bubble {
            display: inline-block;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 70%;
            word-wrap: break-word;
        }
        
        .message.own {
            text-align: right;
        }
        
        .message.own .message-bubble {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .message.peer .message-bubble {
            background: #f3f4f6;
            color: #1f2937;
        }
        
        .message.system {
            text-align: center;
            font-style: italic;
            color: #6b7280;
            font-size: 0.9em;
        }
        
        .message-author {
            font-size: 0.8em;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .chat-input {
            display: flex;
            padding: 15px;
            background: #f9fafb;
            border-top: 2px solid #e5e7eb;
            gap: 10px;
        }
        
        .chat-input input {
            flex: 1;
            margin: 0;
        }
        
        .chat-input button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .success-message {
            background: #d1fae5;
            color: #065f46;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
        }
        
        .info-box {
            background: #eff6ff;
            border: 2px solid #3b82f6;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .info-box h4 {
            color: #1e40af;
            margin-bottom: 10px;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÑ Relay Mesh Chat</h1>
            <p>Smart connection relay system</p>
            <div class="network-status" id="networkStatus">
                <span>üì° Ready</span>
            </div>
        </div>
        
        <div class="content">
            <!-- Initial Setup -->
            <div id="setupScreen">
                <input type="text" id="userName" placeholder="Enter your name">
                
                <button class="button primary" onclick="createRoom()">
                    üè† Create New Room
                </button>
                
                <button class="button secondary" onclick="showJoinScreen()">
                    üîó Join Existing Room
                </button>
            </div>
            
            <!-- Create Room (Person A) -->
            <div id="createRoomScreen" style="display: none;">
                <div class="room-display">
                    <p>Room Created!</p>
                    <div class="room-code" id="roomCode"></div>
                </div>
                
                <div class="info-box">
                    <h4>How the relay system works:</h4>
                    <p>1. You create an offer and send it to Person B</p>
                    <p>2. Person B sends back an answer</p>
                    <p>3. You both connect!</p>
                </div>
                
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>Creating your offer...</strong>
                    <div class="connection-code" id="hostInvite">Generating...</div>
                    <button class="button secondary hidden" id="copyHostInviteBtn" onclick="copyHostInvite()">
                        üìã Copy Invite
                    </button>
                </div>
                
                <div class="step" id="hostWaitingStep">
                    <span class="step-number">2</span>
                    <strong>Waiting for them to respond...</strong>
                    <textarea id="hostReceiveResponse" placeholder="Paste their response here"></textarea>
                    <button class="button success" onclick="hostProcessResponse()">
                        Complete Connection
                    </button>
                </div>
                
                <button class="button primary" onclick="enterChat()" style="display: none;" id="hostEnterChat">
                    üí¨ Enter Chat Room
                </button>
            </div>
            
            <!-- Join Room (Person B, C, etc.) -->
            <div id="joinRoomScreen" style="display: none;">
                <h2>Join Room</h2>
                
                <input type="text" id="joinerName" placeholder="Your name">
                
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>Paste the invite from a room member:</strong>
                    <textarea id="joinInvite" placeholder="Paste invite here"></textarea>
                    <button class="button primary" onclick="processInvite()">
                        Process Invite
                    </button>
                </div>
                
                <div class="step" id="joinResponseStep" style="display: none;">
                    <span class="step-number">2</span>
                    <strong>Creating your answer...</strong>
                    <div class="connection-code" id="joinResponse">Generating...</div>
                    <button class="button secondary hidden" id="copyJoinResponseBtn" onclick="copyJoinResponse()">
                        üìã Copy Response
                    </button>
                    <p style="margin-top: 10px; color: #6b7280;">
                        Once they confirm, you'll be connected!
                    </p>
                </div>
                
                <button class="button primary" onclick="enterChat()" style="display: none;" id="joinerEnterChat">
                    üí¨ Enter Chat Room
                </button>
            </div>
            
            <!-- Chat Room -->
            <div id="chatScreen" style="display: none;">
                <div class="peers-grid" id="peersGrid"></div>
                
                <div class="chat-container">
                    <div class="chat-messages" id="messages"></div>
                    <div class="chat-input">
                        <input type="text" id="messageInput" placeholder="Type a message..." onkeypress="if(event.key==='Enter') sendMessage()">
                        <button onclick="sendMessage()">Send</button>
                    </div>
                </div>
                
                <button class="button success" onclick="inviteNewPerson()">
                    + Invite Someone New
                </button>
                
                <div id="inviteSection" style="display: none;">
                    <div class="connection-box">
                        <h3>Invite New Person</h3>
                        <p>They'll connect to everyone in the room!</p>
                        <div class="connection-code" id="relayInvite">Generating...</div>
                        <button class="button secondary" onclick="copyRelayInvite()">
                            üìã Copy Invite
                        </button>
                        
                        <p style="margin-top: 15px;">When they respond, paste here:</p>
                        <textarea id="relayResponse" placeholder="Paste their response"></textarea>
                        <button class="button success" onclick="processRelayResponse()">
                            Connect Them
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global mesh state
        class MeshNetwork {
            constructor() {
                this.myId = this.generateId();
                this.myName = '';
                this.roomId = null;
                this.peers = new Map(); // peerId -> {name, pc, dc, status}
                this.messageQueue = new Map(); // peerId -> [messages] for pending connections
                this.relayOffers = new Map(); // Store relay offers waiting to be processed
            }
            
            generateId() {
                return Math.random().toString(36).substring(2, 15);
            }
            
            // Create a peer connection with better state management
            createPeerConnection(peerId, isInitiator = true) {
                console.log(`Creating peer connection for ${peerId}, initiator: ${isInitiator}`);
                
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });
                
                // Initialize or update peer info
                const peer = this.peers.get(peerId) || {};
                peer.pc = pc;
                peer.peerId = peerId; // Store the peer ID with the peer object
                peer.status = 'connecting';
                peer.iceCandidates = [];
                peer.isInitiator = isInitiator;
                this.peers.set(peerId, peer);
                
                // ICE candidate collection
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const currentPeer = this.peers.get(peerId);
                        if (currentPeer) {
                            currentPeer.iceCandidates.push(event.candidate.toJSON());
                        }
                    }
                };
                
                // Data channel setup
                if (isInitiator) {
                    console.log('Creating data channel as initiator');
                    const dc = pc.createDataChannel('chat');
                    peer.dc = dc;
                    this.setupDataChannel(dc, peerId);
                } else {
                    console.log('Waiting for data channel as responder');
                    pc.ondatachannel = (event) => {
                        console.log('Data channel received');
                        const currentPeer = this.peers.get(peerId);
                        if (currentPeer) {
                            currentPeer.dc = event.channel;
                            this.setupDataChannel(event.channel, peerId);
                        }
                    };
                }
                
                // Connection state monitoring
                pc.onconnectionstatechange = () => {
                    console.log(`Connection state for ${peerId}: ${pc.connectionState}`);
                    const currentPeer = this.peers.get(peerId);
                    if (currentPeer) {
                        currentPeer.status = pc.connectionState === 'connected' ? 'connected' : 
                                          pc.connectionState === 'failed' ? 'failed' : 
                                          pc.connectionState === 'disconnected' ? 'disconnected' : 'connecting';
                        this.updatePeersDisplay();
                        
                        if (pc.connectionState === 'connected') {
                            addSystemMessage(`Connected to ${currentPeer.name || 'peer'}`);
                        } else if (pc.connectionState === 'failed') {
                            addSystemMessage(`Failed to connect to ${currentPeer.name || 'peer'}`);
                        }
                    }
                };
                
                return pc;
            }
            
            // Setup data channel handlers with proper queuing
            setupDataChannel(dc, peerId) {
                // Store reference to this mesh instance
                const mesh = this;
                
                dc.onopen = () => {
                    // Find the current peer by data channel reference
                    let currentPeerId = peerId;
                    for (const [id, peer] of mesh.peers.entries()) {
                        if (peer.dc === dc) {
                            currentPeerId = id;
                            break;
                        }
                    }
                    
                    console.log(`Data channel open with ${currentPeerId}`);
                    const peer = mesh.peers.get(currentPeerId);
                    if (peer) {
                        peer.status = 'connected';
                        peer.dcReady = true;
                        mesh.updatePeersDisplay();
                        
                        // Send introduction
                        mesh.sendToPeer(currentPeerId, {
                            type: 'intro',
                            id: mesh.myId,
                            name: mesh.myName
                        });
                        
                        // Flush message queue for this peer
                        mesh.flushMessageQueue(currentPeerId);
                        
                        // Process any waiting relay offers
                        mesh.processQueuedRelayOffers();
                    }
                };
                
                dc.onmessage = (event) => {
                    try {
                        // Find the current peer by data channel reference
                        let currentPeerId = peerId;
                        for (const [id, peer] of mesh.peers.entries()) {
                            if (peer.dc === dc) {
                                currentPeerId = id;
                                break;
                            }
                        }
                        
                        const data = JSON.parse(event.data);
                        mesh.handleMessage(data, currentPeerId);
                    } catch(e) {
                        console.error('Failed to parse message:', e);
                    }
                };
                
                dc.onerror = (error) => {
                    // Find the current peer by data channel reference
                    let currentPeerId = peerId;
                    for (const [id, peer] of mesh.peers.entries()) {
                        if (peer.dc === dc) {
                            currentPeerId = id;
                            break;
                        }
                    }
                    console.error(`Data channel error with ${currentPeerId}:`, error);
                };
                
                dc.onclose = () => {
                    // Find the current peer by data channel reference
                    let currentPeerId = peerId;
                    for (const [id, peer] of mesh.peers.entries()) {
                        if (peer.dc === dc) {
                            currentPeerId = id;
                            break;
                        }
                    }
                    
                    console.log(`Data channel closed with ${currentPeerId}`);
                    const peer = mesh.peers.get(currentPeerId);
                    if (peer) {
                        peer.dcReady = false;
                        peer.status = 'disconnected';
                        mesh.updatePeersDisplay();
                    }
                };
            }
            
            // Queue messages for peers not yet connected
            queueMessage(peerId, message) {
                if (!this.messageQueue.has(peerId)) {
                    this.messageQueue.set(peerId, []);
                }
                this.messageQueue.get(peerId).push(message);
                console.log(`Queued message for ${peerId}:`, message.type);
            }
            
            // Flush queued messages when connection opens
            flushMessageQueue(peerId) {
                const queue = this.messageQueue.get(peerId);
                if (queue && queue.length > 0) {
                    console.log(`Flushing ${queue.length} messages for ${peerId}`);
                    for (const message of queue) {
                        this.sendToPeer(peerId, message);
                    }
                    this.messageQueue.delete(peerId);
                }
            }
            
            // Handle incoming messages
            handleMessage(data, fromPeerId) {
                switch(data.type) {
                    case 'intro':
                        // For pending connections, we need to update the peer mapping
                        if (fromPeerId.startsWith('pending_')) {
                            const tempPeer = this.peers.get(fromPeerId);
                            if (tempPeer && data.id) {
                                // Move the entire peer object to the new ID
                                this.peers.delete(fromPeerId);
                                this.peers.set(data.id, tempPeer);
                                tempPeer.peerId = data.id;
                                tempPeer.name = data.name;
                                fromPeerId = data.id;
                                console.log(`Updated peer ID from pending to ${data.id}`);
                            }
                        } else {
                            // Normal intro for already-known peer
                            const peer = this.peers.get(fromPeerId);
                            if (peer) {
                                peer.name = data.name;
                            }
                        }
                        this.updatePeersDisplay();
                        addSystemMessage(`${data.name} joined the room`);
                        break;
                        
                    case 'message':
                        displayMessage(data.text, data.author, false);
                        break;
                        
                    case 'relay-offer':
                        this.handleRelayOffer(data, fromPeerId);
                        break;
                        
                    case 'relay-answer':
                        this.handleRelayAnswer(data, fromPeerId);
                        break;
                }
            }
            
            // Handle relay offer with proper queuing
            async handleRelayOffer(data, fromPeerId) {
                const { newPeerId, newPeerName, offer, iceCandidates } = data;
                
                console.log(`Received relay offer from ${fromPeerId} for new peer ${newPeerId}`);
                
                // Prevent duplicate connections
                if (this.peers.has(newPeerId)) {
                    console.log(`Already connected to ${newPeerId}, ignoring duplicate`);
                    return;
                }
                
                // Store the offer for processing
                this.relayOffers.set(newPeerId, { data, fromPeerId });
                
                // Create connection as responder
                const pc = this.createPeerConnection(newPeerId, false);
                const peer = this.peers.get(newPeerId);
                peer.name = newPeerName;
                
                try {
                    // Set the remote offer
                    await pc.setRemoteDescription(new RTCSessionDescription({
                        type: 'offer',
                        sdp: offer
                    }));
                    
                    // Add ICE candidates
                    if (iceCandidates) {
                        for (const candidate of iceCandidates) {
                            await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        }
                    }
                    
                    // Create answer
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    // Wait for ICE gathering
                    await new Promise((resolve) => {
                        if (pc.iceGatheringState === 'complete') {
                            resolve();
                        } else {
                            pc.onicegatheringstatechange = () => {
                                if (pc.iceGatheringState === 'complete') {
                                    resolve();
                                }
                            };
                            setTimeout(resolve, 3000);
                        }
                    });
                    
                    // Create answer message
                    const answerMessage = {
                        type: 'relay-answer',
                        targetPeerId: newPeerId,
                        answer: answer.sdp,
                        iceCandidates: peer.iceCandidates,
                        fromPeerId: this.myId,
                        fromPeerName: this.myName
                    };
                    
                    // Send or queue the answer
                    if (!this.sendToPeer(fromPeerId, answerMessage)) {
                        console.log(`Queuing answer for relay back to ${fromPeerId}`);
                        this.queueMessage(fromPeerId, answerMessage);
                    }
                    
                    console.log(`Processed relay offer from ${newPeerId}`);
                    
                } catch(e) {
                    console.error('Failed to handle relay offer:', e);
                }
            }
            
            // Process queued relay offers when connections are ready
            processQueuedRelayOffers() {
                // Check if we have any queued relay offers that can now be processed
                for (const [newPeerId, {data, fromPeerId}] of this.relayOffers.entries()) {
                    const fromPeer = this.peers.get(fromPeerId);
                    if (fromPeer && fromPeer.dcReady) {
                        // Connection is ready, process can continue
                        console.log(`Processing queued relay offer for ${newPeerId}`);
                    }
                }
            }
            
            // Handle relay answer with better routing
            async handleRelayAnswer(data, fromPeerId) {
                const { targetPeerId, answer, iceCandidates, fromPeerId: answerFromId, fromPeerName } = data;
                
                console.log(`Received relay answer for ${targetPeerId} from ${answerFromId}`);
                
                // Check if this answer is for us
                if (targetPeerId === this.myId) {
                    // We are the new peer receiving an answer
                    const peer = this.peers.get(answerFromId);
                    if (peer && peer.pc) {
                        try {
                            peer.name = fromPeerName;
                            
                            await peer.pc.setRemoteDescription(new RTCSessionDescription({
                                type: 'answer',
                                sdp: answer
                            }));
                            
                            if (iceCandidates) {
                                for (const candidate of iceCandidates) {
                                    await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
                                }
                            }
                            
                            console.log(`Connected to ${answerFromId} via relay`);
                            this.updatePeersDisplay();
                            
                        } catch(e) {
                            console.error('Failed to set relay answer:', e);
                        }
                    }
                } else {
                    // We are the relay, forward to target
                    console.log(`Relaying answer to ${targetPeerId}`);
                    if (!this.sendToPeer(targetPeerId, data)) {
                        // Queue for later delivery
                        console.log(`Queuing relay answer for ${targetPeerId}`);
                        this.queueMessage(targetPeerId, data);
                    }
                }
            }
            
            // Send data to a specific peer with queuing fallback
            sendToPeer(peerId, data) {
                const peer = this.peers.get(peerId);
                if (peer && peer.dc && peer.dc.readyState === 'open' && peer.dcReady) {
                    try {
                        peer.dc.send(JSON.stringify(data));
                        return true;
                    } catch(e) {
                        console.error(`Failed to send to ${peerId}:`, e);
                        return false;
                    }
                }
                // If not ready, queue the message
                this.queueMessage(peerId, data);
                return false;
            }
            
            // Broadcast to all connected peers
            broadcast(data) {
                for (const [peerId, peer] of this.peers.entries()) {
                    if (peer.dcReady) {
                        this.sendToPeer(peerId, data);
                    }
                }
            }
            
            // Update peers display
            updatePeersDisplay() {
                const grid = document.getElementById('peersGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                // Add self
                const selfCard = document.createElement('div');
                selfCard.className = 'peer-card connected';
                selfCard.innerHTML = `
                    <div class="connection-indicator"></div>
                    <div class="peer-avatar">${this.myName[0]?.toUpperCase() || '?'}</div>
                    <div class="peer-name">${this.myName} (You)</div>
                    <div class="peer-status">Connected</div>
                `;
                grid.appendChild(selfCard);
                
                // Add peers
                this.peers.forEach((peer, peerId) => {
                    const card = document.createElement('div');
                    const isConnected = peer.status === 'connected' && peer.dcReady;
                    card.className = `peer-card ${isConnected ? 'connected' : 'pending'}`;
                    card.innerHTML = `
                        ${isConnected ? '<div class="connection-indicator"></div>' : ''}
                        <div class="peer-avatar">${peer.name?.[0]?.toUpperCase() || '?'}</div>
                        <div class="peer-name">${peer.name || 'Connecting...'}</div>
                        <div class="peer-status">${peer.status}</div>
                    `;
                    grid.appendChild(card);
                });
                
                // Update network status
                const connected = Array.from(this.peers.values()).filter(p => p.status === 'connected' && p.dcReady).length;
                document.getElementById('networkStatus').innerHTML = `
                    <span>üì° ${connected} peer${connected !== 1 ? 's' : ''} connected</span>
                `;
            }
        }
        
        // Initialize mesh network
        const mesh = new MeshNetwork();
        
        // Create room (Person A - Host)
        async function createRoom() {
            const name = document.getElementById('userName').value.trim();
            if (!name) {
                alert('Please enter your name');
                return;
            }
            
            mesh.myName = name;
            mesh.roomId = mesh.generateId().substring(0, 8).toUpperCase();
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('createRoomScreen').style.display = 'block';
            document.getElementById('roomCode').textContent = mesh.roomId;
            
            // Create initial offer for first joiner
            setTimeout(async () => {
                try {
                    const tempPeerId = 'pending_' + Date.now();
                    const pc = mesh.createPeerConnection(tempPeerId, true);
                    
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // Wait for ICE gathering
                    await new Promise((resolve) => {
                        if (pc.iceGatheringState === 'complete') {
                            resolve();
                        } else {
                            pc.onicegatheringstatechange = () => {
                                if (pc.iceGatheringState === 'complete') {
                                    resolve();
                                }
                            };
                            setTimeout(resolve, 3000);
                        }
                    });
                    
                    const peer = mesh.peers.get(tempPeerId);
                    const invite = {
                        type: 'host-offer',
                        roomId: mesh.roomId,
                        hostId: mesh.myId,
                        hostName: mesh.myName,
                        offer: offer.sdp,
                        iceCandidates: peer.iceCandidates
                    };
                    
                    document.getElementById('hostInvite').textContent = btoa(JSON.stringify(invite));
                    document.getElementById('copyHostInviteBtn').classList.remove('hidden');
                } catch(e) {
                    console.error('Failed to create offer:', e);
                }
            }, 100);
        }
        
        // Copy host invite
        function copyHostInvite() {
            const text = document.getElementById('hostInvite').textContent;
            navigator.clipboard.writeText(text);
            alert('Invite copied! Send it to someone to join.');
        }
        
        // Host processes response from Person B
        async function hostProcessResponse() {
            const response = document.getElementById('hostReceiveResponse').value.trim();
            if (!response) {
                alert('Please paste the response');
                return;
            }
            
            try {
                const data = JSON.parse(atob(response));
                
                // Find pending connection
                let pc = null;
                let tempPeerId = null;
                let tempPeer = null;
                
                for (const [id, peer] of mesh.peers.entries()) {
                    if (id.startsWith('pending_')) {
                        pc = peer.pc;
                        tempPeerId = id;
                        tempPeer = peer;
                        break;
                    }
                }
                
                if (!pc) {
                    throw new Error('No pending connection found');
                }
                
                // Set remote description first
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'answer',
                    sdp: data.answer
                }));
                
                // Add ICE candidates
                if (data.iceCandidates) {
                    for (const candidate of data.iceCandidates) {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    }
                }
                
                // Update peer info - but keep the pending ID for now
                // It will be updated when we receive the intro message
                tempPeer.name = data.name;
                tempPeer.expectedRealId = data.peerId;
                
                document.getElementById('hostEnterChat').style.display = 'block';
                addSystemMessage(`Connecting to ${data.name}...`);
                
            } catch (e) {
                alert('Invalid response: ' + e.message);
                console.error(e);
            }
        }
        
        // Show join screen
        function showJoinScreen() {
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('joinRoomScreen').style.display = 'block';
        }
        
        // Process invite (Person B or C+)
        async function processInvite() {
            const name = document.getElementById('joinerName').value.trim();
            const invite = document.getElementById('joinInvite').value.trim();
            
            if (!name || !invite) {
                alert('Please enter your name and paste the invite');
                return;
            }
            
            mesh.myName = name;
            
            try {
                const data = JSON.parse(atob(invite));
                mesh.roomId = data.roomId;
                
                if (data.type === 'host-offer') {
                    // Direct connection to host
                    const pc = mesh.createPeerConnection(data.hostId, false);
                    const peer = mesh.peers.get(data.hostId);
                    peer.name = data.hostName;
                    
                    await pc.setRemoteDescription(new RTCSessionDescription({
                        type: 'offer',
                        sdp: data.offer
                    }));
                    
                    if (data.iceCandidates) {
                        for (const candidate of data.iceCandidates) {
                            await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        }
                    }
                    
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    // Wait for ICE
                    await new Promise((resolve) => {
                        if (pc.iceGatheringState === 'complete') {
                            resolve();
                        } else {
                            pc.onicegatheringstatechange = () => {
                                if (pc.iceGatheringState === 'complete') {
                                    resolve();
                                }
                            };
                            setTimeout(resolve, 3000);
                        }
                    });
                    
                    const response = {
                        peerId: mesh.myId,
                        name: mesh.myName,
                        answer: answer.sdp,
                        iceCandidates: peer.iceCandidates
                    };
                    
                    document.getElementById('joinResponse').textContent = btoa(JSON.stringify(response));
                    document.getElementById('joinResponseStep').style.display = 'block';
                    document.getElementById('copyJoinResponseBtn').classList.remove('hidden');
                    document.getElementById('joinerEnterChat').style.display = 'block';
                    
                } else if (data.type === 'relay-invite') {
                    // Create offers for all existing peers
                    const offers = [];
                    
                    for (const peerInfo of data.existingPeers) {
                        if (peerInfo.id !== mesh.myId) {
                            const pc = mesh.createPeerConnection(peerInfo.id, true);
                            const peer = mesh.peers.get(peerInfo.id);
                            peer.name = peerInfo.name;
                            
                            const offer = await pc.createOffer();
                            await pc.setLocalDescription(offer);
                            
                            await new Promise((resolve) => {
                                if (pc.iceGatheringState === 'complete') {
                                    resolve();
                                } else {
                                    pc.onicegatheringstatechange = () => {
                                        if (pc.iceGatheringState === 'complete') {
                                            resolve();
                                        }
                                    };
                                    setTimeout(resolve, 3000);
                                }
                            });
                            
                            offers.push({
                                targetId: peerInfo.id,
                                offer: offer.sdp,
                                iceCandidates: peer.iceCandidates
                            });
                        }
                    }
                    
                    const response = {
                        type: 'relay-response',
                        newPeerId: mesh.myId,
                        newPeerName: mesh.myName,
                        offers: offers
                    };
                    
                    document.getElementById('joinResponse').textContent = btoa(JSON.stringify(response));
                    document.getElementById('joinResponseStep').style.display = 'block';
                    document.getElementById('copyJoinResponseBtn').classList.remove('hidden');
                    document.getElementById('joinerEnterChat').style.display = 'block';
                }
                
            } catch (e) {
                alert('Invalid invite: ' + e.message);
                console.error(e);
            }
        }
        
        // Copy join response
        function copyJoinResponse() {
            const text = document.getElementById('joinResponse').textContent;
            navigator.clipboard.writeText(text);
            alert('Response copied! Send it back to the person who invited you.');
        }
        
        // Enter chat room
        function enterChat() {
            document.getElementById('createRoomScreen').style.display = 'none';
            document.getElementById('joinRoomScreen').style.display = 'none';
            document.getElementById('chatScreen').style.display = 'block';
            mesh.updatePeersDisplay();
        }
        
        // Invite new person with better connection handling
        async function inviteNewPerson() {
            const connectedPeers = [];
            mesh.peers.forEach((peer, peerId) => {
                if (peer.status === 'connected' && peer.dcReady) {
                    connectedPeers.push({
                        id: peerId,
                        name: peer.name
                    });
                }
            });
            
            const relayInvite = {
                type: 'relay-invite',
                roomId: mesh.roomId,
                inviterId: mesh.myId,
                inviterName: mesh.myName,
                existingPeers: [
                    { id: mesh.myId, name: mesh.myName },
                    ...connectedPeers
                ]
            };
            
            document.getElementById('relayInvite').textContent = btoa(JSON.stringify(relayInvite));
            document.getElementById('inviteSection').style.display = 'block';
        }
        
        // Copy relay invite
        function copyRelayInvite() {
            const text = document.getElementById('relayInvite').textContent;
            navigator.clipboard.writeText(text);
            alert('Invite copied! Send it to the new person.');
        }
        
        // Process relay response with improved connection management
        async function processRelayResponse() {
            const response = document.getElementById('relayResponse').value.trim();
            if (!response) {
                alert('Please paste their response');
                return;
            }
            
            try {
                const data = JSON.parse(atob(response));
                
                if (data.type !== 'relay-response') {
                    throw new Error('Invalid response type');
                }
                
                const { newPeerId, newPeerName, offers } = data;
                
                // Check for duplicates
                if (mesh.peers.has(newPeerId)) {
                    console.log(`Already connected to ${newPeerId}`);
                    document.getElementById('inviteSection').style.display = 'none';
                    return;
                }
                
                console.log(`Processing ${offers.length} offers from ${newPeerName}`);
                addSystemMessage(`Connecting ${newPeerName} to the mesh...`);
                
                // Process our offer first
                const ourOffer = offers.find(o => o.targetId === mesh.myId);
                if (ourOffer) {
                    const pc = mesh.createPeerConnection(newPeerId, false);
                    const peer = mesh.peers.get(newPeerId);
                    peer.name = newPeerName;
                    
                    await pc.setRemoteDescription(new RTCSessionDescription({
                        type: 'offer',
                        sdp: ourOffer.offer
                    }));
                    
                    if (ourOffer.iceCandidates) {
                        for (const candidate of ourOffer.iceCandidates) {
                            await pc.addIceCandidate(new RTCIceCandidate(candidate));
                        }
                    }
                    
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    await new Promise((resolve) => {
                        if (pc.iceGatheringState === 'complete') {
                            resolve();
                        } else {
                            pc.onicegatheringstatechange = () => {
                                if (pc.iceGatheringState === 'complete') {
                                    resolve();
                                }
                            };
                            setTimeout(resolve, 3000);
                        }
                    });
                    
                    // Queue our answer for when connection opens
                    const answerMessage = {
                        type: 'relay-answer',
                        targetPeerId: newPeerId,
                        answer: answer.sdp,
                        iceCandidates: peer.iceCandidates,
                        fromPeerId: mesh.myId,
                        fromPeerName: mesh.myName
                    };
                    
                    mesh.queueMessage(newPeerId, answerMessage);
                }
                
                // Schedule relay of other offers after a delay
                setTimeout(() => {
                    for (const offer of offers) {
                        if (offer.targetId !== mesh.myId) {
                            const relayMessage = {
                                type: 'relay-offer',
                                newPeerId: newPeerId,
                                newPeerName: newPeerName,
                                offer: offer.offer,
                                iceCandidates: offer.iceCandidates
                            };
                            
                            if (!mesh.sendToPeer(offer.targetId, relayMessage)) {
                                console.log(`Queuing relay offer for ${offer.targetId}`);
                                mesh.queueMessage(offer.targetId, relayMessage);
                            }
                        }
                    }
                }, 500);
                
                document.getElementById('inviteSection').style.display = 'none';
                document.getElementById('relayResponse').value = '';
                
            } catch (e) {
                alert('Invalid response: ' + e.message);
                console.error(e);
            }
        }
        
        // Send message
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();
            if (!text) return;
            
            const message = {
                type: 'message',
                text: text,
                author: mesh.myName,
                timestamp: Date.now()
            };
            
            mesh.broadcast(message);
            displayMessage(text, 'You', true);
            
            input.value = '';
        }
        
        // Display message
        function displayMessage(text, author, isOwn) {
            const messages = document.getElementById('messages');
            if (!messages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = isOwn ? 'message own' : 'message peer';
            
            if (!isOwn) {
                const authorDiv = document.createElement('div');
                authorDiv.className = 'message-author';
                authorDiv.textContent = author;
                messageDiv.appendChild(authorDiv);
            }
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = text;
            messageDiv.appendChild(bubble);
            
            messages.appendChild(messageDiv);
            messages.scrollTop = messages.scrollHeight;
        }
        
        // Add system message
        function addSystemMessage(text) {
            const messages = document.getElementById('messages');
            if (!messages) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.textContent = text;
            messages.appendChild(messageDiv);
            messages.scrollTop = messages.scrollHeight;
        }
    </script>
</body>
</html>
