<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EO - Emergent Organizing</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    const OPERATORS = [
      { id: 'starter', name: 'Starter', desc: 'Designs & initiates work', seq: 1, canRequestRevision: false },
      { id: 'doer', name: 'Doer', desc: 'Produces artifacts & outputs', seq: 2, canRequestRevision: false },
      { id: 'compiler', name: 'Compiler', desc: 'Packages work into reviewable form', seq: 3, canRequestRevision: false },
      { id: 'reviewer', name: 'Reviewer', desc: 'Evaluates & segments quality', seq: 4, canRequestRevision: true },
      { id: 'approver', name: 'Approver', desc: 'Alters state with authority', seq: 5, canRequestRevision: true },
      { id: 'documenter', name: 'Documenter', desc: 'Records & formalizes', seq: 6, canRequestRevision: false },
      { id: 'convener', name: 'Convener', desc: 'Assembles people & resources', seq: 7, canRequestRevision: false },
      { id: 'steward', name: 'Steward', desc: 'Supervises ongoing work', seq: 8, canRequestRevision: false },
      { id: 'coordinator', name: 'Coordinator', desc: 'Orchestrates next cycle', seq: 9, canRequestRevision: false }
    ];

    const DEFAULT_STAGE_BLUEPRINT = OPERATORS.map((op, index) => ({
      key: op.id,
      name: op.name,
      description: op.desc,
      order: index,
      supportsRevision: op.canRequestRevision
    }));

    function getStageIdentity(stage) {
      return stage?.id || stage?.key || stage?.name;
    }

    function createDefaultStages() {
      const timestamp = Date.now();
      return DEFAULT_STAGE_BLUEPRINT.map((stage, idx) => ({
        id: `stage-${timestamp}-${idx}`,
        key: stage.key,
        operatorKey: stage.key,
        name: stage.name,
        description: stage.description,
        order: idx,
        roleId: null,
        supportsRevision: stage.supportsRevision,
        conditions: '',
        skipped: false
      }));
    }

    function getOrderedStages(flow) {
      const stages = Array.isArray(flow?.stages) && flow.stages.length > 0
        ? flow.stages
        : DEFAULT_STAGE_BLUEPRINT.map((stage, idx) => ({
            key: stage.key,
            operatorKey: stage.key,
            name: stage.name,
            description: stage.description,
            order: idx,
            roleId: null,
            supportsRevision: stage.supportsRevision,
            conditions: '',
            skipped: false
          }));

      return [...stages]
        .map((stage, idx) => ({
          ...stage,
          order: stage.order ?? idx,
          operatorKey: stage.operatorKey || stage.key,
          uid: getStageIdentity(stage)
        }))
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
    }

    function findStageForRole(flow, role) {
      if (!role) return null;
      const orderedStages = getOrderedStages(flow);
      return orderedStages.find(stage => stage.operatorKey === role.operatorType || stage.key === role.operatorType) || null;
    }

    function createStageHistoryEntry(stageId, timestamp) {
      return {
        id: `stage-entry-${timestamp}-${Math.random().toString(36).slice(2, 7)}`,
        stageId,
        enteredAt: timestamp,
        exitedAt: null,
        claimedBy: null,
        claimedAt: null,
        priority: null,
        completedAt: null,
        skippedAt: null,
        log: []
      };
    }

    function getLatestStageHistoryEntry(stageHistory, stageId) {
      if (!Array.isArray(stageHistory)) return null;
      for (let i = stageHistory.length - 1; i >= 0; i--) {
        const entry = stageHistory[i];
        if (entry?.stageId === stageId) {
          return entry;
        }
      }
      return null;
    }

    function updateLatestStageHistoryEntry(stageHistory, stageId, updater, { createIfMissing = false, timestamp = Date.now() } = {}) {
      const nextHistory = Array.isArray(stageHistory) ? [...stageHistory] : [];
      for (let i = nextHistory.length - 1; i >= 0; i--) {
        if (nextHistory[i]?.stageId === stageId) {
          nextHistory[i] = updater(nextHistory[i]);
          return nextHistory;
        }
      }
      if (createIfMissing && stageId) {
        const created = updater(createStageHistoryEntry(stageId, timestamp));
        nextHistory.push(created);
      }
      return nextHistory;
    }

    function ensureStageTracking(activity, stageId, timestamp = Date.now()) {
      const currentStageId = stageId || activity.currentStageId || activity.stageId || null;
      const baseHistory = Array.isArray(activity.stageHistory) ? activity.stageHistory : [];
      let stageHistory = [...baseHistory];
      if (currentStageId && !getLatestStageHistoryEntry(stageHistory, currentStageId)) {
        stageHistory.push(createStageHistoryEntry(currentStageId, activity.createdAt || timestamp));
      }
      const stageReadBy = { ...(activity.stageReadBy || {}) };
      if (currentStageId && !stageReadBy[currentStageId]) {
        stageReadBy[currentStageId] = { ...(activity.readBy || {}) };
      }
      return { currentStageId, stageHistory, stageReadBy };
    }

    function getActivityDefaultStageId(activity, orderedStages = []) {
      if (!activity) {
        const firstStage = orderedStages[0];
        return firstStage ? getStageIdentity(firstStage) : null;
      }
      if (activity.currentStageId) return activity.currentStageId;
      if (activity.stageId) return activity.stageId;
      if (Array.isArray(activity.stageHistory) && activity.stageHistory.length > 0) {
        const lastEntry = activity.stageHistory[activity.stageHistory.length - 1];
        if (lastEntry?.stageId) return lastEntry.stageId;
      }
      const firstStage = orderedStages[0];
      return firstStage ? getStageIdentity(firstStage) : null;
    }

    function getStageStatusFromHistory(activity, stageId) {
      if (!activity || !stageId) return { completed: false, skipped: false, entry: null };
      const entry = getLatestStageHistoryEntry(activity.stageHistory, stageId);
      const completed = !!entry?.completedAt || !!activity?.completedAt;
      const skipped = !!entry?.skippedAt;
      return { completed, skipped, entry };
    }

    function getNextStageId(orderedStages, currentStageId, skippedStages = []) {
      if (!currentStageId) return null;
      const skippedSet = new Set(skippedStages || []);
      const startIndex = orderedStages.findIndex(stage => getStageIdentity(stage) === currentStageId);
      if (startIndex === -1) return null;
      for (let idx = startIndex + 1; idx < orderedStages.length; idx++) {
        const candidate = orderedStages[idx];
        const candidateId = getStageIdentity(candidate);
        if (candidate.skipped) continue;
        if (skippedSet.has(candidateId)) continue;
        return candidateId;
      }
      return null;
    }

    // Icons
    function PlusIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" /></svg>;
    }
    function ArrowLeftIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>;
    }
    function LayersIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>;
    }
    function ChevronRightIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" /></svg>;
    }
    function XIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>;
    }
    function LinkIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" /></svg>;
    }
    function ChatBubbleIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8 10h.01M12 10h.01M16 10h.01M21 12c0 1.657-1.79 3-4 3-.295 0-.582-.021-.859-.061-.284 1.193-1.355 2.06-2.641 2.06-.358 0-.703-.065-1.019-.184-.44.498-1.086.814-1.781.814-.732 0-1.392-.347-1.829-.888-.51.355-1.137.558-1.812.558-1.648 0-2.985-1.343-2.985-3 0-.333.054-.654.153-.954C3.1 12.715 2 11.477 2 10c0-1.657 1.79-3 4-3h11c2.21 0 4 1.343 4 3z" /></svg>;
    }

    function ActivityDetailPanel({ activity, role, stage, nextStage, stageMap, dependencies, project, currentUser, onClose, onEdit, onDelete, onClaim, onUnclaim, onAdvanceStage, onSkipStage, onComplete, onWire, onRequestRevision, onAddComment, onAddAttachment, onRemoveAttachment }) {
      const [commentText, setCommentText] = useState('');
      const [attachmentName, setAttachmentName] = useState('');
      const [attachmentUrl, setAttachmentUrl] = useState('');

      useEffect(() => {
        setCommentText('');
        setAttachmentName('');
        setAttachmentUrl('');
      }, [activity?.id]);

      const stageState = activity.activeStageState || activity.state || 'waiting';
      const activeEntry = activity.activeStageEntry || null;
      const claimedBy = activeEntry?.claimedBy || null;
      const priority = activeEntry?.priority || null;
      const isMine = claimedBy && claimedBy === currentUser;
      const canClaim = stageState === 'ready' && !claimedBy && role?.userIds.some(uid => project.users.find(u => u.id === uid)?.name === currentUser);
      const canComplete = isMine && stageState === 'in_progress';
      const isCompleted = !!activity.completedAt;
      const canAdvanceStage = !isCompleted && !!nextStage && stageState !== 'completed' && stageState !== 'skipped';
      const canSkipStage = !isCompleted && !!nextStage;
      const stageSupportsRevision = stage?.supportsRevision;

      const comments = [...(activity.comments || [])].sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      const history = [...(activity.history || [])].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      const stageHistory = [...(activity.stageHistory || [])];
      const stageStates = activity.stageStates || [];

      const stageStateLabel = stageState.replace('_', ' ');

      const handleAddComment = () => {
        if (!currentUser || !commentText.trim()) return;
        onAddComment(commentText);
        setCommentText('');
      };

      const handleAddAttachment = () => {
        if (!attachmentName.trim() || !currentUser) return;
        onAddAttachment({ name: attachmentName.trim(), url: attachmentUrl.trim(), addedBy: currentUser });
        setAttachmentName('');
        setAttachmentUrl('');
      };

      const renderCommentContent = (text) => {
        const parts = text.split(/(@[\w-]+)/g);
        return parts.map((part, idx) => {
          if (part.startsWith && part.startsWith('@')) {
            const name = part.slice(1);
            const isMe = currentUser && name.toLowerCase() === currentUser.toLowerCase();
            return <span key={idx} className={isMe ? 'text-blue-300 font-semibold' : 'text-blue-400'}>{part}</span>;
          }
          return <span key={idx}>{part}</span>;
        });
      };

      const actionButtons = (
        <div className="flex flex-wrap gap-2">
          {canClaim && <button onClick={() => onClaim(activity.id)} className="bg-blue-600 hover:bg-blue-700 px-3 py-1.5 rounded text-sm">Claim</button>}
          {isMine && !activity.completedAt && <button onClick={() => onUnclaim(activity.id)} className="bg-gray-700 hover:bg-gray-600 px-3 py-1.5 rounded text-sm">Unclaim</button>}
          {canAdvanceStage && <button onClick={() => onAdvanceStage(activity.id, { skip: false })} className="bg-green-600 hover:bg-green-700 px-3 py-1.5 rounded text-sm">Advance</button>}
          {canSkipStage && <button onClick={() => onSkipStage(activity.id)} className="bg-yellow-700 hover:bg-yellow-600 px-3 py-1.5 rounded text-sm text-yellow-100">Skip Stage</button>}
          {stageSupportsRevision && dependencies.length > 0 && !activity.completedAt && (
            <button onClick={() => {
              const lastDep = dependencies[dependencies.length - 1];
              if (lastDep) {
                const reason = window.prompt('Reason for revision? (optional)', '') || '';
                onRequestRevision(activity.id, lastDep.requiredStageId || activity.currentStageId, reason);
              }
            }} className="bg-orange-600 hover:bg-orange-700 px-3 py-1.5 rounded text-sm">Request revision</button>
          )}
          {canComplete && !nextStage && <button onClick={() => onComplete(activity.id)} className="bg-emerald-600 hover:bg-emerald-700 px-3 py-1.5 rounded text-sm">Complete Activity</button>}
          {!activity.completedAt && <button onClick={() => onWire(activity.id)} className="bg-purple-600 hover:bg-purple-700 px-3 py-1.5 rounded text-sm">Wire</button>}
          {!activity.completedAt && <button onClick={() => onEdit(activity.id)} className="bg-gray-800 hover:bg-gray-700 px-3 py-1.5 rounded text-sm">Edit</button>}
          {!activity.completedAt && <button onClick={() => onDelete(activity.id)} className="bg-red-700 hover:bg-red-800 px-3 py-1.5 rounded text-sm">Delete</button>}
        </div>
      );

      return (
        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex justify-end z-40" aria-modal="true" role="dialog">
          <div className="w-full max-w-md bg-gray-900 border-l border-gray-800 h-full overflow-y-auto">
            <div className="flex items-center justify-between px-6 py-4 border-b border-gray-800">
              <div>
                <h2 className="text-lg font-semibold text-gray-100">{activity.title}</h2>
                <div className="text-xs text-gray-400 mt-1">Stage status: {stageStateLabel}</div>
              </div>
              <button onClick={onClose} className="p-2 rounded hover:bg-gray-800"><XIcon className="w-4 h-4" /></button>
            </div>

            <div className="px-6 py-4 space-y-6">
              <div className="bg-gray-800/50 border border-gray-700 rounded-lg p-4 space-y-3">
                <div className="flex items-start justify-between">
                  <div className="space-y-2 text-sm text-gray-200">
                    {role && <div><span className="text-gray-400">Role:</span> {role.name}</div>}
                    {stage && <div><span className="text-gray-400">Stage:</span> {stage.name}</div>}
                    {stage?.conditions && <div className="text-xs text-blue-200 bg-blue-900/20 border border-blue-800/30 rounded px-2 py-1">Conditions: {stage.conditions}</div>}
                    {activity.skippedStages?.length > 0 && (
                      <div className="text-xs text-yellow-300">Skipped: {activity.skippedStages.map(id => stageMap?.[id]?.name || id).join(', ')}</div>
                    )}
                    {claimedBy && <div><span className="text-gray-400">Claimed by:</span> {claimedBy}{priority && <span className="text-xs bg-blue-900/60 text-blue-200 px-2 py-0.5 ml-2 rounded">{priority}</span>}</div>}
                    {nextStage ? (
                      <div className="text-xs text-gray-400">Next stage: {nextStage.name}</div>
                    ) : (
                      <div className="text-xs text-gray-500">Final stage</div>
                    )}
                    {activity.deliverable && <div><span className="text-gray-400">Deliverable:</span> {activity.deliverable}</div>}
                    <div className="text-xs text-gray-500">Created {formatTimestamp(activity.createdAt)}</div>
                  </div>
                </div>
                {stageStates.length > 0 && (
                  <div className="text-xs text-gray-200">
                    <div className="text-gray-400 mb-2">Stage overview</div>
                    <ul className="space-y-1">
                      {stageStates.map(({ stage: stageInfo, state, entry }) => (
                        <li key={getStageIdentity(stageInfo)} className="flex items-center justify-between bg-gray-900/40 px-2 py-1 rounded">
                          <span>{stageInfo.name}</span>
                          <span className="text-gray-400 text-[11px]">{state.replace('_', ' ')}{entry?.claimedBy ? ` · ${entry.claimedBy}` : ''}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                {dependencies.length > 0 && (
                  <div className="text-sm text-gray-200">
                    <div className="text-gray-400 mb-2">Waiting on</div>
                    <ul className="space-y-2 ml-2">
                      {dependencies.map((dep, idx) => {
                        const sourceName = dep.requiredStageName || 'Source stage';
                        const targetName = dep.blockingStageName || 'Target stage';
                        const activityTitle = dep.activity ? dep.activity.title : 'Missing activity';
                        const isCleared = dep.satisfied;
                        const statusLabel = isCleared ? 'Cleared' : 'Blocking';
                        const statusClass = isCleared ? 'text-emerald-300' : 'text-yellow-300';
                        return (
                          <li key={idx} className="flex items-start gap-2">
                            <ChevronRightIcon className="w-3 h-3 text-gray-500 mt-1" />
                            <div className="flex-1 space-y-1">
                              <div className="flex flex-wrap items-center gap-2 text-[11px] text-gray-300">
                                <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-gray-800/80">{sourceName}</span>
                                <span className="text-gray-600">→</span>
                                <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-gray-800/60 text-gray-200">{targetName}</span>
                                <span className={statusClass}>{statusLabel}</span>
                                {dep.edgeType === 'loops' && <span className="text-xs text-orange-400">(revision)</span>}
                                {(dep.needsMigration || dep.stageInferred) && <span className="text-xs text-yellow-400">Stage mapping inferred — confirm wiring</span>}
                              </div>
                              <div className={`${isCleared ? 'text-gray-500 line-through' : 'text-gray-200'} text-sm`}>
                                {activityTitle}
                                {dep.missingSource && <span className="ml-2 text-xs text-red-300">Source missing</span>}
                              </div>
                            </div>
                          </li>
                        );
                      })}
                    </ul>
                  </div>
                )}
                {actionButtons}
              </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-semibold text-gray-100">Attachments</h3>
                </div>
                <div className="space-y-2">
                  {(activity.attachments || []).length === 0 ? (
                    <div className="text-xs text-gray-500">No attachments yet.</div>
                  ) : (
                    (activity.attachments || []).map(att => (
                      <div key={att.id} className="flex items-center justify-between bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm text-gray-200">
                        <div className="flex flex-col">
                          <span>{att.name}</span>
                          {att.url && <a href={att.url} target="_blank" rel="noopener noreferrer" className="text-xs text-blue-400 hover:text-blue-300">{att.url}</a>}
                          <span className="text-xs text-gray-500">Added {att.addedBy || 'someone'} · {formatRelativeTime(att.addedAt)}</span>
                        </div>
                        <button onClick={() => onRemoveAttachment(att.id)} className="text-xs text-gray-400 hover:text-gray-200">Remove</button>
                      </div>
                    ))
                  )}
                  <div className="bg-gray-800 border border-gray-700 rounded-lg p-3 space-y-2">
                    <input type="text" value={attachmentName} onChange={(e) => setAttachmentName(e.target.value)} placeholder="File name" className="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 text-sm" />
                    <input type="text" value={attachmentUrl} onChange={(e) => setAttachmentUrl(e.target.value)} placeholder="Link (optional)" className="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 text-sm" />
                    <button onClick={handleAddAttachment} disabled={!currentUser || !attachmentName.trim()} className="w-full bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 text-sm py-2 rounded">Add attachment</button>
                  </div>
                </div>
              </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-semibold text-gray-100">Comments ({comments.length})</h3>
                </div>
                <div className="space-y-3">
                  {comments.length === 0 ? (
                    <div className="text-xs text-gray-500">No comments yet.</div>
                  ) : (
                    comments.map(comment => (
                      <div key={comment.id} className="bg-gray-800 border border-gray-700 rounded-lg p-3 text-sm text-gray-100">
                        <div className="flex items-center justify-between text-xs text-gray-400 mb-2">
                          <span>{comment.author}{comment.system && ' · system'}</span>
                          <span>{formatRelativeTime(comment.createdAt)}</span>
                        </div>
                        <div className="leading-relaxed">{renderCommentContent(comment.content)}</div>
                      </div>
                    ))
                  )}
                  <div className="bg-gray-800 border border-gray-700 rounded-lg p-3 space-y-2">
                    <textarea value={commentText} onChange={(e) => setCommentText(e.target.value)} placeholder={currentUser ? 'Add a comment with @mentions' : 'Set your name in the dashboard to comment'} className="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 text-sm" rows={3} disabled={!currentUser} />
                    <div className="flex justify-end">
                      <button onClick={handleAddComment} disabled={!currentUser || !commentText.trim()} className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 disabled:text-gray-400 px-3 py-1.5 rounded text-sm">Comment</button>
                    </div>
                  </div>
                </div>
              </div>

              <div>
                <h3 className="text-sm font-semibold text-gray-100 mb-3">History</h3>
                <div className="space-y-2 text-sm text-gray-200">
                  {stageHistory.length > 0 && (
                    <div className="space-y-1">
                      <div className="text-xs uppercase tracking-wide text-gray-500">Stage history</div>
                      {stageHistory.map(entry => (
                        <div key={entry.id} className="bg-gray-900/40 border border-gray-800 rounded p-2 text-xs text-gray-300">
                          <div className="flex items-center justify-between mb-1">
                            <span className="text-gray-100">{stageMap?.[entry.stageId]?.name || entry.stageId}</span>
                            <span className="text-gray-500">{entry.enteredAt ? formatRelativeTime(entry.enteredAt) : ''}</span>
                          </div>
                          {entry.claimedBy && <div>Claimed by {entry.claimedBy}{entry.priority && ` (${entry.priority})`}</div>}
                          {entry.completedAt && <div>Completed {formatRelativeTime(entry.completedAt)}</div>}
                          {entry.skippedAt && <div>Skipped {formatRelativeTime(entry.skippedAt)}</div>}
                          {(entry.log || []).length > 0 && (
                            <ul className="mt-1 space-y-0.5">
                              {entry.log.slice().reverse().map(logEntry => (
                                <li key={logEntry.id} className="text-gray-400">{logEntry.text}</li>
                              ))}
                            </ul>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                  {history.length === 0 ? (
                    <div className="text-xs text-gray-500">No history yet.</div>
                  ) : (
                    history.map(entry => (
                      <div key={entry.id} className="flex items-start gap-2">
                        <div className="text-xs text-gray-500 w-28 flex-shrink-0">{formatRelativeTime(entry.timestamp)}</div>
                        <div className="flex-1">{entry.text}</div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function formatTimestamp(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleString();
    }

    function formatRelativeTime(timestamp) {
      if (!timestamp) return '';
      const diff = Date.now() - timestamp;
      const minutes = Math.floor(diff / 60000);
      if (minutes < 1) return 'just now';
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    function extractMentions(content) {
      const regex = /@([\w-]+)/g;
      const mentions = new Set();
      let match;
      while ((match = regex.exec(content))) {
        mentions.add(match[1]);
      }
      return Array.from(mentions);
    }
    function RefreshIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>;
    }
    function EditIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>;
    }
    function TrashIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
    }
    function UsersIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" /></svg>;
    }
    function HomeIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>;
    }

    function computeActivityState(activity, stage, allActivities, edges) {
      if (!activity || !stage) return 'waiting';
      const stageId = getStageIdentity(stage);
      const stageEntry = getLatestStageHistoryEntry(activity.stageHistory, stageId);

      if (stageEntry?.skippedAt) return 'skipped';
      if (stageEntry?.completedAt) return 'completed';
      if (stageEntry?.claimedBy) return 'in_progress';

      const inbound = edges.filter(edge => edge.dstId === activity.id && (!edge.dstStage || edge.dstStage === stageId));
      const dependenciesSatisfied = inbound.length === 0 || inbound.every(edge => {
        const src = allActivities.find(a => a.id === edge.srcId);
        if (!src) return false;
        if (src.completedAt) return true;
        const requiredStageId = edge.srcStage || getActivityDefaultStageId(src);
        const status = getStageStatusFromHistory(src, requiredStageId);
        if (status.completed || status.skipped) return true;
        if (!edge.srcStage) {
          const lastStage = Array.isArray(src.stageHistory) ? src.stageHistory[src.stageHistory.length - 1] : null;
          return !!lastStage?.completedAt || !!lastStage?.skippedAt;
        }
        return false;
      });

      const currentStageId = activity.currentStageId || activity.stageId || null;
      if (!dependenciesSatisfied) return 'waiting';
      if (currentStageId === stageId) {
        if (!stageEntry) return 'ready';
        if (!stageEntry.claimedBy && !stageEntry.completedAt && !stageEntry.skippedAt) {
          return 'ready';
        }
      }

      return 'waiting';
    }

    function EventOperator() {
      const [view, setView] = useState('welcome');
      const [currentUser, setCurrentUser] = useState('');
      const [projects, setProjects] = useState([]);
      const [selectedProject, setSelectedProject] = useState(null);
      const [selectedFlow, setSelectedFlow] = useState(null);
      const [roles, setRoles] = useState([]);
      const [showModal, setShowModal] = useState(null);
      const [modalData, setModalData] = useState({});

      useEffect(() => {
        if (selectedProject && projects.length > 0) {
          const updated = projects.find(p => p.id === selectedProject.id);
          if (updated) setSelectedProject(updated);
        }
      }, [projects]);

      useEffect(() => {
        if (selectedFlow && selectedProject) {
          const updated = selectedProject.flows.find(f => f.id === selectedFlow.id);
          if (updated) setSelectedFlow(updated);
        }
      }, [selectedProject]);

      useEffect(() => {
        setProjects(prev => {
          let mutated = false;
          const nextProjects = prev.map(project => {
            let projectChanged = false;
            const nextFlows = project.flows.map(flow => {
              if (!Array.isArray(flow.edges) || flow.edges.length === 0) return flow;
              const orderedStages = getOrderedStages(flow);
              const fallbackStageId = orderedStages[0] ? getStageIdentity(orderedStages[0]) : null;
              let flowChanged = false;
              const nextEdges = flow.edges.map(edge => {
                if (edge.srcStage && edge.dstStage && edge.stageInferred !== undefined) return edge;
                const srcActivity = flow.activities.find(a => a.id === edge.srcId);
                const dstActivity = flow.activities.find(a => a.id === edge.dstId);
                const srcStage = edge.srcStage || getActivityDefaultStageId(srcActivity, orderedStages) || fallbackStageId;
                const dstStage = edge.dstStage || getActivityDefaultStageId(dstActivity, orderedStages) || fallbackStageId;
                if (edge.srcStage === srcStage && edge.dstStage === dstStage && edge.stageInferred !== undefined) {
                  return edge;
                }
                flowChanged = true;
                return {
                  ...edge,
                  srcStage,
                  dstStage,
                  stageInferred: edge.stageInferred !== false
                };
              });
              if (!flowChanged) return flow;
              projectChanged = true;
              return { ...flow, edges: nextEdges };
            });
            if (!projectChanged) return project;
            mutated = true;
            return { ...project, flows: nextFlows };
          });
          return mutated ? nextProjects : prev;
        });
      }, []);

      const createProject = (name, users, currentUserName) => {
        const project = { 
          id: `p-${Date.now()}`, 
          name, 
          users: users.map(u => ({ id: `u-${Date.now()}-${Math.random()}`, name: u })),
          flows: [] 
        };
        setProjects([...projects, project]);
        setCurrentUser(currentUserName);
        setView('dashboard');
      };

      const addUserToProject = (projectId, userName) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          users: [...p.users, { id: `u-${Date.now()}`, name: userName }]
        } : p));
      };

      const removeUserFromProject = (projectId, userId) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          users: p.users.filter(u => u.id !== userId)
        } : p));
      };

      const createFlow = (projectId, name, deliverables, description) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: [...p.flows, {
            id: `f-${Date.now()}`,
            name,
            deliverables,
            description,
            stages: createDefaultStages(),
            activities: [],
            edges: []
          }]
        } : p));
      };

      const createActivity = (projectId, flowId, title, roleId, deliverable = '', options = {}) => {
        const timestamp = Date.now();
        const activityId = options.id || `a-${timestamp}`;
        const explicitStageId = options.stageId || null;
        const role = roles.find(r => r.id === roleId);
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => {
            if (f.id !== flowId) return f;
            const orderedStages = getOrderedStages(f);
            const explicitStage = explicitStageId ? orderedStages.find(stage => getStageIdentity(stage) === explicitStageId) : null;
            const targetStage = explicitStage || findStageForRole(f, role) || orderedStages[0] || null;
            const stageId = targetStage ? getStageIdentity(targetStage) : explicitStageId;
            const entry = stageId ? createStageHistoryEntry(stageId, timestamp) : null;
            if (entry) {
              entry.log = [{ id: `log-${timestamp}`, text: `${actor} created this activity`, timestamp }];
            }
            return {
              ...f,
              activities: [...f.activities, {
                id: activityId,
                title,
                roleId,
                deliverable,
                currentStageId: stageId,
                skippedStages: [],
                stageHistory: entry ? [entry] : [],
                stageReadBy: stageId ? { [stageId]: {} } : {},
                createdAt: timestamp,
                completedAt: null,
                comments: [],
                attachments: [],
                history: [{ id: `h-${timestamp}`, text: `${actor} created this activity`, timestamp }]
              }]
            };
          })
        } : p));
      };

      const updateActivity = (projectId, flowId, activityId, updates) => {
        const timestamp = Date.now();
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const baseTracking = ensureStageTracking(a, a.currentStageId || a.stageId, timestamp);
              let currentStageId = baseTracking.currentStageId;
              let stageHistory = baseTracking.stageHistory;
              const stageReadBy = { ...baseTracking.stageReadBy };

              if (updates.roleId) {
                const nextRole = roles.find(r => r.id === updates.roleId);
                const stage = findStageForRole(f, nextRole) || (orderedStages[0] || null);
                if (stage) currentStageId = getStageIdentity(stage);
              }
              if (updates.stageId) currentStageId = updates.stageId;
              if (updates.currentStageId) currentStageId = updates.currentStageId;

              if (currentStageId && !getLatestStageHistoryEntry(stageHistory, currentStageId)) {
                stageHistory = [...stageHistory, createStageHistoryEntry(currentStageId, timestamp)];
              }
              if (currentStageId && !stageReadBy[currentStageId]) {
                stageReadBy[currentStageId] = {};
              }

              const merged = {
                ...a,
                ...updates,
                currentStageId,
                stageHistory,
                stageReadBy,
                stageId: currentStageId
              };
              if (!merged.skippedStages) merged.skippedStages = a.skippedStages || [];
              return merged;
            })
          } : f)
        } : p));
      };

      const deleteActivity = (projectId, flowId, activityId) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.filter(a => a.id !== activityId),
            edges: f.edges.filter(e => e.srcId !== activityId && e.dstId !== activityId)
          } : f)
        } : p));
      };

      const createEdge = (projectId, flowId, srcId, dstId, type, options = {}) => {
        const { srcStage: providedSrcStage, dstStage: providedDstStage } = options;
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            edges: [...f.edges, (() => {
              const timestamp = Date.now();
              const orderedStages = getOrderedStages(f);
              const srcActivity = f.activities.find(a => a.id === srcId);
              const dstActivity = f.activities.find(a => a.id === dstId);
              const fallbackStageId = orderedStages[0] ? getStageIdentity(orderedStages[0]) : null;
              const inferredSrcStage = providedSrcStage || getActivityDefaultStageId(srcActivity, orderedStages) || fallbackStageId;
              const inferredDstStage = providedDstStage || getActivityDefaultStageId(dstActivity, orderedStages) || fallbackStageId;
              const stageInferred = !providedSrcStage || !providedDstStage;
              return {
                id: `e-${timestamp}`,
                type,
                srcId,
                dstId,
                srcStage: inferredSrcStage,
                dstStage: inferredDstStage,
                stageInferred
              };
            })()]
          } : f)
        } : p));
      };

      const createRole = (name, operatorType, userIds = []) => {
        const role = {
          id: `r-${Date.now()}`,
          name,
          operatorType,
          userIds
        };
        setRoles([...roles, role]);
        return role;
      };

      const updateRole = (roleId, updates) => {
        setRoles(prev => prev.map(r => r.id === roleId ? { ...r, ...updates } : r));
      };

      const claimActivity = (projectId, flowId, activityId, priority) => {
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const stageIdSeed = a.currentStageId || a.stageId;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageIdSeed, timestamp);
              if (!currentStageId) return a;
              const stageMeta = orderedStages.find(stage => getStageIdentity(stage) === currentStageId);
              const latestEntry = getLatestStageHistoryEntry(stageHistory, currentStageId);
              if (latestEntry?.claimedBy && latestEntry.claimedBy !== currentUser) {
                return a;
              }
              const updatedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                ...entry,
                claimedBy: currentUser,
                claimedAt: timestamp,
                priority: priority || null,
                log: [...(entry.log || []), { id: `log-${timestamp}`, text: `${actor} claimed${priority ? ` (${priority})` : ''}`, timestamp }]
              }), { createIfMissing: true, timestamp });
              const updatedStageReadBy = {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [actor]: timestamp }
              };
              const stageName = stageMeta?.name || 'stage';
              const comments = [
                ...(a.comments || []),
                {
                  id: `c-${timestamp}`,
                  author: actor,
                  content: `${actor} claimed ${stageName}${priority ? ` (priority: ${priority})` : ''}`,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                }
              ];
              return {
                ...a,
                currentStageId,
                stageHistory: updatedHistory,
                stageReadBy: updatedStageReadBy,
                comments,
                history: [...(a.history || []), { id: `h-${timestamp}`, text: `${actor} claimed ${stageName}${priority ? ` (priority: ${priority})` : ''}`, timestamp }]
              };
            })
          } : f)
        } : p));
      };

      const unclaimActivity = (projectId, flowId, activityId) => {
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const stageIdSeed = a.currentStageId || a.stageId;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageIdSeed, timestamp);
              if (!currentStageId) return a;
              const stageMeta = orderedStages.find(stage => getStageIdentity(stage) === currentStageId);
              const updatedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                ...entry,
                claimedBy: null,
                priority: null,
                log: [...(entry.log || []), { id: `log-${timestamp}`, text: `${actor} unclaimed`, timestamp }]
              }), { createIfMissing: true, timestamp });
              const updatedStageReadBy = {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [actor]: timestamp }
              };
              const stageName = stageMeta?.name || 'stage';
              return {
                ...a,
                currentStageId,
                stageHistory: updatedHistory,
                stageReadBy: updatedStageReadBy,
                comments: [...(a.comments || []), {
                  id: `c-${timestamp}`,
                  author: actor,
                  content: `${actor} unclaimed ${stageName}`,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                }],
                history: [...(a.history || []), { id: `h-${timestamp}`, text: `${actor} unclaimed ${stageName}`, timestamp }]
              };
            })
          } : f)
        } : p));
      };

      const completeActivity = (projectId, flowId, activityId, options = {}) => {
        const { skipStage: skipStageFlag = false, note = null } = options || {};
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const stageIdSeed = a.currentStageId || a.stageId;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageIdSeed, timestamp);
              if (!currentStageId) return a;
              const stageMeta = orderedStages.find(stage => getStageIdentity(stage) === currentStageId);
              const stageName = stageMeta?.name || 'stage';
              const message = skipStageFlag ? `${actor} skipped ${stageName}` : `${actor} completed ${stageName}`;
              const trimmedNote = note ? note.trim() : '';
              const updatedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                ...entry,
                exitedAt: timestamp,
                completedAt: skipStageFlag ? entry.completedAt : timestamp,
                skippedAt: skipStageFlag ? timestamp : entry.skippedAt,
                log: [
                  ...(entry.log || []),
                  { id: `log-${timestamp}`, text: message, timestamp },
                  ...(trimmedNote ? [{ id: `log-${timestamp}-note`, text: `Note: ${trimmedNote}`, timestamp }] : [])
                ]
              }), { createIfMissing: true, timestamp });
              const newSkippedStages = skipStageFlag ? Array.from(new Set([...(a.skippedStages || []), currentStageId])) : (a.skippedStages || []);
              const nextStageId = getNextStageId(orderedStages, currentStageId, newSkippedStages);
              const nextStageMeta = nextStageId ? orderedStages.find(stage => getStageIdentity(stage) === nextStageId) : null;
              let extendedHistory = [...updatedHistory];
              if (nextStageId) {
                const nextEntry = createStageHistoryEntry(nextStageId, timestamp);
                nextEntry.log = [{ id: `log-${timestamp}-enter`, text: `${actor} moved to ${nextStageMeta?.name || 'next stage'}`, timestamp }];
                extendedHistory.push(nextEntry);
              }
              const updatedStageReadBy = {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [actor]: timestamp }
              };
              if (nextStageId && !updatedStageReadBy[nextStageId]) {
                updatedStageReadBy[nextStageId] = {};
              }
              const historyEntries = [
                ...(a.history || []),
                { id: `h-${timestamp}`, text: message, timestamp }
              ];
              if (nextStageMeta) {
                historyEntries.push({ id: `h-${timestamp}-advance`, text: `${actor} advanced to ${nextStageMeta.name}`, timestamp });
              } else {
                historyEntries.push({ id: `h-${timestamp}-finish`, text: `${actor} completed the activity`, timestamp });
              }
              if (trimmedNote) {
                historyEntries.push({ id: `h-${timestamp}-note`, text: `${actor} noted: ${trimmedNote}`, timestamp });
              }
              const comments = [
                ...(a.comments || []),
                {
                  id: `c-${timestamp}`,
                  author: actor,
                  content: message,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                },
                ...(trimmedNote ? [{
                  id: `c-${timestamp}-note`,
                  author: actor,
                  content: `Note on ${stageName}: ${trimmedNote}`,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                }] : [])
              ];
              return {
                ...a,
                currentStageId: nextStageId || currentStageId,
                skippedStages: newSkippedStages,
                stageHistory: extendedHistory,
                stageReadBy: updatedStageReadBy,
                comments,
                history: historyEntries,
                completedAt: nextStageId ? a.completedAt : timestamp
              };
            })
          } : f)
        } : p));
      };

      const addCommentToActivity = (projectId, flowId, activityId, author, content) => {
        const trimmed = content.trim();
        if (!trimmed) return;
        const timestamp = Date.now();
        const mentions = extractMentions(trimmed);
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, a.currentStageId || a.stageId, timestamp);
              const updatedStageReadBy = currentStageId ? {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [author]: timestamp }
              } : stageReadBy;
              return {
                ...a,
                currentStageId,
                stageHistory,
                stageReadBy: updatedStageReadBy,
                comments: [...(a.comments || []), { id: `c-${timestamp}`, author, content: trimmed, createdAt: timestamp, mentions, system: false }],
                history: [...(a.history || []), { id: `h-${timestamp}`, text: `${author} commented`, timestamp }]
              };
            })
          } : f)
        } : p));
      };

      const addAttachmentToActivity = (projectId, flowId, activityId, attachment) => {
        const timestamp = Date.now();
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => a.id === activityId ? {
              ...a,
              attachments: [...(a.attachments || []), { ...attachment, id: attachment.id || `att-${timestamp}`, addedAt: timestamp }],
              history: [...(a.history || []), { id: `h-${timestamp}`, text: `${attachment.addedBy} attached ${attachment.name}`, timestamp }]
            } : a)
          } : f)
        } : p));
      };

      const removeAttachmentFromActivity = (projectId, flowId, activityId, attachmentId) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => a.id === activityId ? {
              ...a,
              attachments: (a.attachments || []).filter(att => att.id !== attachmentId)
            } : a)
          } : f)
        } : p));
      };

      const markActivityRead = (projectId, flowId, activityId, userName) => {
        if (!userName) return;
        const timestamp = Date.now();
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, a.currentStageId || a.stageId, timestamp);
              if (!currentStageId) return a;
              return {
                ...a,
                currentStageId,
                stageHistory,
                stageReadBy: {
                  ...stageReadBy,
                  [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [userName]: timestamp }
                }
              };
            })
          } : f)
        } : p));
      };

      const spawnActivity = (projectId, flowId, sourceActivityId, title, roleId, deliverable = '') => {
        const timestamp = Date.now();
        const newActivityId = `a-${timestamp}`;
        const role = roles.find(r => r.id === roleId);
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: [...f.activities, (() => {
              const orderedStages = getOrderedStages(f);
              const initialStage = findStageForRole(f, role) || orderedStages[0] || null;
              const stageId = initialStage ? getStageIdentity(initialStage) : null;
              const entry = stageId ? createStageHistoryEntry(stageId, timestamp) : null;
              if (entry) {
                entry.log = [{ id: `log-${timestamp}`, text: `${actor} spawned this from ${sourceActivityId}`, timestamp }];
              }
              return {
                id: newActivityId,
                title,
                roleId,
                deliverable,
                currentStageId: stageId,
                skippedStages: [],
                stageHistory: entry ? [entry] : [],
                stageReadBy: stageId ? { [stageId]: {} } : {},
                createdAt: timestamp,
                completedAt: null,
                comments: [],
                attachments: [],
                history: [{ id: `h-${timestamp}`, text: `${actor} spawned this from another activity`, timestamp }]
              };
            })()],
            edges: [...f.edges, (() => {
              const orderedStages = getOrderedStages(f);
              const srcActivity = f.activities.find(a => a.id === sourceActivityId);
              const initialStage = findStageForRole(f, role) || orderedStages[0] || null;
              const stageId = initialStage ? getStageIdentity(initialStage) : null;
              const srcStageId = getActivityDefaultStageId(srcActivity, orderedStages);
              return {
                id: `e-${timestamp}`,
                type: 'enables',
                srcId: sourceActivityId,
                dstId: newActivityId,
                srcStage: srcStageId,
                dstStage: stageId,
                stageInferred: false
              };
            })()]
          } : f)
        } : p));
      };

      const requestRevision = (projectId, flowId, activityId, targetStageId, reason = '') => {
        if (!targetStageId) return;
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => {
            if (f.id !== flowId) return f;
            const orderedStages = getOrderedStages(f);
            const targetStage = orderedStages.find(stage => getStageIdentity(stage) === targetStageId) || null;
            const resolvedStageId = targetStage ? getStageIdentity(targetStage) : targetStageId;
            return {
              ...f,
              activities: f.activities.map(a => {
                if (a.id !== activityId) return a;
                const stageSeed = a.currentStageId || a.stageId || resolvedStageId;
                const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageSeed, timestamp);
                const activeStage = orderedStages.find(stage => getStageIdentity(stage) === currentStageId) || null;
                const activeStageName = activeStage?.name || currentStageId || 'current stage';
                const trimmedReason = reason ? reason.trim() : '';
                const exitedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                  ...entry,
                  exitedAt: timestamp,
                  log: [
                    ...(entry.log || []),
                    { id: `log-${timestamp}-revision`, text: `${actor} requested revision back to ${targetStage?.name || resolvedStageId}`, timestamp },
                    ...(trimmedReason ? [{ id: `log-${timestamp}-revision-reason`, text: `Reason: ${trimmedReason}`, timestamp }] : [])
                  ]
                }), { createIfMissing: true, timestamp });
                const revisionEntry = createStageHistoryEntry(resolvedStageId, timestamp);
                revisionEntry.log = [
                  { id: `log-${timestamp}-reopen`, text: `${actor} reopened stage${trimmedReason ? ` — ${trimmedReason}` : ''}`, timestamp }
                ];
                const filteredSkipped = (a.skippedStages || []).filter(id => id !== resolvedStageId);
                const updatedReadBy = {
                  ...stageReadBy,
                  [resolvedStageId]: { ...(stageReadBy[resolvedStageId] || {}), [actor]: timestamp }
                };
                const historyEntries = [
                  ...(a.history || []),
                  { id: `h-${timestamp}-revision`, text: `${actor} sent ${activeStageName} back to ${targetStage?.name || resolvedStageId}`, timestamp }
                ];
                if (trimmedReason) {
                  historyEntries.push({ id: `h-${timestamp}-revision-reason`, text: `Reason: ${trimmedReason}`, timestamp });
                }
                const comments = [
                  ...(a.comments || []),
                  {
                    id: `c-${timestamp}-revision`,
                    author: actor,
                    content: `${actor} requested revision to ${targetStage?.name || resolvedStageId}${trimmedReason ? ` — ${trimmedReason}` : ''}`,
                    createdAt: timestamp,
                    mentions: [],
                    system: true
                  }
                ];
                return {
                  ...a,
                  currentStageId: resolvedStageId,
                  stageHistory: [...exitedHistory, revisionEntry],
                  stageReadBy: updatedReadBy,
                  skippedStages: filteredSkipped,
                  isRevision: true,
                  comments,
                  history: historyEntries,
                  completedAt: null
                };
              })
            };
          })
        } : p));
      };

      const updateFlowStage = (projectId, flowId, stageId, updater) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => {
            if (f.id !== flowId) return f;
            const existingStages = Array.isArray(f.stages) && f.stages.length > 0 ? f.stages : createDefaultStages();
            const updatedStages = existingStages.map(stage => {
              const identity = getStageIdentity(stage);
              if (identity !== stageId && stage.key !== stageId) return stage;
              return { ...stage, ...updater(stage) };
            });
            return { ...f, stages: updatedStages };
          })
        } : p));
      };

      const configureStageConditions = (projectId, flowId, stageId, conditions) => {
        updateFlowStage(projectId, flowId, stageId, () => ({ conditions }));
      };

      const toggleStageSkip = (projectId, flowId, stageId) => {
        updateFlowStage(projectId, flowId, stageId, (stage) => ({ skipped: !stage.skipped }));
      };

      const advanceStage = (projectId, flowId, activityId, options = {}) => {
        completeActivity(projectId, flowId, activityId, options);
      };

      const skipStage = (projectId, flowId, activityId, note = null) => {
        completeActivity(projectId, flowId, activityId, { skipStage: true, note });
      };

      const advanceActivityStage = (projectId, flowId, activityId, { skip = false, note = null } = {}) => {
        advanceStage(projectId, flowId, activityId, { skipStage: skip, note });
      };

      const skipActivityStage = (projectId, flowId, activityId, note = null) => {
        skipStage(projectId, flowId, activityId, note);
      };

      let mainContent;

      if (view === 'welcome') {
        mainContent = <WelcomeView onCreate={createProject} />;
      } else if (view === 'dashboard') {
        mainContent = <DashboardView projects={projects} currentUser={currentUser} roles={roles} onSelectFlow={(p, f) => { setSelectedProject(p); setSelectedFlow(f); setView('activities'); }} onCreateProject={() => setShowModal('createProject')} onManageUsers={(p) => { setSelectedProject(p); setShowModal('manageUsers'); }} onCreateFlow={(p) => { setSelectedProject(p); setShowModal('createFlow'); }} />;
      } else if (view === 'activities' && selectedProject && selectedFlow) {
        mainContent = (
          <ActivitiesView
            project={selectedProject}
            flow={selectedFlow}
            roles={roles}
            currentUser={currentUser}
            onBack={() => { setSelectedFlow(null); setSelectedProject(null); setView('dashboard'); }}
            onCreateActivity={(operatorId) => {
              setModalData(operatorId ? { operatorId } : {});
              setShowModal('createActivity');
            }}
            onEditActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('editActivity'); }}
            onDeleteActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('deleteActivity'); }}
            onClaimActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('claimActivity'); }}
            onUnclaimActivity={(aid) => unclaimActivity(selectedProject.id, selectedFlow.id, aid)}
            onCompleteActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('completeActivity'); }}
            onWireActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('wireActivity'); }}
            onRequestRevision={(activityId, targetStageId, reason) => requestRevision(selectedProject.id, selectedFlow.id, activityId, targetStageId, reason)}
            onAddComment={addCommentToActivity}
            onAddAttachment={addAttachmentToActivity}
            onRemoveAttachment={removeAttachmentFromActivity}
            onMarkRead={markActivityRead}
            onAdvanceActivityStage={(aid, options) => advanceActivityStage(selectedProject.id, selectedFlow.id, aid, options)}
            onSkipActivityStage={(aid) => skipActivityStage(selectedProject.id, selectedFlow.id, aid)}
            onConfigureStageConditions={(stageId, conditions) => configureStageConditions(selectedProject.id, selectedFlow.id, stageId, conditions)}
            onToggleStageSkip={(stageId) => toggleStageSkip(selectedProject.id, selectedFlow.id, stageId)}
          />
        );
      }

      return (
        <>
          {mainContent}
          {showModal === 'createProject' && <CreateProjectModal onClose={() => setShowModal(null)} onCreate={(name, users) => { createProject(name, users, currentUser); setShowModal(null); }} />}
          {showModal === 'createFlow' && selectedProject && <CreateFlowModal onClose={() => setShowModal(null)} onCreate={(name, del, desc) => { createFlow(selectedProject.id, name, del, desc); setShowModal(null); }} />}
          {showModal === 'manageUsers' && selectedProject && <ManageUsersModal project={selectedProject} onClose={() => setShowModal(null)} onAddUser={(name) => addUserToProject(selectedProject.id, name)} onRemoveUser={(uid) => removeUserFromProject(selectedProject.id, uid)} />}
          {showModal === 'createActivity' && selectedProject && selectedFlow && <CreateActivityModal project={selectedProject} flow={selectedFlow} roles={roles} initialOperatorId={modalData.operatorId} onClose={() => { setShowModal(null); setModalData({}); }} onCreate={(title, roleId, deliverable) => { createActivity(selectedProject.id, selectedFlow.id, title, roleId, deliverable); setShowModal(null); setModalData({}); }} onCreateRole={createRole} onUpdateRole={updateRole} />}
          {showModal === 'editActivity' && selectedFlow && <EditActivityModal project={selectedProject} activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} roles={roles} onClose={() => { setShowModal(null); setModalData({}); }} onUpdate={(updates) => { updateActivity(modalData.projectId, modalData.flowId, modalData.activityId, updates); setShowModal(null); setModalData({}); }} onCreateRole={createRole} onUpdateRole={updateRole} />}
          {showModal === 'deleteActivity' && selectedFlow && <DeleteActivityModal activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} onClose={() => { setShowModal(null); setModalData({}); }} onDelete={() => { deleteActivity(modalData.projectId, modalData.flowId, modalData.activityId); setShowModal(null); setModalData({}); }} />}
          {showModal === 'claimActivity' && selectedFlow && <ClaimActivityModal activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} roles={roles} project={selectedProject} onClose={() => { setShowModal(null); setModalData({}); }} onClaim={(priority) => { claimActivity(modalData.projectId, modalData.flowId, modalData.activityId, priority); setShowModal(null); setModalData({}); }} />}
          {showModal === 'completeActivity' && selectedFlow && <CompleteActivityModal activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} flow={selectedFlow} onClose={() => { setShowModal(null); setModalData({}); }} onComplete={(options) => { completeActivity(modalData.projectId, modalData.flowId, modalData.activityId, options); setShowModal(null); setModalData({}); }} />}
          {showModal === 'wireActivity' && selectedFlow && <WireActivityModal project={selectedProject} activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} flow={selectedFlow} roles={roles} onClose={() => { setShowModal(null); setModalData({}); }} onWire={({ targetId, edgeType, srcStageId, dstStageId }) => { createEdge(modalData.projectId, modalData.flowId, modalData.activityId, targetId, edgeType, { srcStage: srcStageId, dstStage: dstStageId }); setShowModal(null); setModalData({}); }} onCreate={({ title, roleId, deliverable, edgeType, srcStageId, dstStageId, initialStageId }) => { const timestamp = Date.now(); const newId = `a-${timestamp}`; createActivity(modalData.projectId, modalData.flowId, title, roleId, deliverable, { id: newId, stageId: initialStageId }); setTimeout(() => createEdge(modalData.projectId, modalData.flowId, modalData.activityId, newId, edgeType, { srcStage: srcStageId, dstStage: dstStageId }), 50); setShowModal(null); setModalData({}); }} onCreateRole={createRole} onUpdateRole={updateRole} />}
        </>
      );
    }

    function WelcomeView({ onCreate }) {
      const [projectName, setProjectName] = useState('');
      const [team, setTeam] = useState('');
      const [userName, setUserName] = useState('');

      return (
        <div className="min-h-screen bg-gray-950 text-gray-100 flex items-center justify-center p-6">
          <div className="max-w-2xl w-full">
            <div className="text-center mb-12">
              <h1 className="text-4xl font-bold mb-4">EO</h1>
              <p className="text-gray-300 text-lg">Emergent Organizing</p>
            </div>
            <div className="bg-gray-900 rounded-lg border border-gray-800 p-8">
              <h2 className="text-xl font-semibold mb-6">Create Your First Project</h2>
              <div className="space-y-4 mb-6">
                <div>
                  <label className="block text-sm text-gray-200 mb-2">Project name</label>
                  <input type="text" value={projectName} onChange={(e) => setProjectName(e.target.value)} placeholder="e.g., Marketing, Product Development" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" />
                </div>
                <div>
                  <label className="block text-sm text-gray-200 mb-2">Team members (comma separated)</label>
                  <input type="text" value={team} onChange={(e) => setTeam(e.target.value)} placeholder="e.g., alex, pat, sam" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" />
                </div>
                <div>
                  <label className="block text-sm text-gray-200 mb-2">Your name</label>
                  <input type="text" value={userName} onChange={(e) => setUserName(e.target.value)} placeholder="Your name" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" />
                </div>
              </div>
              <button onClick={() => { if (projectName && userName) { const teamList = team ? team.split(',').map(s => s.trim()) : [userName]; onCreate(projectName, teamList, userName); } }} disabled={!projectName || !userName} className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 disabled:cursor-not-allowed text-white font-medium py-3 rounded-lg transition-colors">Create Project</button>
            </div>
            <div className="bg-gray-900/50 rounded-lg border border-gray-800 p-6 mt-6">
              <p className="text-sm text-gray-300 leading-relaxed">Activities advance stage by stage. Dependencies compute readiness at each step so everyone can see what’s blocking progress.</p>
            </div>
          </div>
        </div>
      );
    }

    function DashboardView({ projects, currentUser, roles, onSelectFlow, onCreateProject, onManageUsers, onCreateFlow }) {
      const allStats = useMemo(() => {
        let totalProjects = projects.length;
        let totalFlows = 0;
        let totalReady = 0;
        let totalWaiting = 0;
        let totalInProgress = 0;
        let totalCompleted = 0;

        projects.forEach(project => {
          totalFlows += project.flows.length;
          project.flows.forEach(flow => {
            const orderedStages = getOrderedStages(flow);
            flow.activities.forEach(activity => {
              const stageIdSeed = activity.currentStageId || activity.stageId || (orderedStages[0] ? getStageIdentity(orderedStages[0]) : null);
              const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
              const currentStage = currentStageId ? orderedStages.find(stage => getStageIdentity(stage) === currentStageId) : orderedStages[0] || null;
              const activityForState = { ...activity, currentStageId, stageHistory };
              const state = currentStage ? computeActivityState(activityForState, currentStage, flow.activities, flow.edges) : 'waiting';
              if (state === 'ready') totalReady++;
              else if (state === 'waiting') totalWaiting++;
              else if (state === 'in_progress') totalInProgress++;
              else if (state === 'completed' || state === 'skipped' || activity.completedAt) totalCompleted++;
            });
          });
        });

        return { totalProjects, totalFlows, totalReady, totalWaiting, totalInProgress, totalCompleted };
      }, [projects]);

      const myWork = useMemo(() => {
        const work = [];
        projects.forEach(project => {
          project.flows.forEach(flow => {
            const orderedStages = getOrderedStages(flow);
            flow.activities.forEach(activity => {
              const stageIdSeed = activity.currentStageId || activity.stageId || (orderedStages[0] ? getStageIdentity(orderedStages[0]) : null);
              const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
              const activeEntry = currentStageId ? getLatestStageHistoryEntry(stageHistory, currentStageId) : null;
              if (activeEntry?.claimedBy === currentUser && !activity.completedAt) {
                const currentStage = currentStageId ? orderedStages.find(stage => getStageIdentity(stage) === currentStageId) : orderedStages[0] || null;
                const activityForState = { ...activity, currentStageId, stageHistory };
                const activeStageState = currentStage ? computeActivityState(activityForState, currentStage, flow.activities, flow.edges) : 'waiting';
                work.push({ project, flow, activity: { ...activity, activeStageEntry: activeEntry, activeStageState, activeStage: currentStage } });
              }
            });
          });
        });
        return work;
      }, [projects, currentUser]);

      return (
        <div className="min-h-screen bg-gray-950 text-gray-100">
          <div className="border-b border-gray-800 bg-gray-900/50">
            <div className="max-w-7xl mx-auto px-6 py-4">
              <div className="flex items-center justify-between">
                <div>
                  <h1 className="text-2xl font-bold">EO</h1>
                  <p className="text-sm text-gray-400">Emergent Organizing</p>
                </div>
                <div className="flex items-center gap-4">
                  <div className="text-sm text-gray-300">You: {currentUser}</div>
                  <button onClick={onCreateProject} className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg font-medium transition-colors text-sm">
                    <PlusIcon className="w-4 h-4" />New Project
                  </button>
                </div>
              </div>
            </div>
          </div>

          <div className="max-w-7xl mx-auto px-6 py-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
              <div className="bg-gray-900 border border-gray-800 rounded-lg p-4">
                <div className="text-2xl font-bold text-blue-400">{allStats.totalProjects}</div>
                <div className="text-sm text-gray-400">Projects</div>
              </div>
              <div className="bg-gray-900 border border-gray-800 rounded-lg p-4">
                <div className="text-2xl font-bold text-purple-400">{allStats.totalFlows}</div>
                <div className="text-sm text-gray-400">Active Flows</div>
              </div>
              <div className="bg-gray-900 border border-gray-800 rounded-lg p-4">
                <div className="text-2xl font-bold text-green-400">{allStats.totalReady}</div>
                <div className="text-sm text-gray-400">Ready to Start</div>
              </div>
              <div className="bg-gray-900 border border-gray-800 rounded-lg p-4">
                <div className="text-2xl font-bold text-blue-400">{allStats.totalInProgress}</div>
                <div className="text-sm text-gray-400">In Progress</div>
              </div>
            </div>

            {myWork.length > 0 && (
              <div className="mb-8">
                <h2 className="text-xl font-semibold mb-4">My Active Work</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {myWork.map(({ project, flow, activity }) => (
                    <div key={activity.id} className="bg-gray-900 border border-blue-800 rounded-lg p-4 cursor-pointer hover:border-blue-700" onClick={() => onSelectFlow(project, flow)}>
                      <div className="text-xs text-gray-400 mb-2">{project.name} → {flow.name}</div>
                      <h4 className="font-medium mb-2">{activity.title}</h4>
                      <div className="flex items-center gap-2">
                        {(() => {
                          const state = activity.activeStageState || 'in_progress';
                          const label = state.replace('_', ' ');
                          const cls = state === 'ready'
                            ? 'bg-green-900 text-green-200'
                            : state === 'completed'
                              ? 'bg-gray-800 text-gray-400'
                              : state === 'waiting'
                                ? 'bg-yellow-900 text-yellow-200'
                                : 'bg-blue-900 text-blue-300';
                          return <span className={`text-xs px-2 py-1 rounded ${cls}`}>{label}</span>;
                        })()}
                        {activity.activeStageEntry?.priority && <span className="text-xs text-gray-400">Priority: {activity.activeStageEntry.priority}</span>}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            <h2 className="text-xl font-semibold mb-4">All Projects</h2>
            {projects.length === 0 ? (
              <div className="text-center py-20">
                <LayersIcon className="w-16 h-16 text-gray-600 mx-auto mb-4" />
                <p className="text-gray-400 mb-4">No projects yet</p>
                <button onClick={onCreateProject} className="bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg transition-colors">Create Your First Project</button>
              </div>
            ) : (
              <div className="space-y-6">
                {projects.map(project => (
                  <ProjectCard key={project.id} project={project} roles={roles} onSelectFlow={(f) => onSelectFlow(project, f)} onManageUsers={() => onManageUsers(project)} onCreateFlow={() => onCreateFlow(project)} />
                ))}
              </div>
            )}
          </div>
        </div>
      );
    }

    function ProjectCard({ project, roles, onSelectFlow, onManageUsers, onCreateFlow }) {
      return (
        <div className="bg-gray-900 border border-gray-800 rounded-lg overflow-hidden">
          <div className="p-6 border-b border-gray-800">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-lg font-semibold">{project.name}</h3>
              <div className="flex gap-2">
                <button onClick={onManageUsers} className="text-xs bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded transition-colors">
                  <UsersIcon className="w-3 h-3 inline mr-1" />Users
                </button>
                <button onClick={onCreateFlow} className="text-xs bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded transition-colors">
                  <PlusIcon className="w-3 h-3 inline mr-1" />Flow
                </button>
              </div>
            </div>
            <p className="text-sm text-gray-400">Team: {project.users.map(u => u.name).join(', ')} · {project.flows.length} flows</p>
          </div>
          
          {project.flows.length === 0 ? (
            <div className="p-6 text-center text-gray-400 text-sm">
              No flows yet. Create one to get started.
            </div>
          ) : (
            <div className="p-6 space-y-4">
              {project.flows.map(flow => (
                <FlowCard key={flow.id} flow={flow} roles={roles} onClick={() => onSelectFlow(flow)} />
              ))}
            </div>
          )}
        </div>
      );
    }

    function FlowCard({ flow, roles, onClick }) {
      const stats = useMemo(() => {
        let ready = 0, waiting = 0, inProgress = 0, completed = 0;
        const orderedStages = getOrderedStages(flow);
        flow.activities.forEach(activity => {
          const stageIdSeed = activity.currentStageId || activity.stageId || (orderedStages[0] ? getStageIdentity(orderedStages[0]) : null);
          const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
          const currentStage = currentStageId ? orderedStages.find(stage => getStageIdentity(stage) === currentStageId) : orderedStages[0] || null;
          const activityForState = { ...activity, currentStageId, stageHistory };
          const state = currentStage ? computeActivityState(activityForState, currentStage, flow.activities, flow.edges) : 'waiting';
          if (state === 'ready') ready++;
          else if (state === 'waiting') waiting++;
          else if (state === 'in_progress') inProgress++;
          else if (state === 'completed' || state === 'skipped' || activity.completedAt) completed++;
        });
        return { ready, waiting, inProgress, completed };
      }, [flow]);

      return (
        <div className="bg-gray-800/50 rounded-lg p-4 border border-gray-700 cursor-pointer hover:border-gray-600 transition-colors" onClick={onClick}>
          <div className="flex items-start justify-between mb-3">
            <div>
              <h4 className="font-medium text-sm mb-1">{flow.name}</h4>
              <p className="text-xs text-gray-400">{flow.deliverables.join(' · ')}</p>
            </div>
            <div className="text-xs text-gray-400">{flow.activities.length} activities</div>
          </div>
          <div className="grid grid-cols-4 gap-2">
            <div className="bg-gray-900 rounded p-2">
              <div className="text-xs text-gray-400 mb-1">Ready</div>
              <div className="text-lg font-semibold text-green-400">{stats.ready}</div>
            </div>
            <div className="bg-gray-900 rounded p-2">
              <div className="text-xs text-gray-400 mb-1">Waiting</div>
              <div className="text-lg font-semibold text-yellow-400">{stats.waiting}</div>
            </div>
            <div className="bg-gray-900 rounded p-2">
              <div className="text-xs text-gray-400 mb-1">In Progress</div>
              <div className="text-lg font-semibold text-blue-400">{stats.inProgress}</div>
            </div>
            <div className="bg-gray-900 rounded p-2">
              <div className="text-xs text-gray-400 mb-1">Done</div>
              <div className="text-lg font-semibold text-gray-500">{stats.completed}</div>
            </div>
          </div>
        </div>
      );
    }

    function ActivitiesView({ project, flow, roles, currentUser, onBack, onCreateActivity, onEditActivity, onDeleteActivity, onClaimActivity, onUnclaimActivity, onCompleteActivity, onWireActivity, onRequestRevision, onAddComment, onAddAttachment, onRemoveAttachment, onMarkRead, onAdvanceActivityStage, onSkipActivityStage, onConfigureStageConditions, onToggleStageSkip }) {
      const stageData = useMemo(() => {
        const ordered = getOrderedStages(flow);
        const map = {};
        ordered.forEach(stage => {
          const identity = stage.uid || getStageIdentity(stage);
          map[identity] = stage;
          if (stage.key) {
            map[stage.key] = stage;
          }
        });
        const fallback = ordered[0] || null;
        return { ordered, map, fallback };
      }, [flow]);

      const getNextActiveStage = (stage) => {
        if (!stage) return null;
        const identity = getStageIdentity(stage);
        const index = stageData.ordered.findIndex(item => getStageIdentity(item) === identity);
        if (index === -1) return null;
        return stageData.ordered.slice(index + 1).find(item => !item.skipped) || null;
      };

      const activitiesWithState = useMemo(() => {
        const fallbackId = stageData.fallback ? getStageIdentity(stageData.fallback) : null;
        return flow.activities.map(activity => {
          const stageIdSeed = activity.currentStageId || activity.stageId || fallbackId;
          const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
          const normalizedStageId = currentStageId || fallbackId;
          const activityForState = {
            ...activity,
            currentStageId: normalizedStageId,
            stageId: normalizedStageId,
            stageHistory
          };
          const stageStates = stageData.ordered.map(stage => {
            const stageId = getStageIdentity(stage);
            return {
              stage,
              stageId,
              state: computeActivityState(activityForState, stage, flow.activities, flow.edges),
              entry: getLatestStageHistoryEntry(stageHistory, stageId)
            };
          });
          const activeStage = normalizedStageId ? stageData.map[normalizedStageId] || null : stageData.fallback || null;
          const activeStageState = activeStage ? computeActivityState(activityForState, activeStage, flow.activities, flow.edges) : 'waiting';
          const activeStageEntry = activeStage ? getLatestStageHistoryEntry(stageHistory, getStageIdentity(activeStage)) : null;
          const claimedBy = activeStageEntry?.claimedBy || null;
          const priority = activeStageEntry?.priority || null;
          return {
            ...activity,
            currentStageId: normalizedStageId,
            stageId: normalizedStageId,
            stageHistory,
            stageStates,
            activeStage,
            activeStageState,
            activeStageEntry,
            claimedBy,
            priority,
            stageReadBy,
            state: activeStageState
          };
        });
      }, [flow.activities, flow.edges, stageData]);

      const [selectedActivityId, setSelectedActivityId] = useState(null);

      const groupedActivities = useMemo(() => {
        const grouped = {};
        stageData.ordered.forEach(stage => {
          const identity = getStageIdentity(stage);
          grouped[identity] = [];
        });
        const fallbackId = stageData.fallback ? getStageIdentity(stageData.fallback) : null;
        activitiesWithState.forEach(activity => {
          const identity = stageData.map[activity.currentStageId] ? getStageIdentity(stageData.map[activity.currentStageId]) : fallbackId;
          if (identity) {
            if (!grouped[identity]) grouped[identity] = [];
            grouped[identity].push(activity);
          }
        });
        return grouped;
      }, [activitiesWithState, stageData]);

      useEffect(() => {
        if (selectedActivityId && !activitiesWithState.some(a => a.id === selectedActivityId)) {
          setSelectedActivityId(null);
        }
      }, [activitiesWithState, selectedActivityId]);

      const selectedActivity = useMemo(() => {
        return selectedActivityId ? activitiesWithState.find(a => a.id === selectedActivityId) : null;
      }, [selectedActivityId, activitiesWithState]);

      const selectedRole = useMemo(() => {
        return selectedActivity ? roles.find(r => r.id === selectedActivity.roleId) : null;
      }, [selectedActivity, roles]);

      const selectedStage = useMemo(() => {
        if (!selectedActivity) return null;
        if (selectedActivity.activeStage) return selectedActivity.activeStage;
        return stageData.map[selectedActivity.currentStageId] || stageData.fallback || null;
      }, [selectedActivity, stageData]);

      const selectedNextStage = useMemo(() => {
        if (!selectedStage) return null;
        const identity = getStageIdentity(selectedStage);
        const nextStageId = getNextStageId(stageData.ordered, identity, selectedActivity?.skippedStages || []);
        return nextStageId ? stageData.map[nextStageId] || null : null;
      }, [selectedStage, stageData, selectedActivity]);

      const getDependencies = (activityId, stageId = null) => {
        const activity = flow.activities.find(a => a.id === activityId);
        const inferredStageId = stageId || getActivityDefaultStageId(activity, stageData.ordered);
        const inbound = flow.edges.filter(e => e.dstId === activityId);
        return inbound.map(edge => {
          const blockingStageId = edge.dstStage || inferredStageId;
          if (inferredStageId && blockingStageId && inferredStageId !== blockingStageId) {
            return null;
          }
          const src = flow.activities.find(a => a.id === edge.srcId);
          const requiredStageId = edge.srcStage || getActivityDefaultStageId(src, stageData.ordered);
          const status = getStageStatusFromHistory(src, requiredStageId);
          return {
            edge,
            activity: src,
            edgeType: edge.type,
            requiredStageId,
            blockingStageId,
            requiredStageName: requiredStageId ? (stageData.map[requiredStageId]?.name || requiredStageId) : 'Unassigned stage',
            blockingStageName: blockingStageId ? (stageData.map[blockingStageId]?.name || blockingStageId) : 'Unassigned stage',
            satisfied: status.completed || status.skipped || !!src?.completedAt,
            missingSource: !src,
            needsMigration: !edge.srcStage || !edge.dstStage,
            stageInferred: !!edge.stageInferred,
            status
          };
        }).filter(Boolean);
      };

      const selectedDependencies = useMemo(() => {
        return selectedActivity ? getDependencies(selectedActivity.id, selectedActivity.currentStageId) : [];
      }, [selectedActivity, flow.edges, flow.activities]);

      const openActivityDetails = (activityId) => {
        setSelectedActivityId(activityId);
        if (currentUser) {
          onMarkRead(project.id, flow.id, activityId, currentUser);
        }
      };

      const closeDetails = () => {
        setSelectedActivityId(null);
      };

      return (
        <div className="min-h-screen bg-gray-950 text-gray-100">
          <div className="border-b border-gray-800 bg-gray-900/50">
            <div className="max-w-7xl mx-auto px-6 py-4">
              <div className="flex items-center justify-between">
                <button onClick={onBack} className="flex items-center gap-2 text-gray-300 hover:text-gray-100 transition-colors">
                  <HomeIcon className="w-4 h-4" />
                  Dashboard
                </button>
                <div className="text-sm text-gray-400">
                  {project.name} → {flow.name}
                </div>
              </div>
            </div>
          </div>

          <div className="max-w-7xl mx-auto p-6">
            <div className="bg-gray-900 border border-gray-800 rounded-lg p-6 mb-8">
              <div className="flex items-start justify-between mb-4">
                <div>
                  <h1 className="text-2xl font-bold mb-2">{flow.name}</h1>
                  {flow.description && <p className="text-gray-300">{flow.description}</p>}
                </div>
                <button onClick={() => onCreateActivity()} className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg font-medium transition-colors">
                  <PlusIcon className="w-4 h-4" />New Activity
                </button>
              </div>
              <div>
                <div className="text-sm text-gray-300 mb-2">Flow Deliverables:</div>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                  {flow.deliverables.map((d, i) => (
                    <div key={i} className="bg-gray-800 rounded px-3 py-2 text-sm text-gray-200">{d}</div>
                  ))}
                </div>
              </div>
            </div>

            <div className="overflow-x-auto pb-4">
              <div className="grid grid-flow-col auto-cols-[minmax(260px,1fr)] gap-4 min-h-[320px]">
                {stageData.ordered.map((stage, index) => {
                  const identity = getStageIdentity(stage);
                  const stageActivities = groupedActivities[identity] || [];
                  const assignedRole = stage.roleId ? roles.find(r => r.id === stage.roleId) : null;
                  const stageConditions = (stage.conditions || '').trim();
                  return (
                    <div key={identity} className={`bg-gray-900 border ${stage.skipped ? 'border-yellow-700 border-dashed opacity-70' : 'border-gray-800'} rounded-lg p-4 min-w-[260px] flex flex-col`}>
                      <div className="mb-4">
                        <div className="flex items-start justify-between gap-2 mb-2">
                          <div className="space-y-1">
                            <div className="flex items-center gap-2">
                              <h3 className="font-semibold text-sm">{index + 1}. {stage.name}</h3>
                              <button
                                onClick={() => onCreateActivity(stage.operatorKey || stage.key || stage.uid || stage.name)}
                                className="p-1 rounded bg-gray-800/60 hover:bg-gray-700 transition-colors"
                                title="Add activity"
                              >
                                <PlusIcon className="w-3.5 h-3.5" />
                              </button>
                            </div>
                            <p className="text-xs text-gray-300 leading-relaxed">{stage.description}</p>
                          </div>
                          <span className="text-xs bg-gray-800 px-2 py-1 rounded self-start">{stageActivities.length}</span>
                        </div>
                        {assignedRole && (
                          <div className="text-xs text-gray-400">Role: {assignedRole.name}</div>
                        )}
                        {stageConditions && (
                          <div className="text-xs text-blue-200 bg-blue-900/30 border border-blue-800/40 rounded px-2 py-1 mt-2">
                            Conditions: {stageConditions}
                          </div>
                        )}
                        <div className="flex flex-wrap gap-2 mt-3">
                          <button
                            onClick={() => {
                              if (!onConfigureStageConditions) return;
                              const existing = stage.conditions || '';
                              const input = window.prompt(`Set entry conditions for ${stage.name}`, existing);
                              if (input !== null) {
                                onConfigureStageConditions(identity, input.trim());
                              }
                            }}
                            className="text-xs px-2 py-1 rounded bg-gray-800 hover:bg-gray-700 transition-colors"
                          >
                            Conditions
                          </button>
                          <button
                            onClick={() => onToggleStageSkip && onToggleStageSkip(identity)}
                            className={`text-xs px-2 py-1 rounded transition-colors ${stage.skipped ? 'bg-yellow-800/60 hover:bg-yellow-700/70 text-yellow-200' : 'bg-gray-800 hover:bg-gray-700'}`}
                          >
                            {stage.skipped ? 'Resume Stage' : 'Skip Stage'}
                          </button>
                        </div>
                      </div>
                      <div className="space-y-2 flex-1">
                        {stageActivities.length === 0 ? (
                          <p className="text-sm text-gray-500 text-center py-6">No activities</p>
                        ) : (
                          stageActivities.map(activity => {
                            const role = roles.find(r => r.id === activity.roleId);
                            const deps = getDependencies(activity.id, activity.currentStageId || activity.stageId);
                            const activityStage = stageData.map[activity.stageId] || stageData.map[identity] || stageData.fallback;
                            const nextStage = getNextActiveStage(activityStage);
                            return (
                              <ActivityCard
                                key={activity.id}
                                activity={activity}
                                role={role}
                                stage={activityStage}
                                nextStage={nextStage}
                                dependencies={deps}
                                project={project}
                                currentUser={currentUser}
                                stageMap={stageData.map}
                                isSelected={selectedActivityId === activity.id}
                                onOpenDetails={openActivityDetails}
                                onEdit={onEditActivity}
                                onDelete={onDeleteActivity}
                                onClaim={onClaimActivity}
                                onUnclaim={onUnclaimActivity}
                                onAdvanceStage={onAdvanceActivityStage}
                                onSkipStage={onSkipActivityStage}
                                onComplete={onCompleteActivity}
                                onWire={onWireActivity}
                                onRequestRevision={onRequestRevision}
                              />
                            );
                          })
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
            {selectedActivity && (
              <ActivityDetailPanel
                activity={selectedActivity}
                role={selectedRole}
                stage={selectedStage}
                nextStage={selectedNextStage}
                stageMap={stageData.map}
                dependencies={selectedDependencies}
                project={project}
                currentUser={currentUser}
                onClose={closeDetails}
                onEdit={onEditActivity}
                onDelete={onDeleteActivity}
                onClaim={onClaimActivity}
                onUnclaim={onUnclaimActivity}
                onAdvanceStage={onAdvanceActivityStage}
                onSkipStage={onSkipActivityStage}
                onComplete={onCompleteActivity}
                onWire={onWireActivity}
                onRequestRevision={onRequestRevision}
                onAddComment={(text) => currentUser && onAddComment(project.id, flow.id, selectedActivity.id, currentUser, text)}
                onAddAttachment={(attachment) => onAddAttachment(project.id, flow.id, selectedActivity.id, attachment)}
                onRemoveAttachment={(attachmentId) => onRemoveAttachment(project.id, flow.id, selectedActivity.id, attachmentId)}
              />
            )}
          </div>
        </div>
      );
    }

    function ActivityCard({ activity, role, stage, nextStage, dependencies, project, currentUser, stageMap, isSelected, onOpenDetails, onEdit, onDelete, onClaim, onUnclaim, onAdvanceStage, onSkipStage, onComplete, onWire, onRequestRevision }) {
      const activeStage = stage;
      const stageState = activity.activeStageState || activity.state || 'waiting';
      const activeEntry = activity.activeStageEntry || null;
      const claimedBy = activeEntry?.claimedBy || null;
      const priority = activeEntry?.priority || null;
      const isMine = claimedBy && claimedBy === currentUser;
      const canClaim = stageState === 'ready' && !claimedBy && role?.userIds.some(uid => project.users.find(u => u.id === uid)?.name === currentUser);
      const canCompleteStage = isMine && stageState === 'in_progress';
      const isActivityCompleted = !!activity.completedAt;
      const canAdvanceStage = !isActivityCompleted && !!nextStage && stageState !== 'completed' && stageState !== 'skipped';
      const canSkipStage = !isActivityCompleted && !!nextStage;
      const stageSupportsRevision = activeStage?.supportsRevision;
      const showRevisionButton = stageSupportsRevision && dependencies.length > 0 && !isActivityCompleted;
      const showCompleteActivity = !nextStage && canCompleteStage;

      const stateConfig = {
        ready: { label: 'Ready', color: 'bg-green-900 text-green-300' },
        waiting: { label: 'Waiting', color: 'bg-yellow-900 text-yellow-300' },
        in_progress: { label: isMine ? 'You' : (claimedBy || 'In progress'), color: isMine ? 'bg-blue-900 text-blue-300' : 'bg-gray-700 text-gray-300' },
        completed: { label: '✓ Completed', color: 'bg-gray-700 text-gray-400' },
        skipped: { label: 'Skipped', color: 'bg-yellow-800 text-yellow-200' }
      };

      const config = stateConfig[stageState] || stateConfig.ready;
      const commentCount = activity.comments?.length || 0;
      const attachmentCount = activity.attachments?.length || 0;
      const stageReaders = activity.stageReadBy?.[activity.currentStageId] || {};
      const lastRead = stageReaders[currentUser] || 0;
      const hasUnread = (activity.comments || []).some(comment => !comment.system && comment.createdAt > lastRead && comment.author !== currentUser);
      const stageName = activeStage?.name || 'Unassigned stage';
      const stageBadgeClass = stageState === 'completed' ? 'bg-emerald-900/60 text-emerald-200' : activeStage?.skipped ? 'bg-yellow-900/60 text-yellow-200' : 'bg-gray-700 text-gray-200';
      const stageHistoryLog = (activeEntry?.log || []).slice(-2).reverse();
      const stageStates = activity.stageStates || [];

      return (
        <div
          className={`bg-gray-800 border ${isSelected ? 'border-blue-500' : 'border-gray-700'} rounded-lg p-3 hover:border-blue-400 transition-colors cursor-pointer`}
          onClick={(e) => {
            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('input') || e.target.closest('textarea')) return;
            onOpenDetails(activity.id);
          }}
        >
          <div className="flex items-start justify-between mb-2">
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <span className={`text-[10px] uppercase tracking-wide px-2 py-0.5 rounded ${stageBadgeClass}`}>{stageName}</span>
                {priority && <span className="text-[10px] bg-blue-900/50 text-blue-200 px-2 py-0.5 rounded">{priority}</span>}
                {activity.skippedStages?.length > 0 && (
                  <span className="text-[10px] text-yellow-300">{activity.skippedStages.length} skipped</span>
                )}
              </div>
              <h4 className="font-medium text-sm">{activity.title}</h4>
              {claimedBy && <div className="text-[11px] text-gray-400">Claimed by {claimedBy}</div>}
            </div>
            <div className="flex items-center gap-1 ml-2">
              <span className={`text-xs px-2 py-0.5 rounded ${config.color}`}>{config.label}</span>
              {hasUnread && <span className="w-2 h-2 rounded-full bg-blue-400" title="Unread comments" />}
            </div>
          </div>
          {activity.isRevision && <div className="text-xs text-orange-400 mb-2">🔄 Revision requested</div>}
          {role && <div className="text-xs text-gray-300 mb-2">{role.name} • {role.userIds.map(uid => project.users.find(u => u.id === uid)?.name).filter(Boolean).join(', ')}</div>}
          {activity.deliverable && <div className="text-xs text-gray-200 mb-2"><span className="text-gray-400">Delivers:</span> {activity.deliverable}</div>}
          {stageStates.length > 0 && (
            <div className="flex flex-wrap gap-1 text-[10px] text-gray-400 mb-2">
              {stageStates.map(({ stage: stageInfo, state }) => {
                const status = state === 'in_progress' ? 'doing' : state.replace('_', ' ');
                return (
                  <span key={getStageIdentity(stageInfo)} className={`px-2 py-0.5 rounded ${state === 'completed' ? 'bg-emerald-900/40 text-emerald-200' : state === 'in_progress' ? 'bg-blue-900/40 text-blue-200' : state === 'ready' ? 'bg-green-900/40 text-green-200' : state === 'skipped' ? 'bg-yellow-900/30 text-yellow-200' : 'bg-gray-800 text-gray-300'}`}>
                    {stageInfo.name}: {status}
                  </span>
                );
              })}
            </div>
          )}
          {stageHistoryLog.length > 0 && (
            <div className="text-[11px] text-gray-400 mb-2">
              <div className="uppercase tracking-wide text-gray-500 mb-1">Recent stage activity</div>
              <ul className="space-y-0.5">
                {stageHistoryLog.map(entry => (
                  <li key={entry.id}>{entry.text}</li>
                ))}
              </ul>
            </div>
          )}
          {dependencies.length > 0 && (
            <div className="text-xs text-gray-300 mb-2">
              <div className="text-gray-400 mb-1">Waiting on:</div>
              <ul className="space-y-0.5 ml-2">
                {dependencies.slice(0, 2).map((dep, i) => {
                  const isCleared = dep.satisfied;
                  return (
                    <li key={i} className={`flex items-center gap-2 ${isCleared ? 'text-gray-500' : 'text-gray-200'}`}>
                      <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-gray-800/80 text-[10px] text-gray-300">
                        {dep.requiredStageName || 'Stage'}
                      </span>
                      <span className="text-[10px] text-gray-500">→</span>
                      <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-gray-800/60 text-[10px] text-gray-200">
                        {dep.blockingStageName || 'Stage'}
                      </span>
                      <span className={`text-[10px] ${dep.satisfied ? 'text-emerald-300' : 'text-yellow-300'}`}>{dep.satisfied ? 'cleared' : 'blocking'}</span>
                      <span className="flex-1">
                        {dep.activity ? dep.activity.title : 'Missing activity'} {dep.edgeType === 'loops' && '(revision)'}
                      </span>
                    </li>
                  );
                })}
                {dependencies.length > 2 && <li className="text-gray-400">+{dependencies.length - 2} more</li>}
              </ul>
            </div>
          )}
          <div className="flex items-center gap-3 text-xs text-gray-400 mt-3">
            {attachmentCount > 0 && (
              <div className="flex items-center gap-1"><span role="img" aria-label="attachments">📎</span>{attachmentCount}</div>
            )}
            {commentCount > 0 && (
              <div className="flex items-center gap-1"><ChatBubbleIcon className="w-3.5 h-3.5" />{commentCount}</div>
            )}
            {activity.createdAt && <div className="ml-auto text-gray-500">{formatRelativeTime(activity.createdAt)}</div>}
          </div>
          <div className="flex gap-1 mt-3 flex-wrap">
            {!activity.completedAt && (
              <>
                <button onClick={(e) => { e.stopPropagation(); onEdit(activity.id); }} className="bg-gray-700 hover:bg-gray-600 text-xs py-1 px-2 rounded transition-colors" title="Edit"><EditIcon className="w-3 h-3" /></button>
                <button onClick={(e) => { e.stopPropagation(); onDelete(activity.id); }} className="bg-red-900 hover:bg-red-800 text-xs py-1 px-2 rounded transition-colors" title="Delete"><TrashIcon className="w-3 h-3" /></button>
              </>
            )}
            {canClaim && <button onClick={(e) => { e.stopPropagation(); onClaim(activity.id); }} className="flex-1 bg-blue-600 hover:bg-blue-700 text-xs py-1 px-2 rounded transition-colors">Claim</button>}
            {isMine && !activity.completedAt && <button onClick={(e) => { e.stopPropagation(); onUnclaim(activity.id); }} className="bg-gray-700 hover:bg-gray-600 text-xs py-1 px-2 rounded transition-colors">Unclaim</button>}
            {canAdvanceStage && (
              <button onClick={(e) => { e.stopPropagation(); onAdvanceStage(activity.id, { skip: false }); }} className="bg-green-600 hover:bg-green-700 text-xs py-1 px-2 rounded transition-colors">Advance</button>
            )}
            {canSkipStage && (
              <button onClick={(e) => { e.stopPropagation(); onSkipStage(activity.id); }} className="bg-yellow-700 hover:bg-yellow-600 text-xs py-1 px-2 rounded transition-colors text-yellow-100">Skip</button>
            )}
          {showRevisionButton && (
            <button onClick={(e) => { e.stopPropagation(); const lastDep = dependencies[dependencies.length - 1]; if (lastDep) { const reason = window.prompt('Reason for revision? (optional)', '') || ''; onRequestRevision(activity.id, lastDep.requiredStageId || activity.currentStageId, reason); } }} className="bg-orange-600 hover:bg-orange-700 text-xs py-1 px-2 rounded transition-colors flex items-center justify-center gap-1" title="Request revision"><RefreshIcon className="w-3 h-3" /></button>
          )}
            {showCompleteActivity && (
              <button onClick={(e) => { e.stopPropagation(); onComplete(activity.id); }} className="flex-1 bg-emerald-600 hover:bg-emerald-700 text-xs py-1 px-2 rounded transition-colors">Complete Activity</button>
            )}
            {!activity.completedAt && <button onClick={(e) => { e.stopPropagation(); onWire(activity.id); }} className="bg-purple-600 hover:bg-purple-700 text-xs py-1 px-2 rounded transition-colors">Wire</button>}
          </div>
        </div>
      );
    }

    function ManageUsersModal({ project, onClose, onAddUser, onRemoveUser }) {
      const [newUserName, setNewUserName] = useState('');

      return (
        <Modal onClose={onClose} title="Manage Team Members">
          <div className="space-y-4">
            <div className="bg-blue-900/30 border border-blue-700/50 rounded p-4">
              <p className="text-sm text-gray-100">Add or remove team members. Users can be assigned to roles.</p>
            </div>
            <div>
              <label className="block text-sm text-gray-200 mb-2">Current Team</label>
              <div className="space-y-2">
                {project.users.map(user => (
                  <div key={user.id} className="flex items-center justify-between bg-gray-800 rounded px-4 py-2">
                    <span className="text-gray-100">{user.name}</span>
                    <button onClick={() => onRemoveUser(user.id)} className="text-red-400 hover:text-red-300 text-sm">Remove</button>
                  </div>
                ))}
              </div>
            </div>
            <div>
              <label className="block text-sm text-gray-200 mb-2">Add New User</label>
              <div className="flex gap-2">
                <input type="text" value={newUserName} onChange={(e) => setNewUserName(e.target.value)} placeholder="User name" className="flex-1 bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" />
                <button onClick={() => { if (newUserName.trim()) { onAddUser(newUserName.trim()); setNewUserName(''); } }} disabled={!newUserName.trim()} className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 px-4 py-2 rounded transition-colors">Add</button>
              </div>
            </div>
            <div className="flex gap-3 pt-4">
              <button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Done</button>
            </div>
          </div>
        </Modal>
      );
    }

    function CreateProjectModal({ onClose, onCreate }) {
      const [name, setName] = useState('');
      const [team, setTeam] = useState('');
      return (
        <Modal onClose={onClose} title="Create Project">
          <div className="space-y-4">
            <div><label className="block text-sm text-gray-200 mb-2">Project name</label><input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="e.g., Marketing" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" autoFocus /></div>
            <div><label className="block text-sm text-gray-200 mb-2">Team members (comma separated)</label><input type="text" value={team} onChange={(e) => setTeam(e.target.value)} placeholder="e.g., alex, pat, sam" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (name) { const teamList = team ? team.split(',').map(s => s.trim()) : []; onCreate(name, teamList); } }} disabled={!name} className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 py-2 rounded transition-colors">Create</button></div>
          </div>
        </Modal>
      );
    }

    function CreateFlowModal({ onClose, onCreate }) {
      const [name, setName] = useState('');
      const [description, setDescription] = useState('');
      const [deliverables, setDeliverables] = useState(['', '', '']);
      return (
        <Modal onClose={onClose} title="Create Flow" size="large">
          <div className="space-y-4">
            <div className="bg-blue-900/30 border border-blue-700/50 rounded p-4"><p className="text-sm text-gray-100">Flows represent coordination cycles. Define up to three deliverables.</p></div>
            <div><label className="block text-sm text-gray-200 mb-2">Flow name</label><input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="e.g., Newsletter Creation" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" autoFocus /></div>
            <div><label className="block text-sm text-gray-200 mb-2">Description (optional)</label><textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Brief description" rows={2} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-sm text-gray-100 placeholder-gray-400" /></div>
            <div><label className="block text-sm text-gray-200 mb-2">Flow Deliverables (1-3)</label><div className="space-y-2">{deliverables.map((d, i) => <input key={i} type="text" value={d} onChange={(e) => { const u = [...deliverables]; u[i] = e.target.value; setDeliverables(u); }} placeholder={i === 0 ? 'e.g., Published article' : i === 1 ? 'e.g., Social media package' : 'e.g., Analytics report'} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-sm text-gray-100 placeholder-gray-400" />)}</div></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={() => { const valid = deliverables.filter(d => d.trim()); if (name && valid.length > 0) onCreate(name, valid, description); }} disabled={!name || !deliverables.some(d => d.trim())} className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 py-2 rounded transition-colors">Create</button></div>
          </div>
        </Modal>
      );
    }

    function CreateActivityModal({ project, flow, roles, onClose, onCreate, onCreateRole, onUpdateRole, initialOperatorId }) {
      const [step, setStep] = useState('role');
      const [title, setTitle] = useState('');
      const [selectedRole, setSelectedRole] = useState('');
      const [newRoleName, setNewRoleName] = useState('');
      const [selectedOperator, setSelectedOperator] = useState(initialOperatorId || '');
      const [selectedUserIds, setSelectedUserIds] = useState([]);
      const [deliverable, setDeliverable] = useState('');

      useEffect(() => {
        setSelectedOperator(initialOperatorId || '');
        setSelectedRole('');
        setStep('role');
        setTitle('');
        setDeliverable('');
        setNewRoleName('');
        setSelectedUserIds([]);
      }, [initialOperatorId, project.id, flow.id]);

      const availableRoles = initialOperatorId ? roles.filter(r => r.operatorType === initialOperatorId) : roles;
      const operatorChoices = initialOperatorId ? OPERATORS.filter(op => op.id === initialOperatorId) : OPERATORS;

      const handleCreateRole = () => {
        if (newRoleName && selectedOperator) {
          const role = onCreateRole(newRoleName, selectedOperator, selectedUserIds);
          setSelectedRole(role.id);
          setStep('activity');
        }
      };

      const toggleUser = (userId) => {
        setSelectedUserIds(prev => prev.includes(userId) ? prev.filter(id => id !== userId) : [...prev, userId]);
      };

      return (
        <Modal onClose={onClose} title="Create Activity" size="large">
          <div className="space-y-4">
            {step === 'role' ? (
              <>
                <div className="bg-blue-900/30 border border-blue-700/50 rounded p-4 mb-4"><p className="text-sm text-gray-100">Each activity needs a role (who does it) and operator type (what kind of work).</p></div>
                {availableRoles.length > 0 && (
                  <>
                    <div><label className="block text-sm text-gray-200 mb-2">Select existing role</label><select value={selectedRole} onChange={(e) => setSelectedRole(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100"><option value="">Choose...</option>{availableRoles.map(r => { const op = OPERATORS.find(o => o.id === r.operatorType); return <option key={r.id} value={r.id}>{r.name} ({op?.name})</option>; })}</select></div>
                    {selectedRole && <button onClick={() => setStep('activity')} className="w-full bg-blue-600 hover:bg-blue-700 py-2 rounded transition-colors">Continue</button>}
                    <div className="relative"><div className="absolute inset-0 flex items-center"><div className="w-full border-t border-gray-700"></div></div><div className="relative flex justify-center text-sm"><span className="px-2 bg-gray-900 text-gray-300">or create new role</span></div></div>
                  </>
                )}
                <div><label className="block text-sm text-gray-200 mb-2">New role name</label><input type="text" value={newRoleName} onChange={(e) => setNewRoleName(e.target.value)} placeholder="e.g., Content Writer" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
                <div><label className="block text-sm text-gray-200 mb-2">Select operator type</label><div className="grid grid-cols-3 gap-2">{operatorChoices.map(op => <button key={op.id} onClick={() => setSelectedOperator(op.id)} className={`p-3 border rounded text-left transition-colors ${selectedOperator === op.id ? 'border-blue-500 bg-blue-500/20' : 'border-gray-700 hover:border-gray-600'}`}><div className="font-medium text-sm">{op.seq}. {op.name}</div><div className="text-xs text-gray-300 mt-1">{op.desc}</div></button>)}</div></div>
                <div><label className="block text-sm text-gray-200 mb-2">Assign users to this role</label><div className="space-y-2">{project.users.map(user => <label key={user.id} className="flex items-center gap-3 p-3 bg-gray-800 border border-gray-700 rounded cursor-pointer hover:border-gray-600"><input type="checkbox" checked={selectedUserIds.includes(user.id)} onChange={() => toggleUser(user.id)} /><span className="text-sm text-gray-100">{user.name}</span></label>)}</div></div>
                <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={handleCreateRole} disabled={!newRoleName || !selectedOperator} className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-700 py-2 rounded transition-colors">Create Role & Continue</button></div>
              </>
            ) : (
              <>
                <div className="bg-gray-800 rounded p-3 mb-4"><div className="text-sm text-gray-300">Role: {roles.find(r => r.id === selectedRole)?.name}</div><button onClick={() => setStep('role')} className="text-xs text-blue-400 hover:text-blue-300 mt-1">Change</button></div>
                <div><label className="block text-sm text-gray-200 mb-2">Activity name</label><input type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Write article" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" autoFocus /></div>
                <div><label className="block text-sm text-gray-200 mb-2">Deliverable (optional)</label><input type="text" value={deliverable} onChange={(e) => setDeliverable(e.target.value)} placeholder="e.g., 800-word article" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
                <div className="flex gap-3 pt-4"><button onClick={() => setStep('role')} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Back</button><button onClick={() => { if (title && selectedRole) onCreate(title, selectedRole, deliverable); }} disabled={!title} className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 py-2 rounded transition-colors">Create</button></div>
              </>
            )}
          </div>
        </Modal>
      );
    }

    function EditActivityModal({ project, activity, roles, onClose, onUpdate, onCreateRole, onUpdateRole }) {
      const [title, setTitle] = useState(activity?.title || '');
      const [deliverable, setDeliverable] = useState(activity?.deliverable || '');
      const [selectedRole, setSelectedRole] = useState(activity?.roleId || '');

      useEffect(() => {
        if (activity) {
          setTitle(activity.title);
          setDeliverable(activity.deliverable || '');
          setSelectedRole(activity.roleId);
        }
      }, [activity]);

      return (
        <Modal onClose={onClose} title="Edit Activity">
          <div className="space-y-4">
            <div><label className="block text-sm text-gray-200 mb-2">Activity name</label><input type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Write article" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" autoFocus /></div>
            <div><label className="block text-sm text-gray-200 mb-2">Role</label><select value={selectedRole} onChange={(e) => setSelectedRole(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100"><option value="">Choose...</option>{roles.map(r => { const op = OPERATORS.find(o => o.id === r.operatorType); return <option key={r.id} value={r.id}>{r.name} ({op?.name})</option>; })}</select></div>
            <div><label className="block text-sm text-gray-200 mb-2">Deliverable (optional)</label><input type="text" value={deliverable} onChange={(e) => setDeliverable(e.target.value)} placeholder="e.g., 800-word article" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (title && selectedRole) onUpdate({ title, roleId: selectedRole, deliverable }); }} disabled={!title || !selectedRole} className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 py-2 rounded transition-colors">Save</button></div>
          </div>
        </Modal>
      );
    }

    function DeleteActivityModal({ activity, onClose, onDelete }) {
      return (
        <Modal onClose={onClose} title="Delete Activity">
          <div className="space-y-4">
            <div className="bg-red-900/30 border border-red-700/50 rounded p-4">
              <p className="text-sm text-gray-100">Are you sure you want to delete this activity? This will also remove all edges connected to it. This action cannot be undone.</p>
            </div>
            <div className="bg-gray-900 rounded-lg p-4">
              <h3 className="font-medium text-gray-100">{activity?.title}</h3>
            </div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={onDelete} className="flex-1 bg-red-600 hover:bg-red-700 py-2 rounded transition-colors">Delete</button></div>
          </div>
        </Modal>
      );
    }

    function ClaimActivityModal({ activity, roles, project, onClose, onClaim }) {
      const [priority, setPriority] = useState('medium');
      return (
        <Modal onClose={onClose} title="Claim Activity">
          <div className="space-y-4">
            <div className="bg-gray-900 rounded-lg p-4"><h3 className="font-medium mb-2 text-gray-100">{activity?.title}</h3></div>
            <div><label className="block text-sm text-gray-200 mb-3">Priority</label><div className="space-y-2">{[{ value: 'high', label: 'High - Focus' }, { value: 'medium', label: 'Medium - Normal' }, { value: 'low', label: 'Low - When available' }].map(opt => <label key={opt.value} className="flex items-center gap-3 p-3 bg-gray-800 border border-gray-700 rounded cursor-pointer hover:border-gray-600"><input type="radio" name="priority" value={opt.value} checked={priority === opt.value} onChange={(e) => setPriority(e.target.value)} /><span className="text-sm text-gray-100">{opt.label}</span></label>)}</div></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={() => onClaim(priority)} className="flex-1 bg-blue-600 hover:bg-blue-700 py-2 rounded transition-colors">Claim</button></div>
          </div>
        </Modal>
      );
    }

    function CompleteActivityModal({ activity, flow, onClose, onComplete }) {
      const [note, setNote] = useState('');
      const orderedStages = useMemo(() => getOrderedStages(flow), [flow]);
      const currentStage = useMemo(() => {
        if (!activity) return null;
        const stageId = activity.currentStageId || activity.stageId || getActivityDefaultStageId(activity, orderedStages);
        return stageId ? orderedStages.find(stage => getStageIdentity(stage) === stageId) || null : null;
      }, [activity, orderedStages]);
      const stageId = currentStage ? getStageIdentity(currentStage) : null;
      const nextStageId = currentStage ? getNextStageId(orderedStages, getStageIdentity(currentStage), activity?.skippedStages || []) : null;
      const nextStage = nextStageId ? orderedStages.find(stage => getStageIdentity(stage) === nextStageId) || null : null;
      const currentEntry = stageId ? getLatestStageHistoryEntry(activity?.stageHistory, stageId) : null;
      const stageLog = currentEntry?.log || [];

      const handleSubmit = (skipStage = false) => {
        onComplete({ skipStage, note: note.trim() || null });
      };

      return (
        <Modal onClose={onClose} title="Advance Stage" size="large">
          <div className="space-y-4">
            <div className="bg-gray-900 rounded-lg p-4">
              <h3 className="font-medium text-gray-100">{activity?.title}</h3>
              {currentStage && <p className="text-sm text-gray-300 mt-1">Mark the <span className="font-semibold text-gray-100">{currentStage.name}</span> stage as complete or skipped.</p>}
            </div>
            {currentStage && (
              <div className="bg-gray-900/40 border border-gray-800 rounded-lg p-4 space-y-3">
                <div className="flex items-center justify-between text-sm text-gray-300">
                  <span>Current stage</span>
                  <span className="text-gray-100 font-medium">{currentStage.name}</span>
                </div>
                {currentStage.conditions && <div className="text-xs text-blue-200 bg-blue-900/30 border border-blue-800/40 rounded px-3 py-2">Conditions: {currentStage.conditions}</div>}
                <div className="text-xs text-gray-400">
                  {nextStage ? (
                    <p>Advancing will move this activity to <span className="text-gray-100">{nextStage.name}</span>.</p>
                  ) : (
                    <p>Advancing will complete this activity.</p>
                  )}
                </div>
                {stageLog.length > 0 && (
                  <div className="text-xs text-gray-400">
                    <div className="uppercase tracking-wide text-gray-500 mb-2">Recent stage history</div>
                    <ul className="space-y-1">
                      {stageLog.slice(-5).reverse().map(entry => (
                        <li key={entry.id} className="flex items-center justify-between gap-3">
                          <span>{entry.text}</span>
                          <span className="text-[10px] text-gray-500">{formatRelativeTime(entry.timestamp)}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            )}
            <div>
              <label className="block text-sm text-gray-200 mb-2">Notes (optional)</label>
              <textarea value={note} onChange={(e) => setNote(e.target.value)} rows={3} placeholder="Add any context about this stage completion" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-500" />
            </div>
            <div className="grid md:grid-cols-3 gap-3 pt-2">
              <button onClick={onClose} className="bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button>
              <button onClick={() => handleSubmit(true)} className="bg-yellow-800 hover:bg-yellow-700 text-yellow-100 py-2 rounded transition-colors">Skip Stage</button>
              <button onClick={() => handleSubmit(false)} className="bg-green-600 hover:bg-green-700 py-2 rounded transition-colors">Mark Stage Complete</button>
            </div>
          </div>
        </Modal>
      );
    }

    function WireActivityModal({ project, activity, flow, roles, onClose, onWire, onCreate, onCreateRole, onUpdateRole }) {
      const [mode, setMode] = useState('existing');
      const [targetId, setTargetId] = useState('');
      const [edgeType, setEdgeType] = useState('enables');
      const [newTitle, setNewTitle] = useState('');
      const [newRoleId, setNewRoleId] = useState('');
      const [newDeliverable, setNewDeliverable] = useState('');
      const [showNewRole, setShowNewRole] = useState(false);
      const [newRoleName, setNewRoleName] = useState('');
      const [newRoleOperator, setNewRoleOperator] = useState('');
      const [selectedUserIds, setSelectedUserIds] = useState([]);
      const orderedStages = useMemo(() => getOrderedStages(flow), [flow]);
      const stageOptions = useMemo(() => orderedStages.map(stage => ({ id: getStageIdentity(stage), name: stage.name, skipped: stage.skipped })), [orderedStages]);
      const defaultSrcStageId = useMemo(() => {
        if (activity) {
          return activity.currentStageId || activity.stageId || getActivityDefaultStageId(activity, orderedStages) || (stageOptions[0]?.id || '');
        }
        return stageOptions[0]?.id || '';
      }, [activity, orderedStages, stageOptions]);
      const [srcStageId, setSrcStageId] = useState(defaultSrcStageId);
      const [dstStageId, setDstStageId] = useState(stageOptions[0]?.id || '');
      const [newInitialStageId, setNewInitialStageId] = useState(stageOptions[0]?.id || '');

      const availableActivities = flow.activities.filter(a => a.id !== activity.id && !a.completedAt);
      const targetActivity = useMemo(() => availableActivities.find(a => a.id === targetId) || null, [availableActivities, targetId]);

      useEffect(() => {
        setSrcStageId(defaultSrcStageId);
      }, [defaultSrcStageId]);

      useEffect(() => {
        if (targetActivity) {
          const inferred = targetActivity.currentStageId || targetActivity.stageId || getActivityDefaultStageId(targetActivity, orderedStages) || stageOptions[0]?.id || '';
          setDstStageId(inferred || '');
        } else if (stageOptions[0]) {
          setDstStageId(stageOptions[0].id);
        }
      }, [targetActivity, orderedStages, stageOptions]);

      useEffect(() => {
        if (mode === 'new') {
          setDstStageId(newInitialStageId || stageOptions[0]?.id || '');
        }
      }, [mode, newInitialStageId, stageOptions]);

      useEffect(() => {
        if (!newRoleId) return;
        const role = roles.find(r => r.id === newRoleId);
        const stage = findStageForRole(flow, role) || orderedStages[0] || null;
        const inferred = stage ? getStageIdentity(stage) : stageOptions[0]?.id || '';
        setNewInitialStageId(inferred || '');
      }, [newRoleId, roles, flow, orderedStages, stageOptions]);

      const handleCreateRole = () => {
        if (newRoleName && newRoleOperator) {
          const role = onCreateRole(newRoleName, newRoleOperator, selectedUserIds);
          setNewRoleId(role.id);
          setShowNewRole(false);
        }
      };

      const toggleUser = (userId) => {
        setSelectedUserIds(prev => prev.includes(userId) ? prev.filter(id => id !== userId) : [...prev, userId]);
      };

      const canWireExisting = Boolean(targetId && srcStageId && dstStageId);
      const canCreateNew = Boolean(newTitle && newRoleId && srcStageId && newInitialStageId && dstStageId);

      return (
        <Modal onClose={onClose} title="Wire Activity" size="large">
          <div className="space-y-4">
            <div className="bg-gray-900 rounded-lg p-4"><h3 className="font-medium text-gray-100">{activity?.title}</h3><p className="text-sm text-gray-300 mt-1">Connect this activity to another</p></div>
            <div><label className="block text-sm text-gray-200 mb-2">Connection type</label><select value={edgeType} onChange={(e) => setEdgeType(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100"><option value="enables">Enables (this unlocks the other)</option><option value="requires">Requires (this depends on the other)</option></select></div>
            <div className="grid md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm text-gray-200 mb-2">Source stage</label>
                <select value={srcStageId} onChange={(e) => setSrcStageId(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100">
                  <option value="">Choose...</option>
                  {stageOptions.map(option => (
                    <option key={option.id} value={option.id}>{option.name}{option.skipped ? ' (skipped)' : ''}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm text-gray-200 mb-2">{mode === 'existing' ? 'Target stage' : 'Dependency stage'}</label>
                <select value={dstStageId} onChange={(e) => setDstStageId(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100">
                  <option value="">Choose...</option>
                  {stageOptions.map(option => (
                    <option key={option.id} value={option.id}>{option.name}{option.skipped ? ' (skipped)' : ''}</option>
                  ))}
                </select>
                {mode === 'existing' && !targetActivity && <p className="text-xs text-gray-500 mt-1">Select a target activity to prefill its current stage.</p>}
              </div>
            </div>
            <div className="flex gap-2 p-2 bg-gray-800 rounded"><button onClick={() => setMode('existing')} className={`flex-1 py-2 px-3 rounded text-sm transition-colors ${mode === 'existing' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'}`}>Existing Activity</button><button onClick={() => setMode('new')} className={`flex-1 py-2 px-3 rounded text-sm transition-colors ${mode === 'new' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'}`}>Create New</button></div>
            {mode === 'existing' ? (
              <>
                <div><label className="block text-sm text-gray-200 mb-2">Select activity</label><select value={targetId} onChange={(e) => setTargetId(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100"><option value="">Choose...</option>{availableActivities.map(a => <option key={a.id} value={a.id}>{a.title}</option>)}</select></div>
                <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (canWireExisting) onWire({ targetId, edgeType, srcStageId, dstStageId }); }} disabled={!canWireExisting} className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 py-2 rounded transition-colors">Wire</button></div>
              </>
            ) : (
              <>
                <div>
                  <label className="block text-sm text-gray-200 mb-2">New activity starts at</label>
                  <select value={newInitialStageId} onChange={(e) => setNewInitialStageId(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100">
                    <option value="">Choose...</option>
                    {stageOptions.map(option => (
                      <option key={option.id} value={option.id}>{option.name}{option.skipped ? ' (skipped)' : ''}</option>
                    ))}
                  </select>
                </div>
                <div><label className="block text-sm text-gray-200 mb-2">New activity title</label><input type="text" value={newTitle} onChange={(e) => setNewTitle(e.target.value)} placeholder="e.g., Review article" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
                {!showNewRole ? (
                  <>
                    <div><label className="block text-sm text-gray-200 mb-2">Role</label><select value={newRoleId} onChange={(e) => setNewRoleId(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100"><option value="">Choose...</option>{roles.map(r => { const op = OPERATORS.find(o => o.id === r.operatorType); return <option key={r.id} value={r.id}>{r.name} ({op?.name})</option>; })}</select></div>
                    <button onClick={() => setShowNewRole(true)} className="text-sm text-blue-400 hover:text-blue-300">+ Create new role</button>
                  </>
                ) : (
                  <>
                    <div><label className="block text-sm text-gray-200 mb-2">New role name</label><input type="text" value={newRoleName} onChange={(e) => setNewRoleName(e.target.value)} placeholder="e.g., Editor" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
                    <div><label className="block text-sm text-gray-200 mb-2">Operator type</label><select value={newRoleOperator} onChange={(e) => setNewRoleOperator(e.target.value)} className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100"><option value="">Choose...</option>{OPERATORS.map(op => <option key={op.id} value={op.id}>{op.seq}. {op.name}</option>)}</select></div>
                    <div><label className="block text-sm text-gray-200 mb-2">Assign users</label><div className="space-y-2">{project.users.map(user => <label key={user.id} className="flex items-center gap-3 p-3 bg-gray-800 border border-gray-700 rounded cursor-pointer hover:border-gray-600"><input type="checkbox" checked={selectedUserIds.includes(user.id)} onChange={() => toggleUser(user.id)} /><span className="text-sm text-gray-100">{user.name}</span></label>)}</div></div>
                    <div className="flex gap-2"><button onClick={handleCreateRole} disabled={!newRoleName || !newRoleOperator} className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-700 py-2 rounded transition-colors">Create Role</button><button onClick={() => setShowNewRole(false)} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button></div>
                  </>
                )}
                <div><label className="block text-sm text-gray-200 mb-2">Deliverable (optional)</label><input type="text" value={newDeliverable} onChange={(e) => setNewDeliverable(e.target.value)} placeholder="e.g., Reviewed draft" className="w-full bg-gray-800 border border-gray-700 rounded px-4 py-2 text-gray-100 placeholder-gray-400" /></div>
                <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-gray-700 hover:bg-gray-600 py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (canCreateNew) onCreate({ title: newTitle, roleId: newRoleId, deliverable: newDeliverable, edgeType, srcStageId, dstStageId, initialStageId: newInitialStageId }); }} disabled={!canCreateNew} className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-700 py-2 rounded transition-colors">Create & Wire</button></div>
              </>
            )}
          </div>
        </Modal>
      );
    }

    function Modal({ children, onClose, title, size = 'medium' }) {
      const sizeClasses = { medium: 'max-w-2xl', large: 'max-w-4xl' };
      return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-6 z-50">
          <div className={`bg-gray-900 rounded-lg border border-gray-800 w-full ${sizeClasses[size]} max-h-[90vh] overflow-y-auto`}>
            <div className="sticky top-0 bg-gray-900 border-b border-gray-800 p-6 flex items-center justify-between">
              <h2 className="text-xl font-semibold text-gray-100">{title}</h2>
              <button onClick={onClose} className="text-gray-300 hover:text-gray-100 transition-colors"><XIcon className="w-5 h-5" /></button>
            </div>
            <div className="p-6">{children}</div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EventOperator />);
  </script>
</body>
</html>
