<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EO - Emergent Organizing</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class'
    };
  </script>
  <style>
    :root {
      --bg: #F9FAFB;
      --surface: #FFFFFF;
      --elevated: #F3F4F6;
      --border: #E5E7EB;
      --text-strong: #111827;
      --text: #1F2937;
      --text-muted: #6B7280;

      --accent: #2563EB;
      --ok: #15803D;
      --info: #1D4ED8;
      --warn: #B45309;
      --danger: #B91C1C;

      --focus: #3B82F6;
    }

    .dark {
      --bg: #0B0F17;
      --surface: #0F172A;
      --elevated: #111827;
      --border: #1F2937;
      --text-strong: #F9FAFB;
      --text: #E5E7EB;
      --text-muted: #9CA3AF;

      --accent: #60A5FA;
      --ok: #34D399;
      --info: #93C5FD;
      --warn: #F59E0B;
      --danger: #F87171;

      --focus: #60A5FA;
    }

    @media (prefers-color-scheme: dark) {
      :root:not(.force-light):not(.force-dark) {
        color-scheme: dark;
      }
    }

    body {
      background: var(--bg);
      color: var(--text);
    }

    :focus-visible {
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        animation: none !important;
        transition: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    (function initTheme() {
      const saved = localStorage.getItem('theme');
      const prefersDark =
        window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const root = document.documentElement;
      if (saved === 'dark') {
        root.classList.add('dark', 'force-dark');
        root.classList.remove('force-light');
        root.style.colorScheme = 'dark';
      } else if (saved === 'light') {
        root.classList.remove('dark');
        root.classList.add('force-light');
        root.classList.remove('force-dark');
        root.style.colorScheme = 'light';
      } else {
        root.classList.toggle('dark', prefersDark);
        root.classList.remove('force-light', 'force-dark');
        root.style.colorScheme = prefersDark ? 'dark' : 'light';
      }
    })();
  </script>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    const OPERATORS = [
      { id: 'starter', name: 'Starter', desc: 'Conceives and designs work', seq: 1, tier: 'genesis', canRequestRevision: false },
      { id: 'doer', name: 'Doer', desc: 'Builds and produces artifacts', seq: 2, tier: 'genesis', canRequestRevision: false },
      { id: 'compiler', name: 'Compiler', desc: 'Packages work into coherent form', seq: 3, tier: 'genesis', canRequestRevision: false },
      { id: 'reviewer', name: 'Reviewer', desc: 'Tests and evaluates quality', seq: 4, tier: 'evaluation', canRequestRevision: true },
      { id: 'approver', name: 'Approver', desc: 'Authorizes and validates', seq: 5, tier: 'evaluation', canRequestRevision: true },
      { id: 'documenter', name: 'Documenter', desc: 'Records and formalizes', seq: 6, tier: 'evaluation', canRequestRevision: false },
      { id: 'integrator', name: 'Integrator', desc: 'Synthesizes into coherent wholes', seq: 7, tier: 'continuity', canRequestRevision: false },
      { id: 'maintainer', name: 'Maintainer', desc: 'Preserves and sustains systems', seq: 8, tier: 'continuity', canRequestRevision: false },
      { id: 'evolver', name: 'Evolver', desc: 'Transforms and reinitiates cycles', seq: 9, tier: 'continuity', canRequestRevision: false }
    ];

    const STAGE_TIERS = {
      creation: ['starter', 'doer', 'compiler'],
      verification: ['reviewer', 'approver', 'documenter'],
      evolution: ['integrator', 'maintainer', 'evolver']
    };

    const TIER_LABELS = {
      creation: { title: 'Creation', subtitle: 'Formation & Building' },
      verification: { title: 'Verification', subtitle: 'Quality & Approval' },
      evolution: { title: 'Evolution', subtitle: 'Integration & Growth' }
    };

    function toUniqueIds(list = []) {
      return Array.from(new Set((Array.isArray(list) ? list : []).filter(Boolean)));
    }

    function trimString(value) {
      return typeof value === 'string' ? value.trim() : '';
    }

    function createUserProfile(data = {}) {
      const now = new Date().toISOString();
      return {
        id: data.id || `user-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        name: trimString(data.name),
        email: trimString(data.email),
        phone: trimString(data.phone),
        relationship: trimString(data.relationship),
        role: data.role || 'viewer',
        matrixId: trimString(data.matrixId),
        avatar: data.avatar || '',
        notes: trimString(data.notes),
        addedAt: data.addedAt || now,
        lastModified: data.lastModified || now,
        metadata: data.metadata || {}
      };
    }

    function getDirectoryUserKey(user) {
      if (!user) return null;
      const email = trimString(user.email || '').toLowerCase();
      if (email) return `email:${email}`;
      const matrixId = trimString(user.matrixId || '').toLowerCase();
      if (matrixId) return `matrix:${matrixId}`;
      const phoneDigits = trimString(user.phone || '').replace(/\D+/g, '');
      if (phoneDigits) return `phone:${phoneDigits}`;
      const name = trimString(user.name || '');
      if (!name) return null;
      const relationship = trimString(user.relationship || '').toLowerCase();
      const role = trimString(user.role || '').toLowerCase();
      return `name:${name.toLowerCase()}|rel:${relationship}|role:${role}`;
    }

    function mergeDirectoryUser(existing, candidate) {
      if (!existing) return candidate;
      if (!candidate) return existing;
      const merged = { ...existing };
      const fields = ['email', 'phone', 'relationship', 'role', 'matrixId', 'avatar', 'notes'];
      fields.forEach(field => {
        if (!trimString(merged[field]) && trimString(candidate[field])) {
          merged[field] = candidate[field];
        }
      });
      if (candidate.metadata) {
        merged.metadata = { ...(merged.metadata || {}), ...candidate.metadata };
      }
      return merged;
    }

    function buildProjectDirectory(projects = []) {
      const userMap = new Map();
      const roleMap = new Map();

      const ensureDirectoryUser = (user) => {
        if (!user) return null;
        const key = getDirectoryUserKey(user);
        if (!key) return null;
        const candidate = { ...user, directoryKey: key };
        if (!userMap.has(key)) {
          userMap.set(key, candidate);
          return candidate;
        }
        const existing = userMap.get(key);
        const merged = mergeDirectoryUser(existing, candidate);
        merged.directoryKey = key;
        userMap.set(key, merged);
        return merged;
      };

      projects.forEach(project => {
        const projectUsers = Array.isArray(project?.users) ? project.users : [];
        projectUsers.forEach(ensureDirectoryUser);
        const userLookup = new Map(projectUsers.map(user => [user.id, user]));
        const teams = Array.isArray(project?.teams) ? project.teams : [];
        teams.forEach(team => {
          const members = (Array.isArray(team?.userIds) ? team.userIds : [])
            .map(id => userLookup.get(id))
            .map(ensureDirectoryUser)
            .filter(Boolean);
          if (members.length === 0) return;
          const memberKeys = members.map(member => member.directoryKey).filter(Boolean);
          if (memberKeys.length === 0) return;
          const roleId = `${project.id || 'project'}-${team.id || team.name || memberKeys.join('-')}`;
          if (roleMap.has(roleId)) {
            const existing = roleMap.get(roleId);
            const combinedKeys = Array.from(new Set([...existing.memberKeys, ...memberKeys]));
            roleMap.set(roleId, {
              ...existing,
              memberKeys: combinedKeys,
              members: combinedKeys.map(key => userMap.get(key)).filter(Boolean)
            });
            return;
          }
          roleMap.set(roleId, {
            id: roleId,
            name: trimString(team.name) || 'Team',
            projectName: trimString(project.name) || 'Project',
            members: memberKeys.map(key => userMap.get(key)).filter(Boolean),
            memberKeys
          });
        });
      });

      const users = Array.from(userMap.values()).sort((a, b) =>
        trimString(a.name).localeCompare(trimString(b.name))
      );
      const roles = Array.from(roleMap.values()).sort((a, b) =>
        trimString(a.name).localeCompare(trimString(b.name))
      );

      return { users, roles, userMap };
    }

    function normalizeProjectUserPayload({ selectedUsers = [], manualMembers = [], fallbackUsers = [] }) {
      const seen = new Set();
      const payload = [];

      const pushEntry = (entry) => {
        if (!entry) return;
        if (typeof entry === 'string') {
          const name = trimString(entry);
          if (!name) return;
          const key = name.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          payload.push({ name });
          return;
        }
        if (typeof entry === 'object') {
          const name = trimString(entry.name || '');
          if (!name) return;
          const key = name.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          const data = { ...entry };
          delete data.id;
          delete data.addedAt;
          delete data.lastModified;
          delete data.directoryKey;
          if (data.metadata) {
            data.metadata = { ...data.metadata };
          }
          data.name = name;
          payload.push(data);
        }
      };

      selectedUsers.forEach(pushEntry);
      manualMembers.forEach(pushEntry);
      fallbackUsers.forEach(pushEntry);

      return payload;
    }

    function getUserInitials(name) {
      if (!name) return 'ðŸ‘¤';
      const parts = trimString(name).split(/\s+/).filter(Boolean);
      if (parts.length === 0) return 'ðŸ‘¤';
      if (parts.length === 1) return parts[0].charAt(0).toUpperCase();
      return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();
    }

    function sanitizeTaggedUserIds(taggedUserIds, project) {
      if (!project) return [];
      const allowed = new Set((project.users || []).map(user => user.id));
      return Array.from(
        new Set(
          (Array.isArray(taggedUserIds) ? taggedUserIds : []).filter(id => allowed.has(id))
        )
      );
    }

    function formatTaggedUserNames(taggedUserIds, project) {
      if (!project) return [];
      const userMap = new Map((project.users || []).map(user => [user.id, user.name]));
      return (Array.isArray(taggedUserIds) ? taggedUserIds : [])
        .map(id => trimString(userMap.get(id) || ''))
        .filter(Boolean);
    }

    function pruneActivityUserTags(activity, userId) {
      if (!activity) return activity;

      const filterTagged = (tagged) => {
        if (!Array.isArray(tagged)) return tagged;
        const filtered = tagged.filter(id => id !== userId);
        return filtered;
      };

      const updateLogs = (logs) => {
        if (!Array.isArray(logs)) return logs;
        return logs.map(log => {
          if (!Array.isArray(log?.taggedUserIds)) return log;
          const filtered = filterTagged(log.taggedUserIds);
          return filtered.length === log.taggedUserIds.length ? log : { ...log, taggedUserIds: filtered };
        });
      };

      const stageHistory = Array.isArray(activity.stageHistory)
        ? activity.stageHistory.map(entry => {
            const updatedLogs = updateLogs(entry.log);
            return updatedLogs === entry.log ? entry : { ...entry, log: updatedLogs };
          })
        : activity.stageHistory;

      const comments = Array.isArray(activity.comments)
        ? activity.comments.map(comment => {
            if (!Array.isArray(comment.taggedUserIds)) return comment;
            const filtered = filterTagged(comment.taggedUserIds);
            return filtered.length === comment.taggedUserIds.length ? comment : { ...comment, taggedUserIds: filtered };
          })
        : activity.comments;

      const history = Array.isArray(activity.history)
        ? activity.history.map(entry => {
            if (!Array.isArray(entry.taggedUserIds)) return entry;
            const filtered = filterTagged(entry.taggedUserIds);
            return filtered.length === entry.taggedUserIds.length ? entry : { ...entry, taggedUserIds: filtered };
          })
        : activity.history;

      return {
        ...activity,
        stageHistory,
        comments,
        history
      };
    }

    const DEFAULT_STAGE_BLUEPRINT = OPERATORS.map((op, index) => ({
      key: op.id,
      name: op.name,
      description: op.desc,
      order: index,
      tier: op.tier,
      supportsRevision: op.canRequestRevision
    }));

    // Gentle, lay-friendly defaults (flow rhythm)
    const DEFAULT_STAGE_TIMELINES = {
      starter: 10,
      doer: 14,
      compiler: 7,
      reviewer: 4,
      approver: 3,
      documenter: 7,
      integrator: 10,
      maintainer: 0,
      evolver: 0
    };

    // Default EO-aligned, lay-friendly conditions
    const DEFAULT_CONDITIONS = {
      starter: "Goal, owner, and success criteria are clear.",
      doer: "Something tangible exists to review (a draft, prototype, or demo).",
      compiler: "Pieces combined into a coherent package ready for feedback.",
      reviewer: "At least one peer has reviewed and left feedback.",
      approver: "Decision-maker has signed off or provided approval notes.",
      documenter: "Final version and key notes recorded in one place.",
      integrator: "Work merged into the wider system or process.",
      maintainer: "Monitoring, updates, and issue tracking are active.",
      evolver: "Lessons captured and next cycle defined or initiated."
    };

    const OPERATOR_ORDER = OPERATORS.reduce((acc, operator, index) => {
      acc[operator.id] = index;
      return acc;
    }, {});

    const PULSE_STAGE_GROUPS = { genesis: [], evaluation: [], continuity: [] };
    OPERATORS.forEach(operator => {
      if (!PULSE_STAGE_GROUPS[operator.tier]) {
        PULSE_STAGE_GROUPS[operator.tier] = [];
      }
      PULSE_STAGE_GROUPS[operator.tier].push({
        id: operator.id,
        name: operator.name,
        desc: operator.desc
      });
    });

    Object.keys(PULSE_STAGE_GROUPS).forEach(tier => {
      PULSE_STAGE_GROUPS[tier] = PULSE_STAGE_GROUPS[tier].sort((a, b) => {
        return (OPERATOR_ORDER[a.id] || 0) - (OPERATOR_ORDER[b.id] || 0);
      });
    });

    const PULSE_TIER_META = {
      genesis: { label: 'GENESIS', subtitle: 'Formation', color: 'text-[var(--info)]' },
      evaluation: { label: 'EVALUATION', subtitle: 'Refinement', color: 'text-[var(--accent)]' },
      continuity: { label: 'CONTINUITY', subtitle: 'Recursion', color: 'text-[var(--ok)]' }
    };

    const TEAM_COLOR_MAP = {
      blue: 'var(--info)',
      green: 'var(--ok)',
      purple: 'var(--accent)',
      orange: 'var(--warn)'
    };

    function createDefaultStageConfig() {
      return OPERATORS.map(op => ({
        stageKey: op.id,
        active: true,
        assignedTeamIds: [],
        assignedUserIds: [],
        optedOutUserIds: []
      }));
    }

    function normalizeStageConfigEntry(entry) {
      if (!entry) return null;
      const stageKey = entry.stageKey || entry.operatorKey || entry.key || entry.id;
      if (!stageKey) return null;
      const {
        assignedTeamIds: entryAssignedTeamIds,
        assignedRoleIds: entryAssignedRoleIds,
        assignedUserIds: entryAssignedUserIds,
        optedOutUserIds: entryOptedOutUserIds,
        roleId,
        roleIds,
        userIds: entryUserIds,
        excludedUserIds,
        ...rest
      } = entry;
      const assignedTeamIds = toUniqueIds([
        ...(Array.isArray(entryAssignedTeamIds) ? entryAssignedTeamIds : []),
        ...(Array.isArray(entryAssignedRoleIds) ? entryAssignedRoleIds : []),
        ...(Array.isArray(roleIds) ? roleIds : []),
        ...(roleId ? [roleId] : [])
      ]);
      const assignedUserIds = toUniqueIds([
        ...(Array.isArray(entryAssignedUserIds) ? entryAssignedUserIds : []),
        ...(Array.isArray(entryUserIds) ? entryUserIds : [])
      ]);
      const optedOutUserIds = toUniqueIds([
        ...(Array.isArray(entryOptedOutUserIds) ? entryOptedOutUserIds : []),
        ...(Array.isArray(excludedUserIds) ? excludedUserIds : [])
      ]);
      return {
        ...rest,
        stageKey,
        active: entry.active !== false,
        assignedTeamIds,
        assignedUserIds,
        optedOutUserIds
      };
    }

    function getFlowStageConfig(flow) {
      const existing = Array.isArray(flow?.stageConfig) ? flow.stageConfig : [];
      const normalized = existing
        .map(normalizeStageConfigEntry)
        .filter(Boolean);
      const configMap = new Map(normalized.map(entry => [entry.stageKey, entry]));
      const ordered = OPERATORS.map(op => {
        const existingEntry = configMap.get(op.id);
        if (existingEntry) {
          return { ...existingEntry, stageKey: op.id, active: existingEntry.active !== false };
        }
        return {
          stageKey: op.id,
          active: true,
          assignedTeamIds: [],
          assignedUserIds: [],
          optedOutUserIds: []
        };
      });
      normalized.forEach(entry => {
        if (!ordered.find(item => item.stageKey === entry.stageKey)) {
          ordered.push(entry);
        }
      });
      return ordered;
    }

    function getFirstActiveStage(orderedStages = []) {
      for (const stage of orderedStages) {
        if (!stage?.skipped) return stage;
      }
      return orderedStages[0] || null;
    }

    function getStageIdentity(stage) {
      return stage?.id || stage?.key || stage?.name;
    }

    function createDefaultStages() {
      const timestamp = Date.now();
      return DEFAULT_STAGE_BLUEPRINT.map((stage, idx) => ({
        id: `stage-${timestamp}-${idx}`,
        key: stage.key,
        operatorKey: stage.key,
        name: stage.name,
        description: stage.description,
        order: idx,
        tier: stage.tier,
        roleId: null,
        supportsRevision: stage.supportsRevision,
        expectedDurationDays: DEFAULT_STAGE_TIMELINES[stage.key] ?? 0,
        conditions: DEFAULT_CONDITIONS[stage.key] || '',
        skipped: false
      }));
    }

    function getOrderedStages(flow) {
      const stages = Array.isArray(flow?.stages) && flow.stages.length > 0
        ? flow.stages
        : DEFAULT_STAGE_BLUEPRINT.map((stage, idx) => ({
            key: stage.key,
            operatorKey: stage.key,
            name: stage.name,
            description: stage.description,
            order: idx,
            tier: stage.tier,
            roleId: null,
            supportsRevision: stage.supportsRevision,
            expectedDurationDays: DEFAULT_STAGE_TIMELINES[stage.key] ?? 0,
            conditions: DEFAULT_CONDITIONS[stage.key] || '',
            skipped: false
          }));

      const stageConfig = getFlowStageConfig(flow || {});
      const stageConfigMap = new Map(stageConfig.map(entry => [entry.stageKey, entry]));

      return [...stages]
        .map((stage, idx) => {
          const operatorKey = stage.operatorKey || stage.key;
          const config = stageConfigMap.get(operatorKey) || null;
          const skipped = config ? !config.active : stage.skipped;
          return {
            ...stage,
            order: stage.order ?? idx,
            operatorKey,
            tier: stage.tier || DEFAULT_STAGE_BLUEPRINT[idx]?.tier,
            uid: getStageIdentity(stage),
            skipped: skipped ?? false,
            stageConfig: config || null
          };
        })
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
    }

    function addDays(ts, days) {
      if (!ts || !Number.isFinite(days)) return ts;
      const d = new Date(ts);
      d.setDate(d.getDate() + Math.max(0, Math.floor(days)));
      return d.getTime();
    }

    function getStageExpectedDays(stage, activity) {
      const key = stage?.operatorKey || stage?.key;
      if (!key) return Number.isFinite(stage?.expectedDurationDays) ? stage.expectedDurationDays : 0;
      const override = activity?.stageDurations && Number.isFinite(activity.stageDurations[key])
        ? activity.stageDurations[key]
        : null;
      if (override !== null) return override;
      if (Number.isFinite(stage?.expectedDurationDays)) return stage.expectedDurationDays;
      return DEFAULT_STAGE_TIMELINES[key] ?? 0;
    }

    function computeExpectedEnd(activity, flow, now = Date.now()) {
      if (!activity || !flow) return { expectedEnd: null, expectedWindowLabel: '' };

      if (activity.timelineMode === 'specific' && activity.targetDate) {
        const parsed = new Date(activity.targetDate);
        const expectedEnd = parsed.getTime();
        if (!Number.isFinite(expectedEnd)) {
          return { expectedEnd: null, expectedWindowLabel: 'Target date' };
        }
        return { expectedEnd, expectedWindowLabel: 'Target date' };
      }

      const ordered = getOrderedStages(flow) || [];
      const currId = activity.currentStageId || activity.stageId || (ordered[0] ? (ordered[0].id || ordered[0].key) : null);
      const startEntry = getLatestStageHistoryEntry(activity.stageHistory, currId) || null;
      const startTs = startEntry?.enteredAt || activity.createdAt || now;

      let sumDays = 0;
      let windowStartName = '';
      let windowEndName = '';
      let inRange = false;

      for (const st of ordered) {
        const id = st.id || st.key || st.operatorKey;
        if (!windowStartName && id === currId) {
          inRange = true;
          windowStartName = st.name || 'Start';
        }
        if (!inRange) continue;
        const d = getStageExpectedDays(st, activity);
        sumDays += Math.max(0, d || 0);
        windowEndName = st.name || windowEndName;
      }

      const expectedEnd = sumDays > 0 ? addDays(startTs, sumDays) : null;
      const approx = sumDays > 0 ? `â‰ˆ ${sumDays} day${sumDays === 1 ? '' : 's'}` : 'continuous';
      const expectedWindowLabel = (windowStartName && windowEndName)
        ? `${windowStartName} â†’ ${windowEndName} ${approx}`
        : `Expected window ${approx}`;

      return { expectedEnd, expectedWindowLabel };
    }

    function computePhaseDrift(actualOrNow, expectedEnd) {
      if (!expectedEnd) return { driftDays: 0, driftLabel: '' };
      const actual = actualOrNow ?? Date.now();
      const msPerDay = 24 * 60 * 60 * 1000;
      const diffDays = Math.round((actual - expectedEnd) / msPerDay);
      if (diffDays === 0) return { driftDays: 0, driftLabel: 'on beat' };
      if (diffDays > 0) return { driftDays: diffDays, driftLabel: `phase drift: +${diffDays}d` };
      return { driftDays: diffDays, driftLabel: `phase lead: ${Math.abs(diffDays)}d` };
    }

    function findStageForRole(flow, role) {
      if (!role || !flow) return null;
      const orderedStages = getOrderedStages(flow);
      const stageConfig = getFlowStageConfig(flow);
      for (const config of stageConfig) {
        if (config.active === false) continue;
        const assignedTeams = Array.isArray(config.assignedTeamIds) ? config.assignedTeamIds : [];
        const legacyAssignedRoles = Array.isArray(config.assignedRoleIds) ? config.assignedRoleIds : [];
        if (role && (assignedTeams.includes(role.id) || legacyAssignedRoles.includes(role.id))) {
          const stage = orderedStages.find(stageItem => {
            const identity = getStageIdentity(stageItem);
            return identity === config.stageKey || stageItem.operatorKey === config.stageKey || stageItem.key === config.stageKey;
          });
          if (stage) return stage;
        }
      }
      return null;
    }

    function createStageHistoryEntry(stageId, timestamp) {
      return {
        id: `stage-entry-${timestamp}-${Math.random().toString(36).slice(2, 7)}`,
        stageId,
        enteredAt: timestamp,
        exitedAt: null,
        claimedBy: null,
        claimedAt: null,
        priority: null,
        completedAt: null,
        skippedAt: null,
        log: []
      };
    }

    function getLatestStageHistoryEntry(stageHistory, stageId) {
      if (!Array.isArray(stageHistory)) return null;
      for (let i = stageHistory.length - 1; i >= 0; i--) {
        const entry = stageHistory[i];
        if (entry?.stageId === stageId) {
          return entry;
        }
      }
      return null;
    }

    function updateLatestStageHistoryEntry(stageHistory, stageId, updater, { createIfMissing = false, timestamp = Date.now() } = {}) {
      const nextHistory = Array.isArray(stageHistory) ? [...stageHistory] : [];
      for (let i = nextHistory.length - 1; i >= 0; i--) {
        if (nextHistory[i]?.stageId === stageId) {
          nextHistory[i] = updater(nextHistory[i]);
          return nextHistory;
        }
      }
      if (createIfMissing && stageId) {
        const created = updater(createStageHistoryEntry(stageId, timestamp));
        nextHistory.push(created);
      }
      return nextHistory;
    }

    function ensureStageTracking(activity, stageId, timestamp = Date.now()) {
      const currentStageId = stageId || activity.currentStageId || activity.stageId || null;
      const baseHistory = Array.isArray(activity.stageHistory) ? activity.stageHistory : [];
      let stageHistory = [...baseHistory];
      if (currentStageId && !getLatestStageHistoryEntry(stageHistory, currentStageId)) {
        stageHistory.push(createStageHistoryEntry(currentStageId, activity.createdAt || timestamp));
      }
      const stageReadBy = { ...(activity.stageReadBy || {}) };
      if (currentStageId && !stageReadBy[currentStageId]) {
        stageReadBy[currentStageId] = { ...(activity.readBy || {}) };
      }
      return { currentStageId, stageHistory, stageReadBy };
    }

    function getActivityDefaultStageId(activity, orderedStages = []) {
      if (!activity) {
        const firstStage = getFirstActiveStage(orderedStages);
        return firstStage ? getStageIdentity(firstStage) : null;
      }
      if (activity.currentStageId) return activity.currentStageId;
      if (activity.stageId) return activity.stageId;
      if (Array.isArray(activity.stageHistory) && activity.stageHistory.length > 0) {
        const lastEntry = activity.stageHistory[activity.stageHistory.length - 1];
        if (lastEntry?.stageId) return lastEntry.stageId;
      }
      const firstStage = getFirstActiveStage(orderedStages);
      return firstStage ? getStageIdentity(firstStage) : null;
    }

    function resolveStageTeams(project, flow, stageId) {
      if (!project || !flow || !stageId) return [];

      const orderedStages = getOrderedStages(flow);
      const stage = orderedStages.find(stageItem => {
        const identity = getStageIdentity(stageItem);
        return identity === stageId || stageItem.operatorKey === stageId || stageItem.key === stageId;
      });
      const stageKey = stage ? (stage.operatorKey || stage.key || getStageIdentity(stage)) : stageId;
      const stageConfig = getFlowStageConfig(flow);
      const config = stageConfig.find(entry => entry.stageKey === stageKey);
      if (!config) return [];

      return (config.assignedTeamIds || [])
        .map(teamId => (project.teams || []).find(team => team.id === teamId))
        .filter(Boolean);
    }

    function getStageStatusFromHistory(activity, stageId) {
      if (!activity || !stageId) return { completed: false, skipped: false, entry: null };
      const entry = getLatestStageHistoryEntry(activity.stageHistory, stageId);
      const completed = !!entry?.completedAt || !!activity?.completedAt;
      const skipped = !!entry?.skippedAt;
      return { completed, skipped, entry };
    }

    function getNextStageId(orderedStages, currentStageId, skippedStages = []) {
      if (!currentStageId) return null;
      const skippedSet = new Set(skippedStages || []);
      const startIndex = orderedStages.findIndex(stage => getStageIdentity(stage) === currentStageId);
      if (startIndex === -1) return null;
      for (let idx = startIndex + 1; idx < orderedStages.length; idx++) {
        const candidate = orderedStages[idx];
        const candidateId = getStageIdentity(candidate);
        if (candidate.skipped) continue;
        if (skippedSet.has(candidateId)) continue;
        return candidateId;
      }
      return null;
    }

    // Icons
    function PlusIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" /></svg>;
    }
    function ArrowLeftIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>;
    }
    function LayersIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>;
    }
    function ChevronRightIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" /></svg>;
    }
    function XIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>;
    }
    function LinkIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" /></svg>;
    }
    function ChatBubbleIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8 10h.01M12 10h.01M16 10h.01M21 12c0 1.657-1.79 3-4 3-.295 0-.582-.021-.859-.061-.284 1.193-1.355 2.06-2.641 2.06-.358 0-.703-.065-1.019-.184-.44.498-1.086.814-1.781.814-.732 0-1.392-.347-1.829-.888-.51.355-1.137.558-1.812.558-1.648 0-2.985-1.343-2.985-3 0-.333.054-.654.153-.954C3.1 12.715 2 11.477 2 10c0-1.657 1.79-3 4-3h11c2.21 0 4 1.343 4 3z" /></svg>;
    }

    function ActivityDetailPanel({ activity, stage, nextStage, stageMap, dependencies, project, flow, currentUser, canUserWorkOnStage, onClose, onEdit, onDelete, onClaim, onUnclaim, onAdvanceStage, onSkipStage, onComplete, onWire, onRequestRevision, onAddComment, onAddAttachment, onRemoveAttachment, onUpdate }) {
      const [commentText, setCommentText] = useState('');
      const [attachmentName, setAttachmentName] = useState('');
      const [attachmentUrl, setAttachmentUrl] = useState('');

      useEffect(() => {
        setCommentText('');
        setAttachmentName('');
        setAttachmentUrl('');
      }, [activity?.id]);

      const stageState = activity.activeStageState || activity.state || 'waiting';
      const activeEntry = activity.activeStageEntry || null;
      const claimedBy = activeEntry?.claimedBy || null;
      const priority = activeEntry?.priority || null;
      const isMine = claimedBy && claimedBy === currentUser;
      const canClaim = stageState === 'ready' && !claimedBy && canUserWorkOnStage?.(flow, activity.currentStageId, currentUser);
      const canComplete = isMine && stageState === 'in_progress';
      const isCompleted = !!activity.completedAt;
      const canAdvanceStage = !isCompleted && !!nextStage && stageState !== 'completed' && stageState !== 'skipped';
      const canSkipStage = !isCompleted && !!nextStage;
      const stageSupportsRevision = stage?.supportsRevision;
      const assignedTeams = resolveStageTeams(project, flow, activity.currentStageId);

      const comments = [...(activity.comments || [])].sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      const history = [...(activity.history || [])].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      const stageHistory = [...(activity.stageHistory || [])];
      const stageStates = activity.stageStates || [];

      const stageStateLabel = stageState.replace('_', ' ');
      const { expectedEnd, expectedWindowLabel } = computeExpectedEnd(activity, flow);
      const actualForDrift = activity.completedAt ?? Date.now();
      const { driftLabel } = computePhaseDrift(actualForDrift, expectedEnd);
      const targetDateValue = (() => {
        if (!activity.targetDate) return '';
        const parsed = new Date(activity.targetDate);
        const time = parsed.getTime();
        return Number.isFinite(time) ? parsed.toISOString().slice(0, 10) : '';
      })();

      const handleAddComment = () => {
        if (!currentUser || !commentText.trim()) return;
        onAddComment(commentText);
        setCommentText('');
      };

      const handleAddAttachment = () => {
        if (!attachmentName.trim() || !currentUser) return;
        onAddAttachment({ name: attachmentName.trim(), url: attachmentUrl.trim(), addedBy: currentUser });
        setAttachmentName('');
        setAttachmentUrl('');
      };

      const renderCommentContent = (text) => {
        const parts = text.split(/(@[\w-]+)/g);
        return parts.map((part, idx) => {
          if (part.startsWith && part.startsWith('@')) {
            const name = part.slice(1);
            const isMe = currentUser && name.toLowerCase() === currentUser.toLowerCase();
            return <span key={idx} className={isMe ? 'text-[var(--info)] font-semibold' : 'text-[var(--info)]'}>{part}</span>;
          }
          return <span key={idx}>{part}</span>;
        });
      };

      const actionButtons = (
        <div className="flex flex-wrap gap-2">
          {canClaim && <button onClick={() => onClaim(activity.id)} className="bg-[var(--accent)] hover:opacity-90 px-3 py-1.5 rounded text-sm">Claim</button>}
          {isMine && !activity.completedAt && <button onClick={() => onUnclaim(activity.id)} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] px-3 py-1.5 rounded text-sm">Unclaim</button>}
          {canAdvanceStage && <button onClick={() => onAdvanceStage(activity.id, { skip: false })} className="bg-[var(--ok)] hover:opacity-90 px-3 py-1.5 rounded text-sm">Advance</button>}
          {canSkipStage && <button onClick={() => onSkipStage(activity.id)} className="bg-[var(--warn)] hover:opacity-90 px-3 py-1.5 rounded text-sm text-white">Skip Stage</button>}
          {stageSupportsRevision && dependencies.length > 0 && !activity.completedAt && (
            <button onClick={() => {
              const lastDep = dependencies[dependencies.length - 1];
              if (lastDep) {
                const reason = window.prompt('Reason for revision? (optional)', '') || '';
                onRequestRevision(activity.id, lastDep.requiredStageId || activity.currentStageId, reason);
              }
            }} className="bg-[var(--warn)] hover:opacity-90 px-3 py-1.5 rounded text-sm">Request revision</button>
          )}
          {canComplete && !nextStage && <button onClick={() => onComplete(activity.id)} className="bg-[var(--ok)] hover:opacity-90 px-3 py-1.5 rounded text-sm">Complete Activity</button>}
          {!activity.completedAt && <button onClick={() => onWire(activity.id)} className="bg-[var(--accent)] hover:opacity-90 px-3 py-1.5 rounded text-sm">Wire</button>}
          {!activity.completedAt && <button onClick={() => onEdit(activity.id)} className="bg-[var(--elevated)] hover:bg-[color:oklch(from_var(--text)_0.82_0_0)] px-3 py-1.5 rounded text-sm">Edit</button>}
          {!activity.completedAt && <button onClick={() => onDelete(activity.id)} className="bg-[var(--danger)] hover:opacity-90 px-3 py-1.5 rounded text-sm">Delete</button>}
        </div>
      );

      return (
        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex justify-end z-40" aria-modal="true" role="dialog">
          <div className="w-full max-w-md bg-[var(--surface)] border-l border-[var(--border)] h-full overflow-y-auto">
            <div className="flex items-center justify-between px-6 py-4 border-b border-[var(--border)]">
              <div>
                <h2 className="text-lg font-semibold text-[var(--text-strong)]">{activity.title}</h2>
                <div className="text-xs text-[var(--text-muted)] mt-1">Stage status: {stageStateLabel}</div>
              </div>
              <button onClick={onClose} className="p-2 rounded hover:bg-[var(--elevated)]"><XIcon className="w-4 h-4" /></button>
            </div>

            <div className="px-6 py-4 space-y-6">
              <div className="bg-[var(--elevated)]/50 border border-[var(--border)] rounded-lg p-4 space-y-3">
                <div className="flex items-start justify-between">
                  <div className="space-y-2 text-sm text-[var(--text)]">
                    {assignedTeams.length > 0 ? (
                      <div className="flex flex-wrap gap-1 text-xs text-[var(--text)]">
                        <span className="text-[var(--text-muted)] mr-1">Teams:</span>
                        {assignedTeams.map(team => (
                          <span key={team.id} className="inline-flex items-center gap-1 bg-[var(--elevated)]/60 px-2 py-0.5 rounded">
                            <span
                              className="w-2 h-2 rounded-full"
                              style={{ backgroundColor: TEAM_COLOR_MAP[team.color] || 'var(--accent)' }}
                            ></span>
                            {team.name}
                          </span>
                        ))}
                      </div>
                    ) : (
                      <div className="text-xs text-[var(--warn)]">No teams assigned to current stage</div>
                    )}
                    {stage && <div><span className="text-[var(--text-muted)]">Stage:</span> {stage.name}</div>}
                    {stage?.conditions && <div className="text-xs text-[var(--info)] bg-[var(--info)]/20 border border-[var(--info)]/30 rounded px-2 py-1">Conditions: {stage.conditions}</div>}
                    {activity.skippedStages?.length > 0 && (
                      <div className="text-xs text-[var(--warn)]">Skipped: {activity.skippedStages.map(id => stageMap?.[id]?.name || id).join(', ')}</div>
                    )}
                    {claimedBy && <div><span className="text-[var(--text-muted)]">Claimed by:</span> {claimedBy}{priority && <span className="text-xs bg-[var(--info)]/60 text-[var(--info)] px-2 py-0.5 ml-2 rounded">{priority}</span>}</div>}
                    {nextStage ? (
                      <div className="text-xs text-[var(--text-muted)]">Next stage: {nextStage.name}</div>
                    ) : (
                      <div className="text-xs text-[var(--text-muted)]">Final stage</div>
                    )}
                    {activity.deliverable && <div><span className="text-gray-400">Deliverable:</span> {activity.deliverable}</div>}
                    <div className="text-xs text-gray-500">Created {formatTimestamp(activity.createdAt)}</div>
                    {expectedWindowLabel && (
                      <div className="text-xs text-gray-300">
                        <span className="text-gray-400">Expected window:</span> {expectedWindowLabel}
                        {expectedEnd && (
                          <> Â· <span className="text-gray-500">{new Date(expectedEnd).toLocaleDateString()}</span></>
                        )}
                      </div>
                    )}
                    {activity.timelineMode === 'specific' && activity.targetDate && (
                      <div className="text-xs text-blue-300">
                        <span className="text-gray-400">Target date:</span> {new Date(activity.targetDate).toLocaleDateString()}
                      </div>
                    )}
                    {driftLabel && (
                      <div className={`text-[11px] ${driftLabel.includes('+') ? 'text-yellow-300' : 'text-gray-400'}`}>
                        {driftLabel}
                      </div>
                    )}
                  </div>
                </div>
                {stageStates.length > 0 && (
                  <div className="text-xs text-[var(--text)]">
                    <div className="text-[var(--text-muted)] mb-2">Stage overview</div>
                    <ul className="space-y-1">
                      {stageStates.map(({ stage: stageInfo, state, entry }) => (
                        <li key={getStageIdentity(stageInfo)} className="flex items-center justify-between bg-[var(--surface)]/40 px-2 py-1 rounded">
                          <span>{stageInfo.name}</span>
                          <span className="text-[var(--text-muted)] text-[11px]">{state.replace('_', ' ')}{entry?.claimedBy ? ` Â· ${entry.claimedBy}` : ''}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                {dependencies.length > 0 && (
                  <div className="text-sm text-[var(--text)]">
                    <div className="text-[var(--text-muted)] mb-2">Waiting on</div>
                    <ul className="space-y-2 ml-2">
                      {dependencies.map((dep, idx) => {
                        const sourceName = dep.requiredStageName || 'Source stage';
                        const targetName = dep.blockingStageName || 'Target stage';
                        const activityTitle = dep.activity ? dep.activity.title : 'Missing activity';
                        const isCleared = dep.satisfied;
                        const statusLabel = isCleared ? 'Cleared' : 'Blocking';
                        const statusClass = isCleared ? 'text-[var(--ok)]' : 'text-[var(--warn)]';
                        return (
                          <li key={idx} className="flex items-start gap-2">
                            <ChevronRightIcon className="w-3 h-3 text-[var(--text-muted)] mt-1" />
                            <div className="flex-1 space-y-1">
                              <div className="flex flex-wrap items-center gap-2 text-[11px] text-[var(--text)]">
                                <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-[var(--elevated)]/80">{sourceName}</span>
                                <span className="text-[var(--text-muted)]">â†’</span>
                                <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-[var(--elevated)]/60 text-[var(--text)]">{targetName}</span>
                                <span className={statusClass}>{statusLabel}</span>
                                {dep.edgeType === 'loops' && <span className="text-xs text-[var(--warn)]">(revision)</span>}
                                {(dep.needsMigration || dep.stageInferred) && <span className="text-xs text-[var(--warn)]">Stage mapping inferred â€” confirm wiring</span>}
                              </div>
                              <div className={`${isCleared ? 'text-[var(--text-muted)] line-through' : 'text-[var(--text)]'} text-sm`}>
                                {activityTitle}
                                {dep.missingSource && <span className="ml-2 text-xs text-[var(--danger)]">Source missing</span>}
                              </div>
                            </div>
                          </li>
                        );
                      })}
                    </ul>
                  </div>
                )}
                {actionButtons}
              </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-semibold text-[var(--text-strong)]">Attachments</h3>
                </div>
                <div className="space-y-2">
                  {(activity.attachments || []).length === 0 ? (
                    <div className="text-xs text-[var(--text-muted)]">No attachments yet.</div>
                  ) : (
                    (activity.attachments || []).map(att => (
                      <div key={att.id} className="flex items-center justify-between bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text)]">
                        <div className="flex flex-col">
                          <span>{att.name}</span>
                          {att.url && <a href={att.url} target="_blank" rel="noopener noreferrer" className="text-xs text-[var(--info)] hover:text-[var(--info)]">{att.url}</a>}
                          <span className="text-xs text-[var(--text-muted)]">Added {att.addedBy || 'someone'} Â· {formatRelativeTime(att.addedAt)}</span>
                        </div>
                        <button onClick={() => onRemoveAttachment(att.id)} className="text-xs text-[var(--text-muted)] hover:text-[var(--text)]">Remove</button>
                      </div>
                    ))
                  )}
                  <div className="bg-[var(--elevated)] border border-[var(--border)] rounded-lg p-3 space-y-2">
                    <input type="text" value={attachmentName} onChange={(e) => setAttachmentName(e.target.value)} placeholder="File name" className="w-full bg-[var(--surface)] border border-[var(--border)] rounded px-3 py-2 text-sm" />
                    <input type="text" value={attachmentUrl} onChange={(e) => setAttachmentUrl(e.target.value)} placeholder="Link (optional)" className="w-full bg-[var(--surface)] border border-[var(--border)] rounded px-3 py-2 text-sm" />
                    <button onClick={handleAddAttachment} disabled={!currentUser || !attachmentName.trim()} className="w-full bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] disabled:bg-[var(--elevated)] disabled:text-[var(--text-muted)] text-sm py-2 rounded">Add attachment</button>
                  </div>
                </div>
              </div>

              <div className="bg-gray-800/50 border border-gray-700 rounded-lg p-3 space-y-2">
                <div className="flex items-center justify-between">
                  <div className="text-xs text-gray-300">Timeline mode</div>
                  <select
                    className="bg-gray-900 border border-gray-700 rounded px-2 py-1 text-xs"
                    value={activity.timelineMode || 'by-stage'}
                    onChange={(e) => {
                      if (!onUpdate) return;
                      const value = e.target.value;
                      const updates = value === 'by-stage'
                        ? { timelineMode: value, targetDate: null }
                        : { timelineMode: value };
                      onUpdate(activity.id, updates);
                    }}
                    disabled={!!activity.completedAt || !onUpdate}
                  >
                    <option value="by-stage">Use stage rhythm</option>
                    <option value="specific">Use specific target date</option>
                  </select>
                </div>

                {activity.timelineMode === 'specific' && (
                  <div className="flex items-center gap-2">
                    <input
                      type="date"
                      className="bg-gray-900 border border-gray-700 rounded px-2 py-1 text-xs"
                      value={targetDateValue}
                      onChange={(e) => {
                        if (!onUpdate) return;
                        const inputValue = e.target.value;
                        let isoValue = null;
                        if (inputValue) {
                          const parsed = new Date(`${inputValue}T12:00:00Z`);
                          const time = parsed.getTime();
                          if (Number.isFinite(time)) {
                            isoValue = parsed.toISOString();
                          }
                        }
                        onUpdate(activity.id, { targetDate: isoValue });
                      }}
                      disabled={!!activity.completedAt || !onUpdate}
                    />
                    <div className="text-[11px] text-gray-500">Optional hard date</div>
                  </div>
                )}
              </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-semibold text-[var(--text-strong)]">Comments ({comments.length})</h3>
                </div>
                <div className="space-y-3">
                  {comments.length === 0 ? (
                    <div className="text-xs text-[var(--text-muted)]">No comments yet.</div>
                  ) : (
                    comments.map(comment => (
                      <div key={comment.id} className="bg-[var(--elevated)] border border-[var(--border)] rounded-lg p-3 text-sm text-[var(--text-strong)]">
                        <div className="flex items-center justify-between text-xs text-[var(--text-muted)] mb-2">
                          <span>{comment.author}{comment.system && ' Â· system'}</span>
                          <span>{formatRelativeTime(comment.createdAt)}</span>
                        </div>
                        <div className="leading-relaxed">{renderCommentContent(comment.content)}</div>
                        {renderTaggedUsers(comment.taggedUserIds)}
                      </div>
                    ))
                  )}
                  <div className="bg-[var(--elevated)] border border-[var(--border)] rounded-lg p-3 space-y-2">
                    <textarea value={commentText} onChange={(e) => setCommentText(e.target.value)} placeholder={currentUser ? 'Add a comment with @mentions' : 'Set your name in the dashboard to comment'} className="w-full bg-[var(--surface)] border border-[var(--border)] rounded px-3 py-2 text-sm" rows={3} disabled={!currentUser} />
                    <div className="flex justify-end">
                      <button onClick={handleAddComment} disabled={!currentUser || !commentText.trim()} className="bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] disabled:text-[var(--text-muted)] px-3 py-1.5 rounded text-sm">Comment</button>
                    </div>
                  </div>
                </div>
              </div>

              <div>
                <h3 className="text-sm font-semibold text-[var(--text-strong)] mb-3">History</h3>
                <div className="space-y-2 text-sm text-[var(--text)]">
                  {stageHistory.length > 0 && (
                    <div className="space-y-1">
                      <div className="text-xs uppercase tracking-wide text-[var(--text-muted)]">Stage history</div>
                      {stageHistory.map(entry => (
                        <div key={entry.id} className="bg-[var(--surface)]/40 border border-[var(--border)] rounded p-2 text-xs text-[var(--text)]">
                          <div className="flex items-center justify-between mb-1">
                            <span className="text-[var(--text-strong)]">{stageMap?.[entry.stageId]?.name || entry.stageId}</span>
                            <span className="text-[var(--text-muted)]">{entry.enteredAt ? formatRelativeTime(entry.enteredAt) : ''}</span>
                          </div>
                          {entry.claimedBy && <div>Claimed by {entry.claimedBy}{entry.priority && ` (${entry.priority})`}</div>}
                          {entry.completedAt && <div>Completed {formatRelativeTime(entry.completedAt)}</div>}
                          {entry.skippedAt && <div>Skipped {formatRelativeTime(entry.skippedAt)}</div>}
                          {(entry.log || []).length > 0 && (
                            <ul className="mt-1 space-y-0.5">
                              {entry.log.slice().reverse().map(logEntry => (
                                <li key={logEntry.id} className="text-[var(--text-muted)]">
                                  <div>{logEntry.text}</div>
                                  {renderTaggedUsers(logEntry.taggedUserIds, 'mt-1')}
                                </li>
                              ))}
                            </ul>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                  {history.length === 0 ? (
                    <div className="text-xs text-[var(--text-muted)]">No history yet.</div>
                  ) : (
                    history.map(entry => (
                      <div key={entry.id} className="flex items-start gap-2">
                        <div className="text-xs text-[var(--text-muted)] w-28 flex-shrink-0">{formatRelativeTime(entry.timestamp)}</div>
                        <div className="flex-1">
                          {entry.text}
                          {renderTaggedUsers(entry.taggedUserIds, 'mt-1')}
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function formatTimestamp(timestamp) {
      if (!timestamp) return '';
      const date = new Date(timestamp);
      return date.toLocaleString();
    }

    function formatRelativeTime(timestamp) {
      if (!timestamp) return '';
      const diff = Date.now() - timestamp;
      const minutes = Math.floor(diff / 60000);
      if (minutes < 1) return 'just now';
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    function extractMentions(content) {
      const regex = /@([\w-]+)/g;
      const mentions = new Set();
      let match;
      while ((match = regex.exec(content))) {
        mentions.add(match[1]);
      }
      return Array.from(mentions);
    }
    function RefreshIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>;
    }
    function EditIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>;
    }
    function TrashIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
    }
    function UsersIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" /></svg>;
    }
    function HomeIcon(props) {
      return <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" /></svg>;
    }

    function computeActivityState(activity, stage, allActivities, edges) {
      if (!activity || !stage) return 'waiting';
      const stageId = getStageIdentity(stage);
      const stageEntry = getLatestStageHistoryEntry(activity.stageHistory, stageId);

      if (stageEntry?.skippedAt) return 'skipped';
      if (stageEntry?.completedAt) return 'completed';
      if (stageEntry?.claimedBy) return 'in_progress';

      const inbound = edges.filter(edge => edge.dstId === activity.id && (!edge.dstStage || edge.dstStage === stageId));
      const dependenciesSatisfied = inbound.length === 0 || inbound.every(edge => {
        const src = allActivities.find(a => a.id === edge.srcId);
        if (!src) return false;
        if (src.completedAt) return true;
        const requiredStageId = edge.srcStage || getActivityDefaultStageId(src);
        const status = getStageStatusFromHistory(src, requiredStageId);
        if (status.completed || status.skipped) return true;
        if (!edge.srcStage) {
          const lastStage = Array.isArray(src.stageHistory) ? src.stageHistory[src.stageHistory.length - 1] : null;
          return !!lastStage?.completedAt || !!lastStage?.skippedAt;
        }
        return false;
      });

      const currentStageId = activity.currentStageId || activity.stageId || null;
      if (!dependenciesSatisfied) return 'waiting';
      if (currentStageId === stageId) {
        if (!stageEntry) return 'ready';
        if (!stageEntry.claimedBy && !stageEntry.completedAt && !stageEntry.skippedAt) {
          return 'ready';
        }
      }

      return 'waiting';
    }

    function getStagePulseKey(stage) {
      if (!stage) return null;
      return stage.operatorKey || stage.key || getStageIdentity(stage);
    }

    function computeFlowPulse(flow) {
      if (!flow) return [];
      const orderedStages = getOrderedStages(flow);
      const firstStage = getFirstActiveStage(orderedStages);
      const fallbackStageId = firstStage ? getStageIdentity(firstStage) : null;
      const stageById = {};
      const stageKeyById = {};

      orderedStages.forEach(stage => {
        const identity = getStageIdentity(stage);
        stageById[identity] = stage;
        stageKeyById[identity] = getStagePulseKey(stage);
      });

      const stageTotals = {};
      const activities = Array.isArray(flow.activities) ? flow.activities : [];
      const edges = Array.isArray(flow.edges) ? flow.edges : [];

      activities.forEach(activity => {
        const stageIdSeed = activity.currentStageId || activity.stageId || fallbackStageId;
        const timestamp = activity.createdAt || Date.now();
        const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, timestamp);
        const normalizedStageId = currentStageId || fallbackStageId;
        if (!normalizedStageId) return;

        const stage = stageById[normalizedStageId] || firstStage;
        if (!stage) return;

        const stageKey = stageKeyById[getStageIdentity(stage)] || getStagePulseKey(stage);
        if (!stageKey) return;

        const activityForState = {
          ...activity,
          currentStageId: normalizedStageId,
          stageHistory
        };

        let state = computeActivityState(activityForState, stage, activities, edges);
        const stageEntry = getLatestStageHistoryEntry(stageHistory, getStageIdentity(stage));

        const inboundEdges = edges.filter(edge => edge.dstId === activity.id && (!edge.dstStage || edge.dstStage === normalizedStageId));
        const dependenciesSatisfied = inboundEdges.length === 0 || inboundEdges.every(edge => {
          const src = activities.find(a => a.id === edge.srcId);
          if (!src) return false;
          if (src.completedAt) return true;
          const requiredStageId = edge.srcStage || getActivityDefaultStageId(src, orderedStages);
          const status = getStageStatusFromHistory(src, requiredStageId);
          if (status.completed || status.skipped) return true;
          if (!edge.srcStage) {
            const lastStage = Array.isArray(src.stageHistory) ? src.stageHistory[src.stageHistory.length - 1] : null;
            return !!lastStage?.completedAt || !!lastStage?.skippedAt;
          }
          return false;
        });

        if (activity.completedAt || stageEntry?.completedAt) {
          state = 'completed';
        } else if (stageEntry?.skippedAt) {
          state = 'waiting';
        } else if (stageEntry?.claimedBy && !stageEntry?.completedAt) {
          state = 'in_progress';
        } else if (!dependenciesSatisfied && inboundEdges.length > 0) {
          state = 'blocked';
        } else if (!stageEntry || (!stageEntry.claimedBy && !stageEntry.completedAt && !stageEntry.skippedAt)) {
          state = 'ready';
        } else {
          state = 'waiting';
        }

        if (!stageTotals[stageKey]) stageTotals[stageKey] = {};
        stageTotals[stageKey][state] = (stageTotals[stageKey][state] || 0) + 1;
      });

      const aggregated = [];
      Object.entries(stageTotals).forEach(([stage, states]) => {
        Object.entries(states).forEach(([state, count]) => {
          aggregated.push({ stage, state, count });
        });
      });

      return aggregated;
    }

    function buildPulseFlows(projects = []) {
      const flows = [];
      projects.forEach(project => {
        const projectFlows = Array.isArray(project?.flows) ? project.flows : [];
        projectFlows.forEach(flow => {
          flows.push({
            id: flow.id,
            name: flow.name,
            projectName: project.name,
            activities: computeFlowPulse(flow)
          });
        });
      });
      return flows;
    }

    function aggregatePulseActivities(flows = []) {
      const aggregatedMap = {};
      flows.forEach(flow => {
        (flow.activities || []).forEach(activity => {
          const key = `${activity.stage}::${activity.state}`;
          aggregatedMap[key] = (aggregatedMap[key] || 0) + activity.count;
        });
      });
      return Object.entries(aggregatedMap).map(([key, count]) => {
        const [stage, state] = key.split('::');
        return { stage, state, count };
      });
    }

    function ActivityPulse({ count, state }) {
      const dots = Math.min(count, 5);
      const stateColor = {
        ready: 'bg-[var(--ok)]',
        in_progress: 'bg-[var(--info)]',
        blocked: 'bg-[var(--danger)]',
        waiting: 'bg-[var(--warn)]',
        completed: 'bg-[var(--text-muted)]'
      }[state] || 'bg-[var(--text-muted)]';
      const shapeCue = state === 'blocked' ? 'â– ' : state === 'ready' ? 'â—' : 'â—‹';

      return (
        <div className="flex items-center gap-1" aria-label={`State ${state}, ${count} items`}>
          {Array.from({ length: dots }).map((_, index) => (
            <div
              key={index}
              className={`w-2 h-2 rounded-full ${stateColor} animate-pulse`}
              style={{ animationDelay: `${index * 200}ms` }}
            />
          ))}
          {dots === 0 && <div className={`w-2 h-2 rounded-full ${stateColor}`} aria-hidden />}
          <span className="sr-only">{state}</span>
          <div aria-hidden className="text-[10px] ml-1 leading-none">
            {shapeCue}
          </div>
        </div>
      );
    }

    function ThemeToggle() {
      const [isDark, setIsDark] = React.useState(() =>
        document.documentElement.classList.contains('dark')
      );

      React.useEffect(() => {
        const mq = window.matchMedia('(prefers-color-scheme: dark)');
        const onChange = (event) => {
          if (localStorage.getItem('theme')) return;
          document.documentElement.classList.toggle('dark', event.matches);
          document.documentElement.classList.remove('force-light', 'force-dark');
          document.documentElement.style.colorScheme = event.matches ? 'dark' : 'light';
          setIsDark(event.matches);
        };
        mq.addEventListener ? mq.addEventListener('change', onChange) : mq.addListener(onChange);
        return () => {
          mq.removeEventListener ? mq.removeEventListener('change', onChange) : mq.removeListener(onChange);
        };
      }, []);

      const toggle = () => {
        const root = document.documentElement;
        const next = !isDark;
        root.classList.toggle('dark', next);
        localStorage.setItem('theme', next ? 'dark' : 'light');
        root.classList.remove('force-light', 'force-dark');
        root.classList.add(next ? 'force-dark' : 'force-light');
        root.style.colorScheme = next ? 'dark' : 'light';
        setIsDark(next);
      };

      return (
        <button
          onClick={toggle}
          className="inline-flex items-center gap-2 px-3 py-1.5 rounded-2xl border border-[var(--border)] bg-[var(--surface)] text-[var(--text)] hover:shadow focus-visible:outline focus-visible:outline-2 focus-visible:outline-[var(--focus)] transition"
          role="switch"
          aria-checked={isDark}
          aria-label={isDark ? 'Switch to light mode' : 'Switch to dark mode'}
        >
          <span aria-hidden="true">{isDark ? 'ðŸŒ™' : 'â˜€ï¸'}</span>
          <span className="text-sm">{isDark ? 'Dark' : 'Light'}</span>
        </button>
      );
    }

    function StageCell({ stage, activities = [], onClick, tier }) {
      const totalActivities = activities.reduce((sum, activity) => sum + activity.count, 0);

      const getFlowState = () => {
        if (activities.some(activity => activity.state === 'blocked')) return 'blocked';
        if (activities.some(activity => activity.state === 'in_progress')) return 'flowing';
        if (activities.some(activity => activity.state === 'ready')) return 'ready';
        if (totalActivities === 0) return 'empty';
        return 'waiting';
      };

      const flowState = getFlowState();

      const getBorderColor = () => {
        switch (flowState) {
          case 'flowing':
            return 'border-[var(--info)]/60';
          case 'ready':
            return 'border-[var(--ok)]/60';
          case 'blocked':
            return 'border-[var(--danger)]/60';
          case 'waiting':
            return 'border-[var(--warn)]/60';
          default:
            return 'border-[var(--border)]';
        }
      };

      const handleClick = onClick || (() => {});

      return (
        <button
          type="button"
          onClick={handleClick}
          className={`bg-[var(--surface)] border-2 ${getBorderColor()} rounded-lg p-4 hover:bg-[var(--elevated)] transition-all hover:scale-105 text-left relative overflow-hidden group`}
        >
          <div
            className={`absolute inset-0 opacity-0 group-hover:opacity-20 transition-opacity ${
              flowState === 'flowing'
                ? 'bg-[var(--info)]'
                : flowState === 'ready'
                  ? 'bg-[var(--ok)]'
                  : flowState === 'blocked'
                    ? 'bg-[var(--danger)]'
                    : 'bg-[var(--text-muted)]'
            }`}
          />

          <div className="relative z-10">
            <div className="font-semibold text-[var(--text-strong)] mb-1">{stage.name}</div>
            <div className="text-xs text-[var(--text-muted)] mb-3">{stage.desc}</div>

            <div className="space-y-2">
              {activities.length > 0 ? (
                activities.map((activity, index) => (
                  <div key={index} className="flex items-center justify-between">
                    <ActivityPulse count={activity.count} state={activity.state} />
                    <span className="text-xs text-[var(--text-muted)]">{activity.count}</span>
                  </div>
                ))
              ) : (
                <div className="flex items-center justify-between">
                  <ActivityPulse count={0} state="empty" />
                  <span className="text-xs text-[var(--text-muted)]">0</span>
                </div>
              )}
            </div>

            <div className="mt-3 text-xs text-[var(--text-muted)]">Total: {totalActivities}</div>
          </div>
        </button>
      );
    }

    function TierBand({ tier, stages, aggregatedData, onStageClick }) {
      const meta = PULSE_TIER_META[tier] || { label: tier, subtitle: '', color: 'text-[var(--text-muted)]' };

      return (
        <div className="space-y-3">
          <div className={`text-xs font-bold tracking-widest ${meta.color} uppercase flex items-center gap-2`}>
            <span>{meta.label}</span>
            <div className="flex-1 h-px bg-[var(--border)]" />
            {meta.subtitle && <span className="text-[10px] text-[var(--text-muted)]">{meta.subtitle}</span>}
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
            {stages.map(stage => {
              const stageActivities = (aggregatedData || []).filter(activity => activity.stage === stage.id);
              return (
                <StageCell
                  key={stage.id}
                  stage={stage}
                  activities={stageActivities}
                  onClick={onStageClick ? () => onStageClick(stage) : undefined}
                  tier={tier}
                />
              );
            })}
          </div>
        </div>
      );
    }

    function PulseOverview({
      projects,
      className = '',
      title = 'The Pulse',
      subtitle = 'System metabolism across your flows',
      actions = null
    }) {
      const pulseData = useMemo(() => {
        const flows = buildPulseFlows(projects);
        const aggregated = aggregatePulseActivities(flows);
        return { flows, aggregated };
      }, [projects]);

      const totals = useMemo(() => {
        const totalReady = pulseData.aggregated.filter(item => item.state === 'ready').reduce((sum, item) => sum + item.count, 0);
        const totalInProgress = pulseData.aggregated
          .filter(item => item.state === 'in_progress')
          .reduce((sum, item) => sum + item.count, 0);
        const totalBlocked = pulseData.aggregated
          .filter(item => item.state === 'blocked')
          .reduce((sum, item) => sum + item.count, 0);
        return { totalReady, totalInProgress, totalBlocked };
      }, [pulseData]);

      const flowSummaries = useMemo(() => {
        return pulseData.flows.map(flow => {
          const summary = flow.activities.reduce(
            (acc, activity) => {
              acc.total += activity.count;
              if (activity.state === 'ready') acc.ready += activity.count;
              if (activity.state === 'in_progress') acc.inProgress += activity.count;
              if (activity.state === 'blocked') acc.blocked += activity.count;
              if (activity.state === 'waiting') acc.waiting += activity.count;
              if (activity.state === 'completed') acc.completed += activity.count;
              return acc;
            },
            { total: 0, ready: 0, inProgress: 0, blocked: 0, waiting: 0, completed: 0 }
          );

          const hasBlocked = summary.blocked > 0;
          const hasInProgress = summary.inProgress > 0;
          const healthStatus = hasBlocked ? 'âŠ— Blocked' : hasInProgress ? 'âœ“ Flowing' : 'â—‹ Dormant';
          const healthColor = hasBlocked
            ? 'text-[var(--danger)]'
            : hasInProgress
              ? 'text-[var(--ok)]'
              : 'text-[var(--text-muted)]';

          return {
            ...flow,
            summary,
            healthStatus,
            healthColor
          };
        });
      }, [pulseData.flows]);

      return (
        <div className={`bg-[var(--surface)] border border-[var(--border)] rounded-2xl p-6 space-y-8 ${className}`}>
          <div className="flex flex-col gap-4 md:flex-row md:items-start md:justify-between">
            <div className="flex-1">
              <h2 className="text-lg font-semibold text-[var(--text-strong)]">{title}</h2>
              <p className="text-sm text-[var(--text-muted)]">{subtitle}</p>
            </div>
            <div className="flex flex-col gap-3 items-stretch md:items-end">
              <div className="flex items-center gap-2 justify-end">
                {actions && <div className="flex justify-end">{actions}</div>}
                <ThemeToggle />
              </div>
              <div className="flex gap-4 text-[var(--text)]">
                <div className="text-right">
                  <div className="text-2xl font-bold text-[var(--ok)]">{totals.totalReady}</div>
                  <div className="text-xs text-[var(--text-muted)]">Ready</div>
                </div>
                <div className="text-right">
                  <div className="text-2xl font-bold text-[var(--info)]">{totals.totalInProgress}</div>
                  <div className="text-xs text-[var(--text-muted)]">In Progress</div>
                </div>
                <div className="text-right">
                  <div className="text-2xl font-bold text-[var(--danger)]">{totals.totalBlocked}</div>
                  <div className="text-xs text-[var(--text-muted)]">Blocked</div>
                </div>
              </div>
            </div>
          </div>

          <div className="space-y-8">
            <TierBand
              tier="genesis"
              stages={PULSE_STAGE_GROUPS.genesis}
              aggregatedData={pulseData.aggregated}
            />
            <TierBand
              tier="evaluation"
              stages={PULSE_STAGE_GROUPS.evaluation}
              aggregatedData={pulseData.aggregated}
            />
            <TierBand
              tier="continuity"
              stages={PULSE_STAGE_GROUPS.continuity}
              aggregatedData={pulseData.aggregated}
            />
          </div>

          <div>
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-sm font-semibold text-[var(--text)] uppercase tracking-wide">Active Flows</h3>
              <span className="text-xs text-[var(--text-muted)]">{flowSummaries.length}</span>
            </div>
            {flowSummaries.length === 0 ? (
              <div className="text-sm text-[var(--text-muted)] bg-[var(--elevated)] border border-dashed border-[var(--border)] rounded-lg p-4">
                Create a flow to see the system pulse come alive.
              </div>
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                {flowSummaries.slice(0, 6).map(flow => (
                  <div key={flow.id} className="bg-[var(--elevated)] border border-[var(--border)] rounded-lg p-4">
                    <div className="flex items-start justify-between mb-2">
                      <div>
                        <div className="text-xs text-[var(--text-muted)]">{flow.projectName}</div>
                        <h4 className="font-medium text-[var(--text-strong)]">{flow.name}</h4>
                      </div>
                      <span className={`text-xs ${flow.healthColor}`}>{flow.healthStatus}</span>
                    </div>
                    <div className="text-xs text-[var(--text-muted)]">{flow.summary.total} active</div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      );
    }

    function EventOperator() {
      const [view, setView] = useState('welcome');
      const [currentUser, setCurrentUser] = useState('');
      const [projects, setProjects] = useState([]);
      const [roles, setRoles] = useState([]);
      const [selectedProject, setSelectedProject] = useState(null);
      const [selectedFlow, setSelectedFlow] = useState(null);
      const [showModal, setShowModal] = useState(null);
      const [modalData, setModalData] = useState({});

      useEffect(() => {
        if (selectedProject && projects.length > 0) {
          const updated = projects.find(p => p.id === selectedProject.id);
          if (updated) setSelectedProject(updated);
        }
      }, [projects]);

      useEffect(() => {
        if (selectedFlow && selectedProject) {
          const updated = selectedProject.flows.find(f => f.id === selectedFlow.id);
          if (updated) setSelectedFlow(updated);
        }
      }, [selectedProject]);

      const selectedProjectTeams = useMemo(() => {
        if (!selectedProject) return [];
        return Array.isArray(selectedProject.teams) ? selectedProject.teams : [];
      }, [selectedProject]);

      const migrateRolesToTeams = () => {
        setProjects(prev => prev.map(project => {
          if (project.teams && project.teams.length > 0) return project;

          const roleMap = new Map();

          (project.flows || []).forEach(flow => {
            (flow.activities || []).forEach(activity => {
              if (activity && activity.roleId) {
                const availableRoles = Array.isArray(project.roles) ? project.roles : roles;
                const role = Array.isArray(availableRoles)
                  ? availableRoles.find(r => r && r.id === activity.roleId)
                  : null;
                if (role && !roleMap.has(role.id)) {
                  roleMap.set(role.id, role);
                }
              }
            });
          });

          if (roleMap.size === 0) {
            return { ...project, teams: Array.isArray(project.teams) ? project.teams : [] };
          }

          const teams = Array.from(roleMap.values()).map(role => ({
            id: role.id ? role.id.replace('role-', 'team-') : `team-${Math.random().toString(36).slice(2, 7)}`,
            name: role.name || 'Team',
            userIds: Array.isArray(role.userIds) ? role.userIds : [],
            color: ['blue', 'green', 'purple', 'orange'][Math.floor(Math.random() * 4)]
          }));

          return { ...project, teams };
        }));

        setRoles([]);
      };

      useEffect(() => {
        migrateRolesToTeams();
      }, []);

      useEffect(() => {
        setProjects(prev => {
          let mutated = false;
          const nextProjects = prev.map(project => {
            let projectChanged = false;
            const teams = Array.isArray(project.teams) ? project.teams : [];
            const nextFlows = project.flows.map(flow => {
              const stageConfig = getFlowStageConfig(flow);
              const needsStageConfig = !Array.isArray(flow.stageConfig);
              if (!Array.isArray(flow.edges) || flow.edges.length === 0) {
                if (needsStageConfig) {
                  projectChanged = true;
                  return { ...flow, stageConfig };
                }
                return flow;
              }
              const orderedStages = getOrderedStages({ ...flow, stageConfig });
              const firstStage = getFirstActiveStage(orderedStages);
              const fallbackStageId = firstStage ? getStageIdentity(firstStage) : null;
              let flowChanged = needsStageConfig;
              const nextEdges = flow.edges.map(edge => {
                if (edge.srcStage && edge.dstStage && edge.stageInferred !== undefined) return edge;
                const srcActivity = flow.activities.find(a => a.id === edge.srcId);
                const dstActivity = flow.activities.find(a => a.id === edge.dstId);
                const srcStage = edge.srcStage || getActivityDefaultStageId(srcActivity, orderedStages) || fallbackStageId;
                const dstStage = edge.dstStage || getActivityDefaultStageId(dstActivity, orderedStages) || fallbackStageId;
                if (edge.srcStage === srcStage && edge.dstStage === dstStage && edge.stageInferred !== undefined) {
                  return edge;
                }
                flowChanged = true;
                return {
                  ...edge,
                  srcStage,
                  dstStage,
                  stageInferred: edge.stageInferred !== false
                };
              });
              if (!flowChanged) return flow;
              projectChanged = true;
              return { ...flow, edges: nextEdges, stageConfig };
            });
            if (teams !== project.teams) {
              projectChanged = true;
            }
            if (!projectChanged) return project;
            mutated = true;
            return { ...project, teams, flows: nextFlows };
          });
          return mutated ? nextProjects : prev;
        });
      }, []);

      const createProject = (name, users, currentUserName) => {
        const normalizedName = trimString(name);
        if (!normalizedName) return;

        const normalizedUsers = Array.isArray(users) ? users : [];
        const seen = new Set();
        const projectUsers = [];

        normalizedUsers.forEach(entry => {
          if (!entry) return;
          const nameValue = typeof entry === 'string' ? trimString(entry) : trimString(entry.name || '');
          if (!nameValue) return;
          const key = nameValue.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          const profile = createUserProfile({
            ...entry,
            id: null,
            name: nameValue,
            addedAt: null,
            lastModified: null
          });
          profile.metadata = entry?.metadata ? { ...entry.metadata } : {};
          projectUsers.push(profile);
        });

        const creatorName = trimString(currentUserName);
        if (creatorName && !seen.has(creatorName.toLowerCase())) {
          projectUsers.unshift(createUserProfile({ name: creatorName }));
        }

        const project = {
          id: `p-${Date.now()}`,
          name: normalizedName,
          users: projectUsers,
          teams: [],
          flows: []
        };
        setProjects([...projects, project]);
        setCurrentUser(creatorName || currentUserName);
        setView('dashboard');
      };

      const saveProjectUser = (projectId, userData) => {
        setProjects(prev => prev.map(project => {
          if (project.id !== projectId) return project;
          const now = new Date().toISOString();
          const existingUsers = Array.isArray(project.users) ? project.users : [];

          if (userData && userData.id) {
            const updatedUsers = existingUsers.map(user => {
              if (user.id !== userData.id) return user;
              return {
                ...user,
                name: trimString(userData.name || user.name),
                email: trimString(userData.email ?? user.email),
                phone: trimString(userData.phone ?? user.phone),
                relationship: trimString(userData.relationship ?? user.relationship),
                role: userData.role || user.role || 'viewer',
                matrixId: trimString(userData.matrixId ?? user.matrixId),
                avatar: userData.avatar !== undefined ? trimString(userData.avatar) : trimString(user.avatar),
                notes: trimString(userData.notes ?? user.notes),
                metadata: userData.metadata || user.metadata || {},
                lastModified: now
              };
            });
            return { ...project, users: updatedUsers };
          }

          const newUser = createUserProfile({
            ...userData,
            name: trimString(userData?.name || ''),
            email: trimString(userData?.email || ''),
            phone: trimString(userData?.phone || ''),
            relationship: trimString(userData?.relationship || ''),
            role: userData?.role || 'viewer',
            matrixId: trimString(userData?.matrixId || ''),
            avatar: trimString(userData?.avatar || ''),
            notes: trimString(userData?.notes || ''),
            metadata: userData?.metadata || {}
          });
          newUser.lastModified = now;
          const nextUsers = [...existingUsers, newUser];
          return { ...project, users: nextUsers };
        }));
      };

      const removeUserFromProject = (projectId, userId) => {
        setProjects(prev => prev.map(project => {
          if (project.id !== projectId) return project;
          const remainingUsers = (project.users || []).filter(user => user.id !== userId);
          const updatedTeams = (project.teams || []).map(team => ({
            ...team,
            userIds: (team.userIds || []).filter(id => id !== userId)
          }));
          const updatedFlows = project.flows.map(flow => ({
            ...flow,
            stageConfig: (flow.stageConfig || []).map(entry => ({
              ...entry,
              assignedUserIds: (entry.assignedUserIds || []).filter(id => id !== userId),
              optedOutUserIds: (entry.optedOutUserIds || []).filter(id => id !== userId)
            })),
            activities: flow.activities.map(activity => pruneActivityUserTags(activity, userId))
          }));
          return {
            ...project,
            users: remainingUsers,
            teams: updatedTeams,
            flows: updatedFlows
          };
        }));
      };

      const createFlow = (projectId, name, deliverables, description) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: [...p.flows, {
            id: `f-${Date.now()}`,
            name,
            deliverables,
            description,
            stageConfig: createDefaultStageConfig(),
            stages: createDefaultStages(),
            activities: [],
            edges: []
          }]
        } : p));
      };

      const createActivity = (projectId, flowId, title, deliverable = '', options = {}) => {
        const timestamp = Date.now();
        const activityId = options.id || `a-${timestamp}`;
        const explicitStageId = options.stageId || null;
        const timelineMode = options.timelineMode || 'by-stage';
        const targetDate = options.targetDate || null;
        const stageDurations = options.stageDurations || {};
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => {
            if (f.id !== flowId) return f;
            const orderedStages = getOrderedStages(f);
            const targetStage = explicitStageId
              ? orderedStages.find(stage => getStageIdentity(stage) === explicitStageId)
              : getFirstActiveStage(orderedStages) || null;
            const stageId = targetStage ? getStageIdentity(targetStage) : (explicitStageId || null);
            const entry = stageId ? createStageHistoryEntry(stageId, timestamp) : null;
            if (entry) {
              entry.log = [{ id: `log-${timestamp}`, text: `${actor} created this activity`, timestamp }];
            }
            return {
              ...f,
              activities: [...f.activities, {
                id: activityId,
                title,
                deliverable,
                currentStageId: stageId,
                skippedStages: [],
                stageHistory: entry ? [entry] : [],
                stageReadBy: stageId ? { [stageId]: {} } : {},
                createdAt: timestamp,
                completedAt: null,
                timelineMode,
                targetDate,
                stageDurations,
                comments: [],
                attachments: [],
                history: [{ id: `h-${timestamp}`, text: `${actor} created this activity`, timestamp }]
              }]
            };
          })
        } : p));
      };

      const updateActivity = (projectId, flowId, activityId, updates) => {
        const timestamp = Date.now();
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const baseTracking = ensureStageTracking(a, a.currentStageId || a.stageId, timestamp);
              let currentStageId = baseTracking.currentStageId;
              let stageHistory = baseTracking.stageHistory;
              const stageReadBy = { ...baseTracking.stageReadBy };
              const restUpdates = { ...(updates || {}) };
              if ('roleId' in restUpdates) delete restUpdates.roleId;
              if (restUpdates.stageId) currentStageId = restUpdates.stageId;
              if (restUpdates.currentStageId) currentStageId = restUpdates.currentStageId;

              if (currentStageId && !getLatestStageHistoryEntry(stageHistory, currentStageId)) {
                stageHistory = [...stageHistory, createStageHistoryEntry(currentStageId, timestamp)];
              }
              if (currentStageId && !stageReadBy[currentStageId]) {
                stageReadBy[currentStageId] = {};
              }

              const merged = {
                ...a,
                ...restUpdates,
                currentStageId,
                stageHistory,
                stageReadBy,
                stageId: currentStageId
              };
              if (!merged.skippedStages) merged.skippedStages = a.skippedStages || [];
              return merged;
            })
          } : f)
        } : p));
      };

      const deleteActivity = (projectId, flowId, activityId) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.filter(a => a.id !== activityId),
            edges: f.edges.filter(e => e.srcId !== activityId && e.dstId !== activityId)
          } : f)
        } : p));
      };

      const createEdge = (projectId, flowId, srcId, dstId, type, options = {}) => {
        const { srcStage: providedSrcStage, dstStage: providedDstStage } = options;
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            edges: [...f.edges, (() => {
              const timestamp = Date.now();
              const orderedStages = getOrderedStages(f);
              const srcActivity = f.activities.find(a => a.id === srcId);
              const dstActivity = f.activities.find(a => a.id === dstId);
              const firstStage = getFirstActiveStage(orderedStages);
              const fallbackStageId = firstStage ? getStageIdentity(firstStage) : null;
              const inferredSrcStage = providedSrcStage || getActivityDefaultStageId(srcActivity, orderedStages) || fallbackStageId;
              const inferredDstStage = providedDstStage || getActivityDefaultStageId(dstActivity, orderedStages) || fallbackStageId;
              const stageInferred = !providedSrcStage || !providedDstStage;
              return {
                id: `e-${timestamp}`,
                type,
                srcId,
                dstId,
                srcStage: inferredSrcStage,
                dstStage: inferredDstStage,
                stageInferred
              };
            })()]
          } : f)
        } : p));
      };

      const createTeam = (name, userIds = []) => {
        if (!selectedProject) return null;

        const timestamp = Date.now();
        const newTeam = {
          id: `team-${timestamp}`,
          name,
          userIds: Array.from(new Set((userIds || []).filter(Boolean))),
          color: ['blue', 'green', 'purple', 'orange'][Math.floor(Math.random() * 4)]
        };

        setProjects(prev => prev.map(project => project.id === selectedProject.id ? {
          ...project,
          teams: [...(project.teams || []), newTeam]
        } : project));

        return newTeam;
      };

      const updateTeam = (teamId, updates) => {
        if (!selectedProject) return;

        setProjects(prev => prev.map(project => project.id === selectedProject.id ? {
          ...project,
          teams: (project.teams || []).map(team =>
            team.id === teamId
              ? {
                  ...team,
                  ...updates,
                  userIds: Array.from(new Set((updates.userIds || team.userIds || []).filter(Boolean)))
                }
              : team
          )
        } : project));
      };

      const deleteTeam = (teamId) => {
        setProjects(prev => prev.map(project => ({
          ...project,
          teams: (project.teams || []).filter(team => team.id !== teamId),
          flows: project.flows.map(flow => ({
            ...flow,
            stageConfig: (flow.stageConfig || []).map(config => ({
              ...config,
              assignedTeamIds: (config.assignedTeamIds || []).filter(id => id !== teamId)
            }))
          }))
        })));
      };

      const getStageTeams = (flow, stageId) => {
        if (!flow || !stageId) return [];

        const project = projects.find(p => p.flows.some(f => f.id === flow.id));
        if (!project) return [];

        return resolveStageTeams(project, flow, stageId);
      };

      const canUserWorkOnStage = (flow, stageId, userName) => {
        if (!flow || !stageId || !userName) return false;

        const project = projects.find(p => p.flows.some(f => f.id === flow.id));
        if (!project) return false;

        const teams = getStageTeams(flow, stageId);
        const hasTeamAccess = teams.some(team =>
          (team.userIds || []).some(userId => {
            const user = project.users.find(u => u.id === userId);
            return user?.name === userName;
          })
        );

        if (hasTeamAccess) return true;

        const orderedStages = getOrderedStages(flow);
        const stage = orderedStages.find(stageItem => {
          const identity = getStageIdentity(stageItem);
          return identity === stageId || stageItem.operatorKey === stageId || stageItem.key === stageId;
        });
        const stageKey = stage ? (stage.operatorKey || stage.key || getStageIdentity(stage)) : stageId;
        const config = getFlowStageConfig(flow).find(sc => sc.stageKey === stageKey);
        const hasDirectAccess = (config?.assignedUserIds || []).some(userId => {
          const user = project.users.find(u => u.id === userId);
          return user?.name === userName;
        });

        return hasDirectAccess;
      };

      const claimActivity = (projectId, flowId, activityId, priority) => {
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const stageIdSeed = a.currentStageId || a.stageId;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageIdSeed, timestamp);
              if (!currentStageId) return a;
              const stageMeta = orderedStages.find(stage => getStageIdentity(stage) === currentStageId);
              const latestEntry = getLatestStageHistoryEntry(stageHistory, currentStageId);
              if (latestEntry?.claimedBy && latestEntry.claimedBy !== currentUser) {
                return a;
              }
              const updatedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                ...entry,
                claimedBy: currentUser,
                claimedAt: timestamp,
                priority: priority || null,
                log: [...(entry.log || []), { id: `log-${timestamp}`, text: `${actor} claimed${priority ? ` (${priority})` : ''}`, timestamp }]
              }), { createIfMissing: true, timestamp });
              const updatedStageReadBy = {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [actor]: timestamp }
              };
              const stageName = stageMeta?.name || 'stage';
              const comments = [
                ...(a.comments || []),
                {
                  id: `c-${timestamp}`,
                  author: actor,
                  content: `${actor} claimed ${stageName}${priority ? ` (priority: ${priority})` : ''}`,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                }
              ];
              return {
                ...a,
                currentStageId,
                stageHistory: updatedHistory,
                stageReadBy: updatedStageReadBy,
                comments,
                history: [...(a.history || []), { id: `h-${timestamp}`, text: `${actor} claimed ${stageName}${priority ? ` (priority: ${priority})` : ''}`, timestamp }]
              };
            })
          } : f)
        } : p));
      };

      const unclaimActivity = (projectId, flowId, activityId) => {
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const stageIdSeed = a.currentStageId || a.stageId;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageIdSeed, timestamp);
              if (!currentStageId) return a;
              const stageMeta = orderedStages.find(stage => getStageIdentity(stage) === currentStageId);
              const updatedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                ...entry,
                claimedBy: null,
                priority: null,
                log: [...(entry.log || []), { id: `log-${timestamp}`, text: `${actor} unclaimed`, timestamp }]
              }), { createIfMissing: true, timestamp });
              const updatedStageReadBy = {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [actor]: timestamp }
              };
              const stageName = stageMeta?.name || 'stage';
              return {
                ...a,
                currentStageId,
                stageHistory: updatedHistory,
                stageReadBy: updatedStageReadBy,
                comments: [...(a.comments || []), {
                  id: `c-${timestamp}`,
                  author: actor,
                  content: `${actor} unclaimed ${stageName}`,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                }],
                history: [...(a.history || []), { id: `h-${timestamp}`, text: `${actor} unclaimed ${stageName}`, timestamp }]
              };
            })
          } : f)
        } : p));
      };

      const completeActivity = (projectId, flowId, activityId, options = {}) => {
        const { skipStage: skipStageFlag = false, note = null, taggedUserIds: taggedUserIdsOption = [] } = options || {};
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const orderedStages = getOrderedStages(f);
              const stageIdSeed = a.currentStageId || a.stageId;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageIdSeed, timestamp);
              if (!currentStageId) return a;
              const stageMeta = orderedStages.find(stage => getStageIdentity(stage) === currentStageId);
              const stageName = stageMeta?.name || 'stage';
              const message = skipStageFlag ? `${actor} skipped ${stageName}` : `${actor} completed ${stageName}`;
              const trimmedNote = note ? note.trim() : '';
              const sanitizedTaggedUserIds = sanitizeTaggedUserIds(taggedUserIdsOption, p);
              const taggedNames = formatTaggedUserNames(sanitizedTaggedUserIds, p);
              const noteLogEntry = (trimmedNote || sanitizedTaggedUserIds.length > 0)
                ? {
                    id: `log-${timestamp}-note`,
                    text: trimmedNote
                      ? `Note: ${trimmedNote}${taggedNames.length > 0 ? ` (Tagged: ${taggedNames.join(', ')})` : ''}`
                      : `Tagged users: ${taggedNames.join(', ')}`,
                    note: trimmedNote || null,
                    taggedUserIds: sanitizedTaggedUserIds,
                    timestamp
                  }
                : null;
              const updatedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                ...entry,
                exitedAt: timestamp,
                completedAt: skipStageFlag ? entry.completedAt : timestamp,
                skippedAt: skipStageFlag ? timestamp : entry.skippedAt,
                log: [
                  ...(entry.log || []),
                  { id: `log-${timestamp}`, text: message, timestamp },
                  ...(noteLogEntry ? [noteLogEntry] : [])
                ]
              }), { createIfMissing: true, timestamp });
              const newSkippedStages = skipStageFlag ? Array.from(new Set([...(a.skippedStages || []), currentStageId])) : (a.skippedStages || []);
              const nextStageId = getNextStageId(orderedStages, currentStageId, newSkippedStages);
              const nextStageMeta = nextStageId ? orderedStages.find(stage => getStageIdentity(stage) === nextStageId) : null;
              let extendedHistory = [...updatedHistory];
              if (nextStageId) {
                const nextEntry = createStageHistoryEntry(nextStageId, timestamp);
                nextEntry.log = [{ id: `log-${timestamp}-enter`, text: `${actor} moved to ${nextStageMeta?.name || 'next stage'}`, timestamp }];
                extendedHistory.push(nextEntry);
              }
              const updatedStageReadBy = {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [actor]: timestamp }
              };
              if (nextStageId && !updatedStageReadBy[nextStageId]) {
                updatedStageReadBy[nextStageId] = {};
              }
              const historyEntries = [
                ...(a.history || []),
                { id: `h-${timestamp}`, text: message, timestamp }
              ];
              if (nextStageMeta) {
                historyEntries.push({ id: `h-${timestamp}-advance`, text: `${actor} advanced to ${nextStageMeta.name}`, timestamp });
              } else {
                historyEntries.push({ id: `h-${timestamp}-finish`, text: `${actor} completed the activity`, timestamp });
              }
              if (trimmedNote || sanitizedTaggedUserIds.length > 0) {
                const historyText = trimmedNote
                  ? `${actor} noted: ${trimmedNote}${taggedNames.length > 0 ? ` (Tagged: ${taggedNames.join(', ')})` : ''}`
                  : `${actor} tagged: ${taggedNames.join(', ')}`;
                historyEntries.push({
                  id: `h-${timestamp}-note`,
                  text: historyText,
                  timestamp,
                  taggedUserIds: sanitizedTaggedUserIds,
                  note: trimmedNote || null
                });
              }
              const comments = [
                ...(a.comments || []),
                {
                  id: `c-${timestamp}`,
                  author: actor,
                  content: message,
                  createdAt: timestamp,
                  mentions: [],
                  system: true
                },
                ...(() => {
                  if (!trimmedNote && sanitizedTaggedUserIds.length === 0) return [];
                  const taggedSummary = taggedNames.length > 0 ? ` (Tagged: ${taggedNames.join(', ')})` : '';
                  const content = trimmedNote
                    ? `Note on ${stageName}: ${trimmedNote}${taggedSummary}`
                    : `Tagged on ${stageName}: ${taggedNames.join(', ')}`;
                  return [{
                    id: `c-${timestamp}-note`,
                    author: actor,
                    content,
                    createdAt: timestamp,
                    mentions: [],
                    system: true,
                    taggedUserIds: sanitizedTaggedUserIds
                  }];
                })()
              ];
              return {
                ...a,
                currentStageId: nextStageId || currentStageId,
                skippedStages: newSkippedStages,
                stageHistory: extendedHistory,
                stageReadBy: updatedStageReadBy,
                comments,
                history: historyEntries,
                completedAt: nextStageId ? a.completedAt : timestamp
              };
            })
          } : f)
        } : p));
      };

      const addCommentToActivity = (projectId, flowId, activityId, author, content) => {
        const trimmed = content.trim();
        if (!trimmed) return;
        const timestamp = Date.now();
        const mentions = extractMentions(trimmed);
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, a.currentStageId || a.stageId, timestamp);
              const updatedStageReadBy = currentStageId ? {
                ...stageReadBy,
                [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [author]: timestamp }
              } : stageReadBy;
              return {
                ...a,
                currentStageId,
                stageHistory,
                stageReadBy: updatedStageReadBy,
                comments: [...(a.comments || []), { id: `c-${timestamp}`, author, content: trimmed, createdAt: timestamp, mentions, system: false }],
                history: [...(a.history || []), { id: `h-${timestamp}`, text: `${author} commented`, timestamp }]
              };
            })
          } : f)
        } : p));
      };

      const addAttachmentToActivity = (projectId, flowId, activityId, attachment) => {
        const timestamp = Date.now();
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => a.id === activityId ? {
              ...a,
              attachments: [...(a.attachments || []), { ...attachment, id: attachment.id || `att-${timestamp}`, addedAt: timestamp }],
              history: [...(a.history || []), { id: `h-${timestamp}`, text: `${attachment.addedBy} attached ${attachment.name}`, timestamp }]
            } : a)
          } : f)
        } : p));
      };

      const removeAttachmentFromActivity = (projectId, flowId, activityId, attachmentId) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => a.id === activityId ? {
              ...a,
              attachments: (a.attachments || []).filter(att => att.id !== attachmentId)
            } : a)
          } : f)
        } : p));
      };

      const markActivityRead = (projectId, flowId, activityId, userName) => {
        if (!userName) return;
        const timestamp = Date.now();
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: f.activities.map(a => {
              if (a.id !== activityId) return a;
              const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, a.currentStageId || a.stageId, timestamp);
              if (!currentStageId) return a;
              return {
                ...a,
                currentStageId,
                stageHistory,
                stageReadBy: {
                  ...stageReadBy,
                  [currentStageId]: { ...(stageReadBy[currentStageId] || {}), [userName]: timestamp }
                }
              };
            })
          } : f)
        } : p));
      };

      const spawnActivity = (projectId, flowId, sourceActivityId, title, deliverable = '', options = {}) => {
        const timestamp = Date.now();
        const newActivityId = `a-${timestamp}`;
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => f.id === flowId ? {
            ...f,
            activities: [...f.activities, (() => {
              const orderedStages = getOrderedStages(f);
              const explicitStageId = options.stageId || options.initialStageId || null;
              const initialStage = explicitStageId
                ? orderedStages.find(stage => getStageIdentity(stage) === explicitStageId)
                : getFirstActiveStage(orderedStages) || null;
              const stageId = initialStage ? getStageIdentity(initialStage) : (explicitStageId || null);
              const entry = stageId ? createStageHistoryEntry(stageId, timestamp) : null;
              if (entry) {
                entry.log = [{ id: `log-${timestamp}`, text: `${actor} spawned this from ${sourceActivityId}`, timestamp }];
              }
              return {
                id: newActivityId,
                title,
                deliverable,
                currentStageId: stageId,
                skippedStages: [],
                stageHistory: entry ? [entry] : [],
                stageReadBy: stageId ? { [stageId]: {} } : {},
                createdAt: timestamp,
                completedAt: null,
                comments: [],
                attachments: [],
                history: [{ id: `h-${timestamp}`, text: `${actor} spawned this from another activity`, timestamp }]
              };
            })()],
            edges: [...f.edges, (() => {
              const orderedStages = getOrderedStages(f);
              const srcActivity = f.activities.find(a => a.id === sourceActivityId);
              const explicitStageId = options.stageId || options.initialStageId || null;
              const initialStage = explicitStageId
                ? orderedStages.find(stage => getStageIdentity(stage) === explicitStageId)
                : getFirstActiveStage(orderedStages) || null;
              const stageId = initialStage ? getStageIdentity(initialStage) : (explicitStageId || null);
              const srcStageId = getActivityDefaultStageId(srcActivity, orderedStages);
              return {
                id: `e-${timestamp}`,
                type: 'enables',
                srcId: sourceActivityId,
                dstId: newActivityId,
                srcStage: srcStageId,
                dstStage: stageId,
                stageInferred: false
              };
            })()]
          } : f)
        } : p));
      };

      const requestRevision = (projectId, flowId, activityId, targetStageId, reason = '') => {
        if (!targetStageId) return;
        const timestamp = Date.now();
        const actor = currentUser || 'Someone';
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => {
            if (f.id !== flowId) return f;
            const orderedStages = getOrderedStages(f);
            const targetStage = orderedStages.find(stage => getStageIdentity(stage) === targetStageId) || null;
            const resolvedStageId = targetStage ? getStageIdentity(targetStage) : targetStageId;
            return {
              ...f,
              activities: f.activities.map(a => {
                if (a.id !== activityId) return a;
                const stageSeed = a.currentStageId || a.stageId || resolvedStageId;
                const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(a, stageSeed, timestamp);
                const activeStage = orderedStages.find(stage => getStageIdentity(stage) === currentStageId) || null;
                const activeStageName = activeStage?.name || currentStageId || 'current stage';
                const trimmedReason = reason ? reason.trim() : '';
                const exitedHistory = updateLatestStageHistoryEntry(stageHistory, currentStageId, (entry) => ({
                  ...entry,
                  exitedAt: timestamp,
                  log: [
                    ...(entry.log || []),
                    { id: `log-${timestamp}-revision`, text: `${actor} requested revision back to ${targetStage?.name || resolvedStageId}`, timestamp },
                    ...(trimmedReason ? [{ id: `log-${timestamp}-revision-reason`, text: `Reason: ${trimmedReason}`, timestamp }] : [])
                  ]
                }), { createIfMissing: true, timestamp });
                const revisionEntry = createStageHistoryEntry(resolvedStageId, timestamp);
                revisionEntry.log = [
                  { id: `log-${timestamp}-reopen`, text: `${actor} reopened stage${trimmedReason ? ` â€” ${trimmedReason}` : ''}`, timestamp }
                ];
                const filteredSkipped = (a.skippedStages || []).filter(id => id !== resolvedStageId);
                const updatedReadBy = {
                  ...stageReadBy,
                  [resolvedStageId]: { ...(stageReadBy[resolvedStageId] || {}), [actor]: timestamp }
                };
                const historyEntries = [
                  ...(a.history || []),
                  { id: `h-${timestamp}-revision`, text: `${actor} sent ${activeStageName} back to ${targetStage?.name || resolvedStageId}`, timestamp }
                ];
                if (trimmedReason) {
                  historyEntries.push({ id: `h-${timestamp}-revision-reason`, text: `Reason: ${trimmedReason}`, timestamp });
                }
                const comments = [
                  ...(a.comments || []),
                  {
                    id: `c-${timestamp}-revision`,
                    author: actor,
                    content: `${actor} requested revision to ${targetStage?.name || resolvedStageId}${trimmedReason ? ` â€” ${trimmedReason}` : ''}`,
                    createdAt: timestamp,
                    mentions: [],
                    system: true
                  }
                ];
                return {
                  ...a,
                  currentStageId: resolvedStageId,
                  stageHistory: [...exitedHistory, revisionEntry],
                  stageReadBy: updatedReadBy,
                  skippedStages: filteredSkipped,
                  isRevision: true,
                  comments,
                  history: historyEntries,
                  completedAt: null
                };
              })
            };
          })
        } : p));
      };

      const updateFlowStage = (projectId, flowId, stageId, updater) => {
        setProjects(prev => prev.map(p => p.id === projectId ? {
          ...p,
          flows: p.flows.map(f => {
            if (f.id !== flowId) return f;
            const existingStages = Array.isArray(f.stages) && f.stages.length > 0 ? f.stages : createDefaultStages();
            let targetStageKey = null;
            let updatedStageRef = null;
            const updatedStages = existingStages.map(stage => {
              const identity = getStageIdentity(stage);
              const matches = identity === stageId || stage.key === stageId || stage.operatorKey === stageId;
              if (!matches) return stage;
              const updatedStage = { ...stage, ...updater(stage) };
              targetStageKey = stage.operatorKey || stage.key || identity;
              updatedStageRef = updatedStage;
              return updatedStage;
            });
            const normalizedConfig = getFlowStageConfig(f);
            const nextStageConfig = targetStageKey
              ? normalizedConfig.map(entry => {
                  if (entry.stageKey !== targetStageKey) return entry;
                  const isActive = updatedStageRef ? !updatedStageRef.skipped : entry.active !== false;
                  return { ...entry, active: isActive };
                })
              : normalizedConfig;
            return { ...f, stages: updatedStages, stageConfig: nextStageConfig };
          })
        } : p));
      };

      const configureStageConditions = (projectId, flowId, stageId, conditions) => {
        updateFlowStage(projectId, flowId, stageId, () => ({ conditions }));
      };

      const toggleStageSkip = (projectId, flowId, stageId) => {
        updateFlowStage(projectId, flowId, stageId, (stage) => ({ skipped: !stage.skipped }));
      };

      const assignTeamsToStage = (projectId, flowId, stageId, { assignedTeamIds = [], assignedUserIds = [] }) => {
        setProjects(prev => prev.map(project => project.id === projectId ? {
          ...project,
          flows: project.flows.map(flow => {
            if (flow.id !== flowId) return flow;
            const orderedStages = getOrderedStages(flow);
            const targetStage = orderedStages.find(stage => {
              const identity = getStageIdentity(stage);
              return identity === stageId || stage.operatorKey === stageId || stage.key === stageId;
            });
            const stageKey = targetStage ? (targetStage.operatorKey || targetStage.key || getStageIdentity(targetStage)) : stageId;
            const normalized = getFlowStageConfig(flow);
            const updatedConfig = normalized.map(entry => entry.stageKey === stageKey ? {
              ...entry,
              assignedTeamIds: toUniqueIds(assignedTeamIds),
              assignedUserIds: toUniqueIds(assignedUserIds)
            } : entry);
            return { ...flow, stageConfig: updatedConfig };
          })
        } : project));
      };

      const advanceStage = (projectId, flowId, activityId, options = {}) => {
        completeActivity(projectId, flowId, activityId, options);
      };

      const skipStage = (projectId, flowId, activityId, noteOrOptions = null) => {
        if (noteOrOptions && typeof noteOrOptions === 'object' && !Array.isArray(noteOrOptions)) {
          const { note: skipNote = null, taggedUserIds = [] } = noteOrOptions;
          completeActivity(projectId, flowId, activityId, { skipStage: true, note: skipNote, taggedUserIds });
        } else {
          completeActivity(projectId, flowId, activityId, { skipStage: true, note: noteOrOptions });
        }
      };

      const advanceActivityStage = (projectId, flowId, activityId, { skip = false, note = null, taggedUserIds = [] } = {}) => {
        advanceStage(projectId, flowId, activityId, { skipStage: skip, note, taggedUserIds });
      };

      const skipActivityStage = (projectId, flowId, activityId, noteOrOptions = null) => {
        skipStage(projectId, flowId, activityId, noteOrOptions);
      };

      let mainContent;

      if (view === 'welcome') {
        mainContent = <WelcomeView onCreate={createProject} projects={projects} />;
      } else if (view === 'dashboard') {
        mainContent = <DashboardView projects={projects} currentUser={currentUser} roles={selectedProjectTeams} onSelectFlow={(p, f) => { setSelectedProject(p); setSelectedFlow(f); setView('activities'); }} onCreateProject={() => setShowModal('createProject')} onManageUsers={(p) => { setSelectedProject(p); setShowModal('manageUsers'); }} onManageTeams={(p) => { setSelectedProject(p); setShowModal('manageTeams'); }} onCreateFlow={(p) => { setSelectedProject(p); setShowModal('createFlow'); }} />;
      } else if (view === 'activities' && selectedProject && selectedFlow) {
        mainContent = (
          <ActivitiesView
            project={selectedProject}
            flow={selectedFlow}
            canUserWorkOnStage={canUserWorkOnStage}
            currentUser={currentUser}
            onBack={() => { setSelectedFlow(null); setSelectedProject(null); setView('dashboard'); }}
            onCreateActivity={(operatorId) => {
              setModalData(operatorId ? { operatorId } : {});
              setShowModal('createActivity');
            }}
            onEditActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('editActivity'); }}
            onDeleteActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('deleteActivity'); }}
            onClaimActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('claimActivity'); }}
            onUnclaimActivity={(aid) => unclaimActivity(selectedProject.id, selectedFlow.id, aid)}
            onCompleteActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('completeActivity'); }}
            onWireActivity={(aid) => { setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, activityId: aid }); setShowModal('wireActivity'); }}
            onRequestRevision={(activityId, targetStageId, reason) => requestRevision(selectedProject.id, selectedFlow.id, activityId, targetStageId, reason)}
            onAddComment={addCommentToActivity}
            onAddAttachment={addAttachmentToActivity}
            onRemoveAttachment={removeAttachmentFromActivity}
            onMarkRead={markActivityRead}
            onAdvanceActivityStage={(aid, options) => advanceActivityStage(selectedProject.id, selectedFlow.id, aid, options)}
            onSkipActivityStage={(aid) => skipActivityStage(selectedProject.id, selectedFlow.id, aid)}
            onConfigureStageConditions={(stageId, conditions) => configureStageConditions(selectedProject.id, selectedFlow.id, stageId, conditions)}
            onToggleStageSkip={(stageId) => toggleStageSkip(selectedProject.id, selectedFlow.id, stageId)}
            onAssignStageTeams={(stageId) => {
              setModalData({ projectId: selectedProject.id, flowId: selectedFlow.id, stageId });
              setShowModal('assignStageTeams');
            }}
            onUpdateActivity={(aid, updates) => updateActivity(selectedProject.id, selectedFlow.id, aid, updates)}
          />
        );
      }

      return (
        <>
          {mainContent}
          {showModal === 'createProject' && (
            <CreateProjectModal
              projects={projects}
              onClose={() => setShowModal(null)}
              onCreate={(name, users) => {
                createProject(name, users, currentUser);
                setShowModal(null);
              }}
            />
          )}
          {showModal === 'createFlow' && selectedProject && <CreateFlowModal onClose={() => setShowModal(null)} onCreate={(name, del, desc) => { createFlow(selectedProject.id, name, del, desc); setShowModal(null); }} />}
          {showModal === 'manageUsers' && selectedProject && (
            <ManageUsersModal
              project={selectedProject}
              onClose={() => setShowModal(null)}
              onSaveUser={(user) => saveProjectUser(selectedProject.id, user)}
              onRemoveUser={(uid) => removeUserFromProject(selectedProject.id, uid)}
            />
          )}
          {showModal === 'manageTeams' && selectedProject && (
            <ManageTeamsModal
              project={selectedProject}
              onClose={() => setShowModal(null)}
              onCreateTeam={(name, userIds) => {
                createTeam(name, userIds);
              }}
              onUpdateTeam={updateTeam}
              onDeleteTeam={deleteTeam}
            />
          )}
          {showModal === 'createActivity' && selectedProject && selectedFlow && <CreateActivityModal project={selectedProject} flow={selectedFlow} initialOperatorId={modalData.operatorId} onClose={() => { setShowModal(null); setModalData({}); }} onCreate={(title, deliverable, options = {}) => { createActivity(selectedProject.id, selectedFlow.id, title, deliverable, options); setShowModal(null); setModalData({}); }} />}
          {showModal === 'editActivity' && selectedFlow && <EditActivityModal project={selectedProject} activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} onClose={() => { setShowModal(null); setModalData({}); }} onUpdate={(updates) => { updateActivity(modalData.projectId, modalData.flowId, modalData.activityId, updates); setShowModal(null); setModalData({}); }} />}
          {showModal === 'deleteActivity' && selectedFlow && <DeleteActivityModal activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} onClose={() => { setShowModal(null); setModalData({}); }} onDelete={() => { deleteActivity(modalData.projectId, modalData.flowId, modalData.activityId); setShowModal(null); setModalData({}); }} />}
          {showModal === 'claimActivity' && selectedFlow && <ClaimActivityModal activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} project={selectedProject} onClose={() => { setShowModal(null); setModalData({}); }} onClaim={(priority) => { claimActivity(modalData.projectId, modalData.flowId, modalData.activityId, priority); setShowModal(null); setModalData({}); }} />}
          {showModal === 'completeActivity' && selectedFlow && (
            <CompleteActivityModal
              activity={selectedFlow.activities.find(a => a.id === modalData.activityId)}
              flow={selectedFlow}
              project={selectedProject}
              onClose={() => { setShowModal(null); setModalData({}); }}
              onComplete={(options) => {
                completeActivity(modalData.projectId, modalData.flowId, modalData.activityId, options);
                setShowModal(null);
                setModalData({});
              }}
            />
          )}
          {showModal === 'wireActivity' && selectedFlow && <WireActivityModal project={selectedProject} activity={selectedFlow.activities.find(a => a.id === modalData.activityId)} flow={selectedFlow} onClose={() => { setShowModal(null); setModalData({}); }} onWire={({ targetId, edgeType, srcStageId, dstStageId }) => { createEdge(modalData.projectId, modalData.flowId, modalData.activityId, targetId, edgeType, { srcStage: srcStageId, dstStage: dstStageId }); setShowModal(null); setModalData({}); }} onCreate={({ title, deliverable = '', edgeType, srcStageId, dstStageId, initialStageId }) => { const timestamp = Date.now(); const newId = `a-${timestamp}`; createActivity(modalData.projectId, modalData.flowId, title, deliverable, { id: newId, stageId: initialStageId }); setTimeout(() => createEdge(modalData.projectId, modalData.flowId, modalData.activityId, newId, edgeType, { srcStage: srcStageId, dstStage: dstStageId }), 50); setShowModal(null); setModalData({}); }} />}
          {showModal === 'assignStageTeams' && selectedProject && selectedFlow && (
            <AssignStageTeamsModal
              project={selectedProject}
              flow={selectedFlow}
              stageId={modalData.stageId}
              onClose={() => { setShowModal(null); setModalData({}); }}
              onUpdate={(stageId, updates) => assignTeamsToStage(selectedProject.id, selectedFlow.id, stageId, updates)}
            />
          )}
        </>
      );
    }

    function WelcomeView({ onCreate, projects = [] }) {
      const [projectName, setProjectName] = useState('');
      const [team, setTeam] = useState('');
      const [userName, setUserName] = useState('');
      const [selectedDirectoryUserKeys, setSelectedDirectoryUserKeys] = useState([]);

      const directory = useMemo(() => buildProjectDirectory(projects), [projects]);
      const manualMembers = useMemo(() => team.split(',').map(name => trimString(name)).filter(Boolean), [team]);
      const selectedDirectoryUsers = useMemo(
        () => selectedDirectoryUserKeys.map(key => directory.userMap.get(key)).filter(Boolean),
        [selectedDirectoryUserKeys, directory]
      );
      const combinedMembers = useMemo(() => {
        const names = new Set();
        selectedDirectoryUsers.forEach(user => {
          const name = trimString(user?.name || '');
          if (name) names.add(name);
        });
        manualMembers.forEach(name => {
          if (name) names.add(name);
        });
        const creatorName = trimString(userName);
        if (creatorName) names.add(creatorName);
        return Array.from(names);
      }, [selectedDirectoryUsers, manualMembers, userName]);

      const toggleDirectoryUserKey = (key) => {
        if (!key) return;
        setSelectedDirectoryUserKeys(prev => {
          const set = new Set(prev);
          if (set.has(key)) {
            set.delete(key);
          } else {
            set.add(key);
          }
          return Array.from(set);
        });
      };

      const handleAddRoleMembers = (role) => {
        if (!role) return;
        setSelectedDirectoryUserKeys(prev => {
          const set = new Set(prev);
          (role.memberKeys || []).forEach(key => {
            if (key) set.add(key);
          });
          return Array.from(set);
        });
      };

      const handleCreateProject = () => {
        const nameValue = trimString(projectName);
        const creatorName = trimString(userName);
        if (!nameValue || !creatorName) return;

        const payloadUsers = normalizeProjectUserPayload({
          selectedUsers: selectedDirectoryUsers,
          manualMembers,
          fallbackUsers: [{ name: creatorName }]
        });

        onCreate(nameValue, payloadUsers, creatorName);
        setProjectName('');
        setTeam('');
        setUserName('');
        setSelectedDirectoryUserKeys([]);
      };

      return (
        <div className="min-h-screen bg-[var(--bg)] text-[var(--text-strong)] flex items-center justify-center p-6">
          <div className="max-w-6xl w-full">
            <div className="text-center mb-12">
              <h1 className="text-4xl font-bold mb-4">EO</h1>
              <p className="text-[var(--text)] text-lg">Emergent Organizing</p>
            </div>

            <div className="grid gap-8 lg:grid-cols-[minmax(0,1fr)_minmax(0,1fr)] items-start">
              <div className="bg-[var(--surface)] rounded-lg border border-[var(--border)] p-8 shadow-lg">
                <h2 className="text-xl font-semibold mb-6">Create Your First Project</h2>
                <div className="space-y-4 mb-6">
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-2">Project name</label>
                    <input
                      type="text"
                      value={projectName}
                      onChange={(e) => setProjectName(e.target.value)}
                      placeholder="e.g., EO Launch"
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-2">Team members (comma separated)</label>
                    <input
                      type="text"
                      value={team}
                      onChange={(e) => setTeam(e.target.value)}
                      placeholder="e.g., Maya, Alex, Priya"
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
                    />
                    <p className="text-xs text-gray-500 mt-2">You can also select people or roles below to add them automatically.</p>
                  </div>
                  <DirectoryQuickAdd
                    directory={directory}
                    selectedKeys={selectedDirectoryUserKeys}
                    onToggleUserKey={toggleDirectoryUserKey}
                    onAddRoleMembers={handleAddRoleMembers}
                  />
                  {combinedMembers.length > 0 && (
                    <div>
                      <label className="block text-sm text-gray-200 mb-2">Team preview</label>
                      <div className="flex flex-wrap gap-2">
                        {combinedMembers.map(name => (
                          <span
                            key={name}
                            className="text-xs px-3 py-1 rounded-full bg-gray-800 border border-gray-700 text-gray-100"
                          >
                            {name}
                          </span>
                        ))}
                      </div>
                    </div>
                  )}
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-2">Your name</label>
                    <input
                      type="text"
                      value={userName}
                      onChange={(e) => setUserName(e.target.value)}
                      placeholder="What should we call you?"
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
                    />
                  </div>
                </div>
                <button
                  onClick={handleCreateProject}
                  disabled={!projectName || !userName}
                  className="w-full bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] disabled:cursor-not-allowed text-white font-medium py-3 rounded-lg transition-colors"
                >
                  Create Project
                </button>
              </div>

              <PulseOverview
                projects={projects}
                className="shadow-lg"
                subtitle="Live activity metabolism across your flows"
              />
            </div>
          </div>
        </div>
      );
    }

    function DashboardView({ projects, currentUser, roles, onSelectFlow, onCreateProject, onManageUsers, onManageTeams, onCreateFlow }) {
      const [expandedPanel, setExpandedPanel] = useState(null);
      const allStats = useMemo(() => {
        let totalProjects = projects.length;
        let totalFlows = 0;
        let totalReady = 0;
        let totalWaiting = 0;
        let totalInProgress = 0;
        let totalCompleted = 0;

        projects.forEach(project => {
          totalFlows += project.flows.length;
          project.flows.forEach(flow => {
            const orderedStages = getOrderedStages(flow);
            flow.activities.forEach(activity => {
              const firstStage = getFirstActiveStage(orderedStages);
              const stageIdSeed = activity.currentStageId || activity.stageId || (firstStage ? getStageIdentity(firstStage) : null);
              const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
              const currentStage = currentStageId ? orderedStages.find(stage => getStageIdentity(stage) === currentStageId) : firstStage || null;
              const activityForState = { ...activity, currentStageId, stageHistory };
              const state = currentStage ? computeActivityState(activityForState, currentStage, flow.activities, flow.edges) : 'waiting';
              if (state === 'ready') totalReady++;
              else if (state === 'waiting') totalWaiting++;
              else if (state === 'in_progress') totalInProgress++;
              else if (state === 'completed' || state === 'skipped' || activity.completedAt) totalCompleted++;
            });
          });
        });

        return { totalProjects, totalFlows, totalReady, totalWaiting, totalInProgress, totalCompleted };
      }, [projects]);

      const myWork = useMemo(() => {
        const work = [];
        projects.forEach(project => {
          project.flows.forEach(flow => {
            const orderedStages = getOrderedStages(flow);
            flow.activities.forEach(activity => {
              const firstStage = getFirstActiveStage(orderedStages);
              const stageIdSeed = activity.currentStageId || activity.stageId || (firstStage ? getStageIdentity(firstStage) : null);
              const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
              const activeEntry = currentStageId ? getLatestStageHistoryEntry(stageHistory, currentStageId) : null;
              if (activeEntry?.claimedBy === currentUser && !activity.completedAt) {
                const currentStage = currentStageId ? orderedStages.find(stage => getStageIdentity(stage) === currentStageId) : firstStage || null;
                const activityForState = { ...activity, currentStageId, stageHistory };
                const activeStageState = currentStage ? computeActivityState(activityForState, currentStage, flow.activities, flow.edges) : 'waiting';
                work.push({ project, flow, activity: { ...activity, activeStageEntry: activeEntry, activeStageState, activeStage: currentStage } });
              }
            });
          });
        });
        return work;
      }, [projects, currentUser]);

      const panelLayoutClasses = expandedPanel ? 'grid grid-cols-1 gap-6 mb-8' : 'grid grid-cols-1 xl:grid-cols-2 gap-6 mb-8';
      const isPulseHidden = expandedPanel && expandedPanel !== 'pulse';
      const isProjectsHidden = expandedPanel && expandedPanel !== 'projects';
      const handlePanelToggle = (panel) => {
        setExpandedPanel(prev => (prev === panel ? null : panel));
      };

      return (
        <div className="min-h-screen bg-[var(--bg)] text-[var(--text-strong)]">
          <div className="border-b border-[var(--border)] bg-[var(--surface)]/50">
            <div className="max-w-7xl mx-auto px-6 py-4">
              <div className="flex items-center justify-between">
                <div>
                  <h1 className="text-2xl font-bold">EO</h1>
                  <p className="text-sm text-[var(--text-muted)]">Emergent Organizing</p>
                </div>
                <div className="flex items-center gap-4">
                  <div className="text-sm text-[var(--text)]">You: {currentUser}</div>
                  <button onClick={onCreateProject} className="flex items-center gap-2 bg-[var(--accent)] hover:opacity-90 px-4 py-2 rounded-lg font-medium transition-colors text-sm">
                    <PlusIcon className="w-4 h-4" />New Project
                  </button>
                </div>
              </div>
            </div>
          </div>

          <div className="max-w-7xl mx-auto px-6 py-6">
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
              <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-4">
                <div className="text-2xl font-bold text-[var(--info)]">{allStats.totalProjects}</div>
                <div className="text-sm text-[var(--text-muted)]">Projects</div>
              </div>
              <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-4">
                <div className="text-2xl font-bold text-[var(--accent)]">{allStats.totalFlows}</div>
                <div className="text-sm text-[var(--text-muted)]">Active Flows</div>
              </div>
              <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-4">
                <div className="text-2xl font-bold text-[var(--ok)]">{allStats.totalReady}</div>
                <div className="text-sm text-[var(--text-muted)]">Ready to Start</div>
              </div>
              <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-4">
                <div className="text-2xl font-bold text-[var(--info)]">{allStats.totalInProgress}</div>
                <div className="text-sm text-[var(--text-muted)]">In Progress</div>
              </div>
            </div>

            <div className={panelLayoutClasses}>
              <PulseOverview
                projects={projects}
                className={`h-full ${isPulseHidden ? 'hidden' : ''}`}
                subtitle="System metabolism across all projects"
                actions={(
                  <button
                    onClick={() => handlePanelToggle('pulse')}
                    className="self-end bg-[var(--elevated)]/80 hover:bg-[color:oklch(from_var(--text)_0.82_0_0)] text-xs md:text-sm px-3 py-1.5 rounded-lg border border-[var(--border)] transition-colors"
                  >
                    {expandedPanel === 'pulse' ? 'Split view' : 'Full width'}
                  </button>
                )}
              />

              <div className={`${isProjectsHidden ? 'hidden' : ''} h-full`}>
                <div className="bg-[var(--surface)]/60 border border-[var(--border)] rounded-2xl p-6 h-full flex flex-col">
                  <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between mb-6">
                    <div>
                      <h2 className="text-lg font-semibold text-[var(--text-strong)]">All Projects</h2>
                      <p className="text-sm text-[var(--text-muted)]">Team matrix and flow overview</p>
                    </div>
                    <button
                      onClick={() => handlePanelToggle('projects')}
                      className="self-end bg-[var(--elevated)]/80 hover:bg-[color:oklch(from_var(--text)_0.82_0_0)] text-xs md:text-sm px-3 py-1.5 rounded-lg border border-[var(--border)] transition-colors"
                    >
                      {expandedPanel === 'projects' ? 'Split view' : 'Full width'}
                    </button>
                  </div>

                  {projects.length === 0 ? (
                    <div className="text-center py-20">
                      <LayersIcon className="w-16 h-16 text-[var(--text-muted)] mx-auto mb-4" />
                      <p className="text-[var(--text-muted)] mb-4">No projects yet</p>
                      <button onClick={onCreateProject} className="bg-[var(--accent)] hover:opacity-90 px-6 py-2 rounded-lg transition-colors">Create Your First Project</button>
                    </div>
                  ) : (
                    <div className="space-y-6">
                      {projects.map(project => (
                        <ProjectCard key={project.id} project={project} roles={roles} onSelectFlow={(f) => onSelectFlow(project, f)} onManageUsers={() => onManageUsers(project)} onManageTeams={() => onManageTeams && onManageTeams(project)} onCreateFlow={() => onCreateFlow(project)} />
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>

            {myWork.length > 0 && (
              <div className="mb-8">
                <h2 className="text-xl font-semibold mb-4">My Active Work</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {myWork.map(({ project, flow, activity }) => (
                    <div key={activity.id} className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-4 cursor-pointer hover:border-[var(--accent)] transition-colors" onClick={() => onSelectFlow(project, flow)}>
                      <div className="text-xs text-[var(--text-muted)] mb-2">{project.name} â†’ {flow.name}</div>
                      <h4 className="font-medium mb-2">{activity.title}</h4>
                      <div className="flex items-center gap-2">
                        {(() => {
                          const state = activity.activeStageState || 'in_progress';
                          const label = state.replace('_', ' ');
                          const cls = state === 'ready'
                            ? 'bg-[var(--ok)]/20 text-[var(--ok)]'
                            : state === 'completed'
                              ? 'bg-[var(--elevated)] text-[var(--text-muted)]'
                              : state === 'waiting'
                                ? 'bg-[var(--warn)]/20 text-[var(--warn)]'
                                : 'bg-[var(--info)]/20 text-[var(--info)]';
                          return <span className={`text-xs px-2 py-1 rounded ${cls}`}>{label}</span>;
                        })()}
                        {activity.activeStageEntry?.priority && <span className="text-xs text-[var(--text-muted)]">Priority: {activity.activeStageEntry.priority}</span>}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

          </div>
        </div>
      );
    }

    function ProjectCard({ project, roles, onSelectFlow, onManageUsers, onManageTeams, onCreateFlow }) {
      return (
        <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg overflow-hidden">
          <div className="p-6 border-b border-[var(--border)]">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-lg font-semibold">{project.name}</h3>
              <div className="flex gap-2">
                <button onClick={onManageTeams} className="flex items-center gap-2 bg-[var(--accent)] hover:opacity-90 px-4 py-2 rounded-lg font-medium transition-colors text-sm">
                  <UsersIcon className="w-4 h-4" />Manage Teams
                </button>
                <button onClick={onManageUsers} className="text-xs bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] px-3 py-1 rounded transition-colors">
                  <UsersIcon className="w-3 h-3 inline mr-1" />Users
                </button>
                <button onClick={onCreateFlow} className="text-xs bg-[var(--accent)] hover:opacity-90 px-3 py-1 rounded transition-colors">
                  <PlusIcon className="w-3 h-3 inline mr-1" />Flow
                </button>
              </div>
            </div>
            <p className="text-sm text-[var(--text-muted)]">Team: {project.users.map(u => u.name).join(', ')} Â· {project.flows.length} flows</p>
          </div>
          
          {project.flows.length === 0 ? (
            <div className="p-6 text-center text-[var(--text-muted)] text-sm">
              No flows yet. Create one to get started.
            </div>
          ) : (
            <div className="p-6 space-y-4">
              {project.flows.map(flow => (
                <FlowCard key={flow.id} flow={flow} roles={roles} onClick={() => onSelectFlow(flow)} />
              ))}
            </div>
          )}
        </div>
      );
    }

    function FlowCard({ flow, roles, onClick }) {
      const stats = useMemo(() => {
        let ready = 0, waiting = 0, inProgress = 0, completed = 0;
        const orderedStages = getOrderedStages(flow);
        flow.activities.forEach(activity => {
          const firstStage = getFirstActiveStage(orderedStages);
          const stageIdSeed = activity.currentStageId || activity.stageId || (firstStage ? getStageIdentity(firstStage) : null);
          const { currentStageId, stageHistory } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
          const currentStage = currentStageId ? orderedStages.find(stage => getStageIdentity(stage) === currentStageId) : firstStage || null;
          const activityForState = { ...activity, currentStageId, stageHistory };
          const state = currentStage ? computeActivityState(activityForState, currentStage, flow.activities, flow.edges) : 'waiting';
          if (state === 'ready') ready++;
          else if (state === 'waiting') waiting++;
          else if (state === 'in_progress') inProgress++;
          else if (state === 'completed' || state === 'skipped' || activity.completedAt) completed++;
        });
        return { ready, waiting, inProgress, completed };
      }, [flow]);

      return (
        <div className="bg-[var(--elevated)]/50 rounded-lg p-4 border border-[var(--border)] cursor-pointer hover:border-[var(--border)] transition-colors" onClick={onClick}>
          <div className="flex items-start justify-between mb-3">
            <div>
              <h4 className="font-medium text-sm mb-1">{flow.name}</h4>
              <p className="text-xs text-[var(--text-muted)]">{flow.deliverables.join(' Â· ')}</p>
            </div>
            <div className="text-xs text-[var(--text-muted)]">{flow.activities.length} activities</div>
          </div>
          <div className="grid grid-cols-4 gap-2">
            <div className="bg-[var(--surface)] rounded p-2">
              <div className="text-xs text-[var(--text-muted)] mb-1">Ready</div>
              <div className="text-lg font-semibold text-[var(--ok)]">{stats.ready}</div>
            </div>
            <div className="bg-[var(--surface)] rounded p-2">
              <div className="text-xs text-[var(--text-muted)] mb-1">Waiting</div>
              <div className="text-lg font-semibold text-[var(--warn)]">{stats.waiting}</div>
            </div>
            <div className="bg-[var(--surface)] rounded p-2">
              <div className="text-xs text-[var(--text-muted)] mb-1">In Progress</div>
              <div className="text-lg font-semibold text-[var(--info)]">{stats.inProgress}</div>
            </div>
            <div className="bg-[var(--surface)] rounded p-2">
              <div className="text-xs text-[var(--text-muted)] mb-1">Done</div>
              <div className="text-lg font-semibold text-[var(--text-muted)]">{stats.completed}</div>
            </div>
          </div>
        </div>
      );
    }

    function ActivitiesView({ project, flow, currentUser, canUserWorkOnStage, onBack, onCreateActivity, onEditActivity, onDeleteActivity, onClaimActivity, onUnclaimActivity, onCompleteActivity, onWireActivity, onRequestRevision, onAddComment, onAddAttachment, onRemoveAttachment, onMarkRead, onAdvanceActivityStage, onSkipActivityStage, onConfigureStageConditions, onToggleStageSkip, onAssignStageTeams, onUpdateActivity }) {
      const stageData = useMemo(() => {
        const ordered = getOrderedStages(flow);
        const map = {};
        ordered.forEach(stage => {
          const identity = stage.uid || getStageIdentity(stage);
          map[identity] = stage;
          if (stage.key) {
            map[stage.key] = stage;
          }
        });
        const fallback = ordered[0] || null;
        return { ordered, map, fallback };
      }, [flow]);

      const getNextActiveStage = (stage) => {
        if (!stage) return null;
        const identity = getStageIdentity(stage);
        const index = stageData.ordered.findIndex(item => getStageIdentity(item) === identity);
        if (index === -1) return null;
        return stageData.ordered.slice(index + 1).find(item => !item.skipped) || null;
      };

      const activitiesWithState = useMemo(() => {
        const fallbackId = stageData.fallback ? getStageIdentity(stageData.fallback) : null;
        return flow.activities.map(activity => {
          const stageIdSeed = activity.currentStageId || activity.stageId || fallbackId;
          const { currentStageId, stageHistory, stageReadBy } = ensureStageTracking(activity, stageIdSeed, activity.createdAt || Date.now());
          const normalizedStageId = currentStageId || fallbackId;
          const activityForState = {
            ...activity,
            currentStageId: normalizedStageId,
            stageId: normalizedStageId,
            stageHistory
          };
          const stageStates = stageData.ordered.map(stage => {
            const stageId = getStageIdentity(stage);
            return {
              stage,
              stageId,
              state: computeActivityState(activityForState, stage, flow.activities, flow.edges),
              entry: getLatestStageHistoryEntry(stageHistory, stageId)
            };
          });
          const activeStage = normalizedStageId ? stageData.map[normalizedStageId] || null : stageData.fallback || null;
          const activeStageState = activeStage ? computeActivityState(activityForState, activeStage, flow.activities, flow.edges) : 'waiting';
          const activeStageEntry = activeStage ? getLatestStageHistoryEntry(stageHistory, getStageIdentity(activeStage)) : null;
          const claimedBy = activeStageEntry?.claimedBy || null;
          const priority = activeStageEntry?.priority || null;
          return {
            ...activity,
            currentStageId: normalizedStageId,
            stageId: normalizedStageId,
            stageHistory,
            stageStates,
            activeStage,
            activeStageState,
            activeStageEntry,
            claimedBy,
            priority,
            stageReadBy,
            state: activeStageState
          };
        });
      }, [flow.activities, flow.edges, stageData]);

      const [selectedActivityId, setSelectedActivityId] = useState(null);

      const groupedActivities = useMemo(() => {
        const grouped = {};
        stageData.ordered.forEach(stage => {
          const identity = getStageIdentity(stage);
          grouped[identity] = [];
        });
        const fallbackId = stageData.fallback ? getStageIdentity(stageData.fallback) : null;
        activitiesWithState.forEach(activity => {
          const identity = stageData.map[activity.currentStageId] ? getStageIdentity(stageData.map[activity.currentStageId]) : fallbackId;
          if (identity) {
            if (!grouped[identity]) grouped[identity] = [];
            grouped[identity].push(activity);
          }
        });
        return grouped;
      }, [activitiesWithState, stageData]);

      useEffect(() => {
        if (selectedActivityId && !activitiesWithState.some(a => a.id === selectedActivityId)) {
          setSelectedActivityId(null);
        }
      }, [activitiesWithState, selectedActivityId]);

      const selectedActivity = useMemo(() => {
        return selectedActivityId ? activitiesWithState.find(a => a.id === selectedActivityId) : null;
      }, [selectedActivityId, activitiesWithState]);

      const selectedStage = useMemo(() => {
        if (!selectedActivity) return null;
        if (selectedActivity.activeStage) return selectedActivity.activeStage;
        return stageData.map[selectedActivity.currentStageId] || stageData.fallback || null;
      }, [selectedActivity, stageData]);

      const selectedNextStage = useMemo(() => {
        if (!selectedStage) return null;
        const identity = getStageIdentity(selectedStage);
        const nextStageId = getNextStageId(stageData.ordered, identity, selectedActivity?.skippedStages || []);
        return nextStageId ? stageData.map[nextStageId] || null : null;
      }, [selectedStage, stageData, selectedActivity]);

      const getDependencies = (activityId, stageId = null) => {
        const activity = flow.activities.find(a => a.id === activityId);
        const inferredStageId = stageId || getActivityDefaultStageId(activity, stageData.ordered);
        const inbound = flow.edges.filter(e => e.dstId === activityId);
        return inbound.map(edge => {
          const blockingStageId = edge.dstStage || inferredStageId;
          if (inferredStageId && blockingStageId && inferredStageId !== blockingStageId) {
            return null;
          }
          const src = flow.activities.find(a => a.id === edge.srcId);
          const requiredStageId = edge.srcStage || getActivityDefaultStageId(src, stageData.ordered);
          const status = getStageStatusFromHistory(src, requiredStageId);
          return {
            edge,
            activity: src,
            edgeType: edge.type,
            requiredStageId,
            blockingStageId,
            requiredStageName: requiredStageId ? (stageData.map[requiredStageId]?.name || requiredStageId) : 'Unassigned stage',
            blockingStageName: blockingStageId ? (stageData.map[blockingStageId]?.name || blockingStageId) : 'Unassigned stage',
            satisfied: status.completed || status.skipped || !!src?.completedAt,
            missingSource: !src,
            needsMigration: !edge.srcStage || !edge.dstStage,
            stageInferred: !!edge.stageInferred,
            status
          };
        }).filter(Boolean);
      };

      const selectedDependencies = useMemo(() => {
        return selectedActivity ? getDependencies(selectedActivity.id, selectedActivity.currentStageId) : [];
      }, [selectedActivity, flow.edges, flow.activities]);

      const openActivityDetails = (activityId) => {
        setSelectedActivityId(activityId);
        if (currentUser) {
          onMarkRead(project.id, flow.id, activityId, currentUser);
        }
      };

      const closeDetails = () => {
        setSelectedActivityId(null);
      };

      return (
        <div className="min-h-screen bg-[var(--bg)] text-[var(--text-strong)]">
          <div className="border-b border-[var(--border)] bg-[var(--surface)]/50">
            <div className="max-w-7xl mx-auto px-6 py-4">
              <div className="flex items-center justify-between">
                <button onClick={onBack} className="flex items-center gap-2 text-[var(--text)] hover:text-[var(--text-strong)] transition-colors">
                  <HomeIcon className="w-4 h-4" />
                  Dashboard
                </button>
                <div className="text-sm text-[var(--text-muted)]">
                  {project.name} â†’ {flow.name}
                </div>
              </div>
            </div>
          </div>

          <div className="max-w-7xl mx-auto p-6">
            <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-6 mb-8">
              <div className="flex items-start justify-between mb-4">
                <div>
                  <h1 className="text-2xl font-bold mb-2">{flow.name}</h1>
                  {flow.description && <p className="text-[var(--text)]">{flow.description}</p>}
                </div>
                <button onClick={() => onCreateActivity()} className="flex items-center gap-2 bg-[var(--accent)] hover:opacity-90 px-4 py-2 rounded-lg font-medium transition-colors">
                  <PlusIcon className="w-4 h-4" />New Activity
                </button>
              </div>
              <div>
                <div className="text-sm text-[var(--text)] mb-2">Flow Deliverables:</div>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                  {flow.deliverables.map((d, i) => (
                    <div key={i} className="bg-[var(--elevated)] rounded px-3 py-2 text-sm text-[var(--text)]">{d}</div>
                  ))}
                </div>
              </div>
            </div>

            <div className="space-y-8">
              {['creation', 'verification', 'evolution'].map(tierKey => {
                const tierStages = stageData.ordered.filter(stage =>
                  STAGE_TIERS[tierKey].includes(stage.operatorKey || stage.key)
                );
                const tierLabel = TIER_LABELS[tierKey];

                if (tierStages.length === 0) {
                  return null;
                }

                return (
                  <div key={tierKey} className="space-y-4">
                    <div className="flex items-center gap-4">
                      <h3 className="text-lg font-semibold text-[var(--info)]">
                        {tierLabel.title}
                      </h3>
                      <span className="text-sm text-[var(--text-muted)]">
                        {tierLabel.subtitle}
                      </span>
                      <div className="flex-1 h-px bg-[var(--border)]" />
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      {tierStages.map(stage => {
                        const identity = getStageIdentity(stage);
                        const stageActivities = groupedActivities[identity] || [];
                        const stageTeams = resolveStageTeams(project, flow, identity);
                        const stageConditions = (stage.conditions || '').trim();
                        const stageIndex = stageData.ordered.findIndex(item => getStageIdentity(item) === identity);
                        return (
                          <div key={identity} className={`bg-[var(--surface)] border ${stage.skipped ? 'border-[var(--warn)] border-dashed opacity-70' : 'border-[var(--border)]'} rounded-lg p-4 min-h-[320px] flex flex-col`}>
                            <div className="mb-4">
                              <div className="flex items-start justify-between gap-2 mb-2">
                                <div className="space-y-1">
                                  <div className="flex items-center gap-2">
                                    <h3 className="font-semibold text-sm">{stageIndex + 1}. {stage.name}</h3>
                                    <button
                                      onClick={() => onCreateActivity(stage.operatorKey || stage.key || stage.uid || stage.name)}
                                      className="p-1 rounded bg-[var(--elevated)]/60 hover:bg-[color:oklch(from_var(--text)_0.82_0_0)] transition-colors"
                                      title="Add activity"
                                    >
                                      <PlusIcon className="w-3.5 h-3.5" />
                                    </button>
                                  </div>
                                  <p className="text-xs text-[var(--text)] leading-relaxed">{stage.description}</p>
                                </div>
                                <span className="text-xs bg-[var(--elevated)] px-2 py-1 rounded self-start">{stageActivities.length}</span>
                              </div>
                              {(() => {
                                if (stageTeams.length === 0) {
                                  return (
                                    <div className="text-xs text-[var(--warn)] bg-[var(--warn)]/20 border border-[var(--warn)]/30 rounded px-2 py-1 mt-2">
                                      âš ï¸ No teams assigned - no one can work on activities in this stage
                                    </div>
                                  );
                                }
                                return (
                                  <div className="flex flex-wrap gap-1 mt-2">
                                    {stageTeams.map(team => (
                                      <span
                                        key={team.id}
                                        className="inline-flex items-center gap-1 text-xs bg-[var(--elevated)]/60 px-2 py-1 rounded"
                                      >
                                        <div
                                          className="w-2 h-2 rounded-full"
                                          style={{ backgroundColor: TEAM_COLOR_MAP[team.color] || 'var(--accent)' }}
                                        ></div>
                                        {team.name}
                                      </span>
                                    ))}
                                  </div>
                                );
                              })()}
                              {stageConditions && (
                                <div className="text-xs text-[var(--info)] bg-[var(--info)]/30 border border-[var(--info)]/40 rounded px-2 py-1 mt-2">
                                  Conditions: {stageConditions}
                                </div>
                              )}
                              <div className="flex flex-wrap gap-2 mt-3">
                                <button
                                  onClick={() => {
                                    if (onAssignStageTeams) {
                                      onAssignStageTeams(identity);
                                    }
                                  }}
                                  className="text-xs px-2 py-1 rounded bg-[var(--elevated)] hover:bg-[color:oklch(from_var(--text)_0.82_0_0)] transition-colors"
                                >
                                  <UsersIcon className="w-3 h-3 inline mr-1" />
                                  Teams ({stageTeams.length})
                                </button>
                                <button
                                  onClick={() => {
                                    if (!onConfigureStageConditions) return;
                                    const existing = stage.conditions || '';
                                    const input = window.prompt(`Set entry conditions for ${stage.name}`, existing);
                                    if (input !== null) {
                                      onConfigureStageConditions(identity, input.trim());
                                    }
                                  }}
                                  className="text-xs px-2 py-1 rounded bg-[var(--elevated)] hover:bg-[color:oklch(from_var(--text)_0.82_0_0)] transition-colors"
                                >
                                  Conditions
                                </button>
                                <button
                                  onClick={() => onToggleStageSkip && onToggleStageSkip(identity)}
                                  className={`text-xs px-2 py-1 rounded transition-colors ${stage.skipped ? 'bg-[var(--warn)]/60 hover:opacity-90/70 text-[var(--warn)]' : 'bg-[var(--elevated)] hover:bg-[color:oklch(from_var(--text)_0.82_0_0)]'}`}
                                >
                                  {stage.skipped ? 'Resume Stage' : 'Skip Stage'}
                                </button>
                              </div>
                            </div>
                            <div className="space-y-2 flex-1">
                              {stageActivities.length === 0 ? (
                                <p className="text-sm text-[var(--text-muted)] text-center py-6">No activities</p>
                              ) : (
                                stageActivities.map(activity => {
                                  const deps = getDependencies(activity.id, activity.currentStageId || activity.stageId);
                                  const activityStage = stageData.map[activity.stageId] || stageData.map[identity] || stageData.fallback;
                                  const nextStage = getNextActiveStage(activityStage);
                                  return (
                                    <ActivityCard
                                      key={activity.id}
                                      activity={activity}
                                      stage={activityStage}
                                      nextStage={nextStage}
                                      dependencies={deps}
                                      project={project}
                                      flow={flow}
                                      currentUser={currentUser}
                                      canUserWorkOnStage={canUserWorkOnStage}
                                      stageMap={stageData.map}
                                      isSelected={selectedActivityId === activity.id}
                                      onOpenDetails={openActivityDetails}
                                      onEdit={onEditActivity}
                                      onDelete={onDeleteActivity}
                                      onClaim={onClaimActivity}
                                      onUnclaim={onUnclaimActivity}
                                      onAdvanceStage={onAdvanceActivityStage}
                                      onSkipStage={onSkipActivityStage}
                                      onComplete={onCompleteActivity}
                                      onWire={onWireActivity}
                                      onRequestRevision={onRequestRevision}
                                    />
                                  );
                                })
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })}
            </div>
            {selectedActivity && (
              <ActivityDetailPanel
                activity={selectedActivity}
                stage={selectedStage}
                nextStage={selectedNextStage}
                stageMap={stageData.map}
                dependencies={selectedDependencies}
                project={project}
                flow={flow}
                canUserWorkOnStage={canUserWorkOnStage}
                currentUser={currentUser}
                onClose={closeDetails}
                onEdit={onEditActivity}
                onDelete={onDeleteActivity}
                onClaim={onClaimActivity}
                onUnclaim={onUnclaimActivity}
                onAdvanceStage={onAdvanceActivityStage}
                onSkipStage={onSkipActivityStage}
                onComplete={onCompleteActivity}
                onWire={onWireActivity}
                onRequestRevision={onRequestRevision}
                onAddComment={(text) => currentUser && onAddComment(project.id, flow.id, selectedActivity.id, currentUser, text)}
                onAddAttachment={(attachment) => onAddAttachment(project.id, flow.id, selectedActivity.id, attachment)}
                onRemoveAttachment={(attachmentId) => onRemoveAttachment(project.id, flow.id, selectedActivity.id, attachmentId)}
                onUpdate={(activityId, updates) => onUpdateActivity && onUpdateActivity(activityId, updates)}
              />
            )}
          </div>
        </div>
      );
    }

    function ActivityCard({ activity, stage, nextStage, dependencies, project, flow, currentUser, canUserWorkOnStage, stageMap, isSelected, onOpenDetails, onEdit, onDelete, onClaim, onUnclaim, onAdvanceStage, onSkipStage, onComplete, onWire, onRequestRevision }) {
      const activeStage = stage;
      const stageState = activity.activeStageState || activity.state || 'waiting';
      const activeEntry = activity.activeStageEntry || null;
      const claimedBy = activeEntry?.claimedBy || null;
      const priority = activeEntry?.priority || null;
      const isMine = claimedBy && claimedBy === currentUser;
      const canClaim = stageState === 'ready' && !claimedBy && canUserWorkOnStage?.(flow, activity.currentStageId, currentUser);
      const canCompleteStage = isMine && stageState === 'in_progress';
      const isActivityCompleted = !!activity.completedAt;
      const canAdvanceStage = !isActivityCompleted && !!nextStage && stageState !== 'completed' && stageState !== 'skipped';
      const canSkipStage = !isActivityCompleted && !!nextStage;
      const stageSupportsRevision = activeStage?.supportsRevision;
      const showRevisionButton = stageSupportsRevision && dependencies.length > 0 && !isActivityCompleted;
      const showCompleteActivity = !nextStage && canCompleteStage;

      const stateConfig = {
        ready: { label: 'Ready', color: 'bg-[var(--ok)]/20 text-[var(--ok)]' },
        waiting: { label: 'Waiting', color: 'bg-[var(--warn)]/20 text-[var(--warn)]' },
        in_progress: { label: isMine ? 'You' : (claimedBy || 'In progress'), color: isMine ? 'bg-[var(--info)]/20 text-[var(--info)]' : 'bg-[color:oklch(from_var(--text)_0.82_0_0)] text-[var(--text)]' },
        completed: { label: 'âœ“ Completed', color: 'bg-[color:oklch(from_var(--text)_0.82_0_0)] text-[var(--text-muted)]' },
        skipped: { label: 'Skipped', color: 'bg-[var(--warn)]/20 text-[var(--warn)]' }
      };

      const config = stateConfig[stageState] || stateConfig.ready;
      const commentCount = activity.comments?.length || 0;
      const attachmentCount = activity.attachments?.length || 0;
      const stageReaders = activity.stageReadBy?.[activity.currentStageId] || {};
      const lastRead = stageReaders[currentUser] || 0;
      const hasUnread = (activity.comments || []).some(comment => !comment.system && comment.createdAt > lastRead && comment.author !== currentUser);
      const stageName = activeStage?.name || 'Unassigned stage';
      const stageBadgeClass = stageState === 'completed' ? 'bg-[var(--ok)]/60 text-[var(--ok)]' : activeStage?.skipped ? 'bg-[var(--warn)]/60 text-[var(--warn)]' : 'bg-[color:oklch(from_var(--text)_0.82_0_0)] text-[var(--text)]';
      const stageHistoryLog = (activeEntry?.log || []).slice(-2).reverse();
      const stageStates = activity.stageStates || [];
      const projectUsers = project?.users || [];

      const renderTaggedUsers = (taggedIds, className = 'mt-2') => {
        const ids = Array.isArray(taggedIds) ? taggedIds.filter(Boolean) : [];
        if (ids.length === 0) return null;
        return (
          <div className={`${className} flex flex-wrap gap-1 text-[11px] text-[var(--info)]`}>
            {ids.map(id => {
              const user = projectUsers.find(u => u.id === id);
              const label = user?.name || 'Unknown user';
              return (
                <span key={id} className="inline-flex items-center gap-1 bg-[var(--info)]/30 border border-[var(--info)]/40 px-2 py-0.5 rounded">
                  <span className="text-[10px] font-semibold">{getUserInitials(user?.name || '')}</span>
                  {label}
                </span>
              );
            })}
          </div>
        );
      };

      return (
        <div
          className={`bg-[var(--elevated)] border ${isSelected ? 'border-[var(--accent)]' : 'border-[var(--border)]'} rounded-lg p-3 hover:border-[var(--accent)] transition-colors cursor-pointer`}
          onClick={(e) => {
            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('input') || e.target.closest('textarea')) return;
            onOpenDetails(activity.id);
          }}
        >
          <div className="flex items-start justify-between mb-2">
            <div className="flex-1">
              <div className="flex items-center gap-2 mb-1">
                <span className={`text-[10px] uppercase tracking-wide px-2 py-0.5 rounded ${stageBadgeClass}`}>{stageName}</span>
                {priority && <span className="text-[10px] bg-[var(--info)]/50 text-[var(--info)] px-2 py-0.5 rounded">{priority}</span>}
                {activity.skippedStages?.length > 0 && (
                  <span className="text-[10px] text-[var(--warn)]">{activity.skippedStages.length} skipped</span>
                )}
              </div>
              <h4 className="font-medium text-sm">{activity.title}</h4>
              {claimedBy && <div className="text-[11px] text-[var(--text-muted)]">Claimed by {claimedBy}</div>}
            </div>
            <div className="flex items-center gap-1 ml-2">
              <span className={`text-xs px-2 py-0.5 rounded ${config.color}`}>{config.label}</span>
              {hasUnread && <span className="w-2 h-2 rounded-full bg-[var(--info)]" title="Unread comments" />}
            </div>
          </div>
          {activity.isRevision && <div className="text-xs text-[var(--warn)] mb-2">ðŸ”„ Revision requested</div>}
          {(() => {
            const teams = resolveStageTeams(project, flow, activity.currentStageId);
            if (teams.length === 0) return null;
            return (
              <div className="text-xs text-[var(--text)] mb-2">
                {teams.map(team => (
                  <span key={team.id} className="inline-flex items-center gap-1 mr-2">
                    <span
                      className="w-2 h-2 rounded-full"
                      style={{ backgroundColor: TEAM_COLOR_MAP[team.color] || 'var(--accent)' }}
                    ></span>
                    {team.name}
                  </span>
                ))}
              </div>
            );
          })()}
          {activity.deliverable && <div className="text-xs text-[var(--text)] mb-2"><span className="text-[var(--text-muted)]">Delivers:</span> {activity.deliverable}</div>}
          {stageStates.length > 0 && (
            <div className="flex flex-wrap gap-1 text-[10px] text-[var(--text-muted)] mb-2">
              {stageStates.map(({ stage: stageInfo, state }) => {
                const status = state === 'in_progress' ? 'doing' : state.replace('_', ' ');
                return (
                  <span key={getStageIdentity(stageInfo)} className={`px-2 py-0.5 rounded ${state === 'completed' ? 'bg-[var(--ok)]/40 text-[var(--ok)]' : state === 'in_progress' ? 'bg-[var(--info)]/40 text-[var(--info)]' : state === 'ready' ? 'bg-[var(--ok)]/40 text-[var(--ok)]' : state === 'skipped' ? 'bg-[var(--warn)]/30 text-[var(--warn)]' : 'bg-[var(--elevated)] text-[var(--text)]'}`}>
                    {stageInfo.name}: {status}
                  </span>
                );
              })}
            </div>
          )}
          {stageHistoryLog.length > 0 && (
            <div className="text-[11px] text-[var(--text-muted)] mb-2">
              <div className="uppercase tracking-wide text-[var(--text-muted)] mb-1">Recent stage activity</div>
              <ul className="space-y-0.5">
                {stageHistoryLog.map(entry => (
                  <li key={entry.id}>{entry.text}</li>
                ))}
              </ul>
            </div>
          )}
          {dependencies.length > 0 && (
            <div className="text-xs text-[var(--text)] mb-2">
              <div className="text-[var(--text-muted)] mb-1">Waiting on:</div>
              <ul className="space-y-0.5 ml-2">
                {dependencies.slice(0, 2).map((dep, i) => {
                  const isCleared = dep.satisfied;
                  return (
                    <li key={i} className={`flex items-center gap-2 ${isCleared ? 'text-[var(--text-muted)]' : 'text-[var(--text)]'}`}>
                      <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-[var(--elevated)]/80 text-[10px] text-[var(--text)]">
                        {dep.requiredStageName || 'Stage'}
                      </span>
                      <span className="text-[10px] text-[var(--text-muted)]">â†’</span>
                      <span className="inline-flex items-center gap-1 px-1.5 py-0.5 rounded bg-[var(--elevated)]/60 text-[10px] text-[var(--text)]">
                        {dep.blockingStageName || 'Stage'}
                      </span>
                      <span className={`text-[10px] ${dep.satisfied ? 'text-[var(--ok)]' : 'text-[var(--warn)]'}`}>{dep.satisfied ? 'cleared' : 'blocking'}</span>
                      <span className="flex-1">
                        {dep.activity ? dep.activity.title : 'Missing activity'} {dep.edgeType === 'loops' && '(revision)'}
                      </span>
                    </li>
                  );
                })}
                {dependencies.length > 2 && <li className="text-[var(--text-muted)]">+{dependencies.length - 2} more</li>}
              </ul>
            </div>
          )}
          <div className="flex items-center gap-3 text-xs text-[var(--text-muted)] mt-3">
            {attachmentCount > 0 && (
              <div className="flex items-center gap-1"><span role="img" aria-label="attachments">ðŸ“Ž</span>{attachmentCount}</div>
            )}
            {commentCount > 0 && (
              <div className="flex items-center gap-1"><ChatBubbleIcon className="w-3.5 h-3.5" />{commentCount}</div>
            )}
            {activity.createdAt && <div className="ml-auto text-[var(--text-muted)]">{formatRelativeTime(activity.createdAt)}</div>}
          </div>
          <div className="flex gap-1 mt-3 flex-wrap">
            {!activity.completedAt && (
              <>
                <button onClick={(e) => { e.stopPropagation(); onEdit(activity.id); }} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] text-xs py-1 px-2 rounded transition-colors" title="Edit"><EditIcon className="w-3 h-3" /></button>
                <button onClick={(e) => { e.stopPropagation(); onDelete(activity.id); }} className="bg-[var(--danger)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors" title="Delete"><TrashIcon className="w-3 h-3" /></button>
              </>
            )}
            {canClaim && <button onClick={(e) => { e.stopPropagation(); onClaim(activity.id); }} className="flex-1 bg-[var(--accent)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors">Claim</button>}
            {isMine && !activity.completedAt && <button onClick={(e) => { e.stopPropagation(); onUnclaim(activity.id); }} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] text-xs py-1 px-2 rounded transition-colors">Unclaim</button>}
            {canAdvanceStage && (
              <button onClick={(e) => { e.stopPropagation(); onAdvanceStage(activity.id, { skip: false }); }} className="bg-[var(--ok)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors">Advance</button>
            )}
            {canSkipStage && (
              <button onClick={(e) => { e.stopPropagation(); onSkipStage(activity.id); }} className="bg-[var(--warn)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors text-white">Skip</button>
            )}
          {showRevisionButton && (
            <button onClick={(e) => { e.stopPropagation(); const lastDep = dependencies[dependencies.length - 1]; if (lastDep) { const reason = window.prompt('Reason for revision? (optional)', '') || ''; onRequestRevision(activity.id, lastDep.requiredStageId || activity.currentStageId, reason); } }} className="bg-[var(--warn)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors flex items-center justify-center gap-1" title="Request revision"><RefreshIcon className="w-3 h-3" /></button>
          )}
            {showCompleteActivity && (
              <button onClick={(e) => { e.stopPropagation(); onComplete(activity.id); }} className="flex-1 bg-[var(--ok)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors">Complete Activity</button>
            )}
            {!activity.completedAt && <button onClick={(e) => { e.stopPropagation(); onWire(activity.id); }} className="bg-[var(--accent)] hover:opacity-90 text-xs py-1 px-2 rounded transition-colors">Wire</button>}
          </div>
        </div>
      );
    }

    function ManageUsersModal({ project, onClose, onSaveUser, onRemoveUser }) {
      const createEmptyForm = () => ({
        id: null,
        name: '',
        email: '',
        phone: '',
        relationship: '',
        role: 'viewer',
        matrixId: '',
        avatar: '',
        notes: '',
        metadata: {}
      });

      const [formData, setFormData] = useState(createEmptyForm());
      const [isEditing, setIsEditing] = useState(false);
      const [showForm, setShowForm] = useState((project.users || []).length === 0);
      const [error, setError] = useState('');

      useEffect(() => {
        setFormData(createEmptyForm());
        setIsEditing(false);
        setShowForm((project.users || []).length === 0);
        setError('');
      }, [project.id]);

      const users = project.users || [];

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
      };

      const startAdd = () => {
        setFormData(createEmptyForm());
        setIsEditing(false);
        setShowForm(true);
        setError('');
      };

      const startEdit = (user) => {
        setFormData({
          ...createEmptyForm(),
          ...user,
          metadata: user.metadata || {}
        });
        setIsEditing(true);
        setShowForm(true);
        setError('');
      };

      const handleSubmit = () => {
        if (!formData.name || !formData.name.trim()) {
          setError('Please enter a name for this user.');
          return;
        }

        const payload = { ...formData };
        if (!isEditing) {
          delete payload.id;
        }
        onSaveUser(payload);
        setFormData(createEmptyForm());
        setIsEditing(false);
        setShowForm(false);
        setError('');
      };

      const handleCancel = () => {
        setFormData(createEmptyForm());
        setIsEditing(false);
        setShowForm(false);
        setError('');
      };

      const handleRemove = (userId) => {
        if (window.confirm('Remove this user? They will be removed from teams and untagged from any notes.')) {
          onRemoveUser(userId);
        }
      };

      const formatDateDisplay = (value) => {
        if (!value) return null;
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return null;
        return date.toLocaleDateString();
      };

      return (
        <Modal onClose={onClose} title="Users & Care Team">
          <div className="space-y-6">
            <div className="bg-[var(--info)]/30 border border-[var(--info)]/50 rounded p-4">
              <p className="text-sm text-[var(--text-strong)] font-semibold">Manage your care team and collaborators.</p>
              <p className="text-xs text-[var(--info)] mt-2">
                Add doctors, family members, or stakeholders. Tag them in activity notes to keep everyone aligned.
              </p>
              <p className="text-[11px] text-[var(--info)] mt-2">
                Future feature: share specific activity updates via Matrix using the Matrix ID field.
              </p>
            </div>

            <div className="flex items-center justify-between gap-3">
              <h3 className="text-sm font-semibold text-[var(--text-strong)]">Care Team</h3>
              <button
                onClick={startAdd}
                className="bg-[var(--accent)] hover:opacity-90 px-3 py-1.5 rounded text-sm transition-colors"
              >
                + Add User
              </button>
            </div>

            {users.length === 0 ? (
              <div className="text-sm text-[var(--text-muted)] bg-[var(--surface)]/60 border border-[var(--border)] rounded-lg p-6 text-center">
                No users added yet. Start by adding your care team or collaborators.
              </div>
            ) : (
              <div className="space-y-3">
                {users.map(user => {
                  const added = formatDateDisplay(user.addedAt);
                  const updated = formatDateDisplay(user.lastModified);
                  return (
                    <div key={user.id} className="bg-[var(--elevated)] border border-[var(--border)] rounded-lg p-4 space-y-3">
                      <div className="flex flex-col md:flex-row md:items-start md:gap-4">
                        <div className="w-14 h-14 rounded-full bg-gradient-to-br from-[var(--accent)] to-[color:oklch(from_var(--accent)_0.68_0.12_260)] text-white flex items-center justify-center font-semibold text-lg overflow-hidden flex-shrink-0">
                          {user.avatar ? (
                            <img src={user.avatar} alt={user.name || 'User avatar'} className="w-full h-full object-cover" />
                          ) : (
                            <span>{getUserInitials(user.name)}</span>
                          )}
                        </div>
                        <div className="flex-1 space-y-3">
                          <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-3">
                            <div>
                              <div className="text-base font-semibold text-[var(--text-strong)]">{user.name || 'Unnamed User'}</div>
                              <div className="flex flex-wrap gap-2 mt-1">
                                {user.relationship && (
                                  <span className="text-[11px] px-2 py-0.5 rounded-full bg-[var(--info)]/20 text-[var(--info)] border border-[var(--info)]/30">
                                    {user.relationship}
                                  </span>
                                )}
                                {user.role && (
                                  <span className="text-[11px] px-2 py-0.5 rounded-full bg-[var(--warn)]/20 text-[var(--warn)] border border-[var(--warn)]/30">
                                    {user.role}
                                  </span>
                                )}
                              </div>
                            </div>
                            <div className="flex gap-2">
                              <button
                                onClick={() => startEdit(user)}
                                className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] text-sm px-3 py-1.5 rounded transition-colors"
                              >
                                Edit
                              </button>
                              <button
                                onClick={() => handleRemove(user.id)}
                                className="bg-[var(--danger)]/70 hover:opacity-90 text-sm px-3 py-1.5 rounded text-[var(--danger)] transition-colors"
                              >
                                Remove
                              </button>
                            </div>
                          </div>
                          <div className="flex flex-wrap gap-4 text-xs text-[var(--text-muted)]">
                            {user.email && <span>âœ‰ï¸ {user.email}</span>}
                            {user.phone && <span>ðŸ“ž {user.phone}</span>}
                            {user.matrixId && <span>ðŸ”— {user.matrixId}</span>}
                          </div>
                          {user.notes && (
                            <div className="text-xs text-[var(--text)] bg-[var(--surface)]/50 border border-[var(--border)] rounded p-3 leading-relaxed">
                              {user.notes}
                            </div>
                          )}
                          {(added || updated) && (
                            <div className="text-[10px] text-[var(--text-muted)]">
                              {added && <span>Added {added}</span>}
                              {added && updated && <span className="mx-1">â€¢</span>}
                              {updated && <span>Updated {updated}</span>}
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            )}

            {showForm && (
              <div className="bg-[var(--surface)] border border-[var(--border)] rounded-lg p-4 space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="text-sm font-semibold text-[var(--text-strong)]">{isEditing ? 'Edit User' : 'Add User'}</h3>
                  <span className="text-xs text-[var(--text-muted)]">Fields marked with * are required.</span>
                </div>
                {error && <div className="text-xs text-[var(--danger)] bg-[var(--danger)]/30 border border-[var(--danger)]/50 rounded px-3 py-2">{error}</div>}
                <div className="grid md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Name *</label>
                    <input
                      type="text"
                      value={formData.name}
                      onChange={(e) => handleInputChange('name', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                      placeholder="Full name"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Email</label>
                    <input
                      type="email"
                      value={formData.email}
                      onChange={(e) => handleInputChange('email', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                      placeholder="email@example.com"
                    />
                  </div>
                </div>
                <div className="grid md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Phone</label>
                    <input
                      type="tel"
                      value={formData.phone}
                      onChange={(e) => handleInputChange('phone', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                      placeholder="(555) 000-0000"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Relationship / Title</label>
                    <input
                      type="text"
                      value={formData.relationship}
                      onChange={(e) => handleInputChange('relationship', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                      placeholder="e.g., Primary Care Doctor"
                    />
                  </div>
                </div>
                <div className="grid md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Role</label>
                    <select
                      value={formData.role}
                      onChange={(e) => handleInputChange('role', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                    >
                      <option value="viewer">Viewer</option>
                      <option value="contributor">Contributor</option>
                      <option value="admin">Admin</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Matrix ID</label>
                    <input
                      type="text"
                      value={formData.matrixId}
                      onChange={(e) => handleInputChange('matrixId', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                      placeholder="@username:matrix.org"
                    />
                    <p className="text-[10px] text-[var(--text-muted)] mt-1">Saved for future Matrix integrations.</p>
                  </div>
                </div>
                <div className="grid md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-[var(--text)] mb-1">Avatar URL</label>
                    <input
                      type="text"
                      value={formData.avatar}
                      onChange={(e) => handleInputChange('avatar', e.target.value)}
                      className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                      placeholder="Link to image (optional)"
                    />
                  </div>
                  <div className="hidden md:block"></div>
                </div>
                <div>
                  <label className="block text-sm text-[var(--text)] mb-1">Notes</label>
                  <textarea
                    value={formData.notes}
                    onChange={(e) => handleInputChange('notes', e.target.value)}
                    rows={3}
                    className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-3 py-2 text-sm text-[var(--text-strong)]"
                    placeholder="Additional information about this person"
                  />
                </div>
                <div className="flex justify-end gap-2 pt-2">
                  <button onClick={handleCancel} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] px-4 py-2 rounded text-sm transition-colors">
                    Cancel
                  </button>
                  <button onClick={handleSubmit} className="bg-[var(--accent)] hover:opacity-90 px-4 py-2 rounded text-sm transition-colors">
                    Save User
                  </button>
                </div>
              </div>
            )}

            <div className="flex justify-end pt-2">
              <button onClick={onClose} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] px-4 py-2 rounded text-sm transition-colors">
                Done
              </button>
            </div>
          </div>
        </Modal>
      );
    }

    function ManageTeamsModal({ project, onClose, onCreateTeam, onUpdateTeam, onDeleteTeam }) {
      const [editingTeam, setEditingTeam] = useState(null);
      const [newTeamName, setNewTeamName] = useState('');
      const [selectedUserIds, setSelectedUserIds] = useState([]);

      const teams = project.teams || [];

      const toggleUser = (userId) => {
        setSelectedUserIds(prev =>
          prev.includes(userId)
            ? prev.filter(id => id !== userId)
            : [...prev, userId]
        );
      };

      const handleCreateTeam = () => {
        if (newTeamName.trim()) {
          onCreateTeam(newTeamName.trim(), selectedUserIds);
          setNewTeamName('');
          setSelectedUserIds([]);
        }
      };

      const handleUpdateTeam = () => {
        if (editingTeam && newTeamName.trim()) {
          onUpdateTeam(editingTeam.id, {
            name: newTeamName.trim(),
            userIds: selectedUserIds
          });
          setEditingTeam(null);
          setNewTeamName('');
          setSelectedUserIds([]);
        }
      };

      const startEdit = (team) => {
        setEditingTeam(team);
        setNewTeamName(team.name);
        setSelectedUserIds([...team.userIds]);
      };

      return (
        <Modal onClose={onClose} title="Manage Teams" size="large">
          <div className="space-y-6">
            <div className="bg-[var(--info)]/30 border border-[var(--info)]/50 rounded p-4">
              <p className="text-sm text-[var(--text-strong)]">
                Teams are groups of people who work together. Assign teams to stages in your flows.
              </p>
            </div>

            <div>
              <h3 className="text-sm font-semibold text-[var(--text)] mb-3">Current Teams</h3>
              <div className="space-y-2">
                {teams.length === 0 ? (
                  <p className="text-sm text-[var(--text-muted)]">No teams yet. Create one below.</p>
                ) : (
                  teams.map(team => (
                    <div key={team.id} className="flex items-center justify-between bg-[var(--elevated)] rounded px-4 py-3">
                      <div>
                        <div className="flex items-center gap-2">
                          <div
                            className="w-3 h-3 rounded-full"
                            style={{ backgroundColor: TEAM_COLOR_MAP[team.color] || 'var(--accent)' }}
                          ></div>
                          <span className="font-medium text-[var(--text-strong)]">{team.name}</span>
                        </div>
                        <div className="text-xs text-[var(--text-muted)] mt-1">
                          {team.userIds.length} members:{' '}
                          {team.userIds
                            .map(uid => project.users.find(u => u.id === uid)?.name)
                            .filter(Boolean)
                            .join(', ')}
                        </div>
                      </div>
                      <div className="flex gap-2">
                        <button onClick={() => startEdit(team)} className="text-[var(--info)] hover:text-[var(--info)] text-sm">Edit</button>
                        <button onClick={() => { if (confirm(`Delete team "${team.name}"?`)) { onDeleteTeam(team.id); } }} className="text-[var(--danger)] hover:text-[var(--danger)] text-sm">Delete</button>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </div>

            <div className="border-t border-[var(--border)] pt-6">
              <h3 className="text-sm font-semibold text-[var(--text)] mb-3">{editingTeam ? 'Edit Team' : 'Create New Team'}</h3>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm text-[var(--text)] mb-2">Team name</label>
                  <input type="text" value={newTeamName} onChange={(e) => setNewTeamName(e.target.value)} placeholder="e.g., Writers, Editors, QA" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400" />
                </div>

                <div>
                  <label className="block text-sm text-[var(--text)] mb-2">Team members</label>
                  <div className="space-y-2 max-h-48 overflow-y-auto">
                    {project.users.map(user => (
                      <label key={user.id} className="flex items-center gap-3 p-3 bg-[var(--elevated)] border border-[var(--border)] rounded cursor-pointer hover:border-[var(--border)]">
                        <input type="checkbox" checked={selectedUserIds.includes(user.id)} onChange={() => toggleUser(user.id)} />
                        <span className="text-sm text-[var(--text-strong)]">{user.name}</span>
                      </label>
                    ))}
                  </div>
                </div>

                <div className="flex gap-3">
                  {editingTeam && (
                    <button onClick={() => { setEditingTeam(null); setNewTeamName(''); setSelectedUserIds([]); }} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button>
                  )}
                  <button onClick={editingTeam ? handleUpdateTeam : handleCreateTeam} disabled={!newTeamName.trim() || selectedUserIds.length === 0} className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors">
                    {editingTeam ? 'Update Team' : 'Create Team'}
                  </button>
                </div>
              </div>
            </div>

            <div className="flex justify-end pt-4 border-t border-[var(--border)]">
              <button onClick={onClose} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] px-6 py-2 rounded transition-colors">Done</button>
            </div>
          </div>
        </Modal>
      );
    }

    function DirectoryQuickAdd({ directory, selectedKeys, onToggleUserKey, onAddRoleMembers }) {
      const users = Array.isArray(directory?.users) ? directory.users : [];
      const roles = Array.isArray(directory?.roles) ? directory.roles : [];
      if (users.length === 0 && roles.length === 0) return null;

      const selectedSet = new Set(Array.isArray(selectedKeys) ? selectedKeys : []);

      return (
        <div className="bg-gray-900 border border-gray-800 rounded-lg p-4 space-y-4">
          <div>
            <h3 className="text-sm font-semibold text-gray-100">Quick add from your directory</h3>
            <p className="text-xs text-gray-500 mt-1">Reuse collaborators and roles from existing projects.</p>
          </div>
          {users.length > 0 && (
            <div>
              <h4 className="text-xs uppercase tracking-wide text-gray-500 mb-2">People</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {users.map(user => {
                  const infoParts = [];
                  const relationship = trimString(user.relationship);
                  const role = trimString(user.role);
                  const email = trimString(user.email);
                  const phone = trimString(user.phone);
                  if (relationship) infoParts.push(relationship);
                  if (role && role !== relationship) infoParts.push(role);
                  if (email) infoParts.push(email);
                  if (phone) infoParts.push(phone);
                  return (
                    <label
                      key={user.directoryKey}
                      className="flex items-center gap-3 p-3 bg-gray-800 border border-gray-700 rounded cursor-pointer hover:border-gray-600"
                    >
                      <input
                        type="checkbox"
                        checked={selectedSet.has(user.directoryKey)}
                        onChange={() => onToggleUserKey && onToggleUserKey(user.directoryKey)}
                      />
                      <div>
                        <div className="text-sm text-gray-100">{user.name || 'Unnamed User'}</div>
                        {infoParts.length > 0 && (
                          <div className="text-[11px] text-gray-400">{infoParts.join(' â€¢ ')}</div>
                        )}
                      </div>
                    </label>
                  );
                })}
              </div>
            </div>
          )}
          {roles.length > 0 && (
            <div>
              <h4 className="text-xs uppercase tracking-wide text-gray-500 mb-2">Roles &amp; Teams</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {roles.map(role => {
                  const memberNames = role.members
                    .map(member => trimString(member?.name || ''))
                    .filter(Boolean)
                    .join(', ');
                  const allSelected = (role.memberKeys || []).every(key => selectedSet.has(key));
                  return (
                    <div key={role.id} className="border border-gray-800 rounded-lg p-3 bg-gray-800/60 space-y-2">
                      <div className="flex items-center justify-between gap-3">
                        <div>
                          <div className="text-sm text-gray-100">{role.name}</div>
                          {trimString(role.projectName) && (
                            <div className="text-[11px] text-gray-500">from {role.projectName}</div>
                          )}
                        </div>
                        <button
                          onClick={() => onAddRoleMembers && onAddRoleMembers(role)}
                          disabled={allSelected}
                          className={`text-xs px-3 py-1 rounded ${allSelected ? 'bg-gray-700 text-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 text-white'}`}
                        >
                          {allSelected ? 'Added' : 'Add'}
                        </button>
                      </div>
                      {memberNames && (
                        <div className="text-[11px] text-gray-400">{memberNames}</div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          )}
        </div>
      );
    }

    function CreateProjectModal({ onClose, onCreate, projects = [] }) {
      const [name, setName] = useState('');
      const [team, setTeam] = useState('');
      const [selectedDirectoryUserKeys, setSelectedDirectoryUserKeys] = useState([]);

      const directory = useMemo(() => buildProjectDirectory(projects), [projects]);
      const manualMembers = useMemo(() => team.split(',').map(value => trimString(value)).filter(Boolean), [team]);
      const selectedDirectoryUsers = useMemo(
        () => selectedDirectoryUserKeys.map(key => directory.userMap.get(key)).filter(Boolean),
        [selectedDirectoryUserKeys, directory]
      );
      const combinedMembers = useMemo(() => {
        const names = new Set();
        selectedDirectoryUsers.forEach(user => {
          const nameValue = trimString(user?.name || '');
          if (nameValue) names.add(nameValue);
        });
        manualMembers.forEach(nameValue => {
          if (nameValue) names.add(nameValue);
        });
        return Array.from(names);
      }, [selectedDirectoryUsers, manualMembers]);

      const toggleDirectoryUserKey = (key) => {
        if (!key) return;
        setSelectedDirectoryUserKeys(prev => {
          const set = new Set(prev);
          if (set.has(key)) {
            set.delete(key);
          } else {
            set.add(key);
          }
          return Array.from(set);
        });
      };

      const handleAddRoleMembers = (role) => {
        if (!role) return;
        setSelectedDirectoryUserKeys(prev => {
          const set = new Set(prev);
          (role.memberKeys || []).forEach(key => {
            if (key) set.add(key);
          });
          return Array.from(set);
        });
      };

      const handleCreate = () => {
        const projectName = trimString(name);
        if (!projectName) return;
        const payloadUsers = normalizeProjectUserPayload({
          selectedUsers: selectedDirectoryUsers,
          manualMembers
        });
        onCreate(projectName, payloadUsers);
        setName('');
        setTeam('');
        setSelectedDirectoryUserKeys([]);
      };

      return (
        <Modal onClose={onClose} title="Create Project">
          <div className="space-y-4">
            <div><label className="block text-sm text-[var(--text)] mb-2">Project name</label><input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="e.g., Marketing" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400" autoFocus /></div>
            <div><label className="block text-sm text-[var(--text)] mb-2">Team members (comma separated)</label><input type="text" value={team} onChange={(e) => setTeam(e.target.value)} placeholder="e.g., alex, pat, sam" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400" /></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (name) { const teamList = team ? team.split(',').map(s => s.trim()) : []; onCreate(name, teamList); } }} disabled={!name} className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors">Create</button></div>
          </div>
        </Modal>
      );
    }

    function CreateFlowModal({ onClose, onCreate }) {
      const [name, setName] = useState('');
      const [description, setDescription] = useState('');
      const [deliverables, setDeliverables] = useState(['', '', '']);
      return (
        <Modal onClose={onClose} title="Create Flow" size="large">
          <div className="space-y-4">
            <div className="bg-[var(--info)]/30 border border-[var(--info)]/50 rounded p-4"><p className="text-sm text-[var(--text-strong)]">Flows represent coordination cycles. Define up to three deliverables.</p></div>
            <div><label className="block text-sm text-[var(--text)] mb-2">Flow name</label><input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="e.g., Newsletter Creation" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400" autoFocus /></div>
            <div><label className="block text-sm text-[var(--text)] mb-2">Description (optional)</label><textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Brief description" rows={2} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-sm text-[var(--text-strong)] placeholder-gray-400" /></div>
            <div><label className="block text-sm text-[var(--text)] mb-2">Flow Deliverables (1-3)</label><div className="space-y-2">{deliverables.map((d, i) => <input key={i} type="text" value={d} onChange={(e) => { const u = [...deliverables]; u[i] = e.target.value; setDeliverables(u); }} placeholder={i === 0 ? 'e.g., Published article' : i === 1 ? 'e.g., Social media package' : 'e.g., Analytics report'} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-sm text-[var(--text-strong)] placeholder-gray-400" />)}</div></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button><button onClick={() => { const valid = deliverables.filter(d => d.trim()); if (name && valid.length > 0) onCreate(name, valid, description); }} disabled={!name || !deliverables.some(d => d.trim())} className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors">Create</button></div>
          </div>
        </Modal>
      );
    }

    function CreateActivityModal({ project, flow, onClose, onCreate, initialOperatorId }) {
      const [title, setTitle] = useState('');
      const [deliverable, setDeliverable] = useState('');
      const [startingStageId, setStartingStageId] = useState('');

      const orderedStages = useMemo(() => getOrderedStages(flow), [flow]);

      useEffect(() => {
        if (initialOperatorId) {
          setStartingStageId(initialOperatorId);
        } else {
          const firstStage = getFirstActiveStage(orderedStages);
          setStartingStageId(firstStage ? getStageIdentity(firstStage) : '');
        }
      }, [initialOperatorId, orderedStages]);

      const selectedTeams = useMemo(() => {
        return resolveStageTeams(project, flow, startingStageId);
      }, [project, flow, startingStageId]);

      return (
        <Modal onClose={onClose} title="Create Activity">
          <div className="space-y-4">
            <div className="bg-[var(--info)]/30 border border-[var(--info)]/50 rounded p-4">
              <p className="text-sm text-[var(--text-strong)]">
                Activities start in a stage. The teams assigned to that stage can work on it.
              </p>
            </div>

            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Activity name</label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="e.g., Write article"
                className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
                autoFocus
              />
            </div>

            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Starting stage</label>
              <select
                value={startingStageId}
                onChange={(e) => setStartingStageId(e.target.value)}
                className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)]"
              >
                {orderedStages.filter(s => !s.skipped).map(stage => (
                  <option key={getStageIdentity(stage)} value={getStageIdentity(stage)}>
                    {stage.name}
                  </option>
                ))}
              </select>
              <p className="text-xs text-[var(--text-muted)] mt-1">
                Teams assigned: {selectedTeams.length === 0 ? 'None yet' : selectedTeams.map(team => team.name).join(', ')}
              </p>
            </div>

            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Deliverable (optional)</label>
              <input
                type="text"
                value={deliverable}
                onChange={(e) => setDeliverable(e.target.value)}
                placeholder="e.g., 800-word article"
                className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
              />
            </div>

            <div className="flex gap-3 pt-4">
              <button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">
                Cancel
              </button>
              <button
                onClick={() => {
                  if (title) onCreate(title, deliverable, { stageId: startingStageId });
                }}
                disabled={!title}
                className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors"
              >
                Create
              </button>
            </div>
          </div>
        </Modal>
      );
    }

    function EditActivityModal({ project, activity, onClose, onUpdate }) {
      const [title, setTitle] = useState(activity?.title || '');
      const [deliverable, setDeliverable] = useState(activity?.deliverable || '');

      useEffect(() => {
        if (activity) {
          setTitle(activity.title);
          setDeliverable(activity.deliverable || '');
        }
      }, [activity]);

      return (
        <Modal onClose={onClose} title="Edit Activity">
          <div className="space-y-4">
            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Activity name</label>
              <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="e.g., Write article"
                className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
                autoFocus
              />
            </div>

            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Deliverable (optional)</label>
              <input
                type="text"
                value={deliverable}
                onChange={(e) => setDeliverable(e.target.value)}
                placeholder="e.g., 800-word article"
                className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400"
              />
            </div>

            <div className="flex gap-3 pt-4">
              <button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">
                Cancel
              </button>
              <button
                onClick={() => {
                  if (title) onUpdate({ title, deliverable });
                }}
                disabled={!title}
                className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors"
              >
                Save
              </button>
            </div>
          </div>
        </Modal>
      );
    }

    function DeleteActivityModal({ activity, onClose, onDelete }) {
      return (
        <Modal onClose={onClose} title="Delete Activity">
          <div className="space-y-4">
            <div className="bg-[var(--danger)]/30 border border-[var(--danger)]/50 rounded p-4">
              <p className="text-sm text-[var(--text-strong)]">Are you sure you want to delete this activity? This will also remove all edges connected to it. This action cannot be undone.</p>
            </div>
            <div className="bg-[var(--surface)] rounded-lg p-4">
              <h3 className="font-medium text-[var(--text-strong)]">{activity?.title}</h3>
            </div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button><button onClick={onDelete} className="flex-1 bg-[var(--danger)] hover:bg-[var(--danger)] py-2 rounded transition-colors">Delete</button></div>
          </div>
        </Modal>
      );
    }

    function ClaimActivityModal({ activity, project, onClose, onClaim }) {
      const [priority, setPriority] = useState('medium');
      return (
        <Modal onClose={onClose} title="Claim Activity">
          <div className="space-y-4">
            <div className="bg-[var(--surface)] rounded-lg p-4"><h3 className="font-medium mb-2 text-[var(--text-strong)]">{activity?.title}</h3></div>
            <div><label className="block text-sm text-[var(--text)] mb-3">Priority</label><div className="space-y-2">{[{ value: 'high', label: 'High - Focus' }, { value: 'medium', label: 'Medium - Normal' }, { value: 'low', label: 'Low - When available' }].map(opt => <label key={opt.value} className="flex items-center gap-3 p-3 bg-[var(--elevated)] border border-[var(--border)] rounded cursor-pointer hover:border-[var(--border)]"><input type="radio" name="priority" value={opt.value} checked={priority === opt.value} onChange={(e) => setPriority(e.target.value)} /><span className="text-sm text-[var(--text-strong)]">{opt.label}</span></label>)}</div></div>
            <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button><button onClick={() => onClaim(priority)} className="flex-1 bg-[var(--accent)] hover:opacity-90 py-2 rounded transition-colors">Claim</button></div>
          </div>
        </Modal>
      );
    }

    function CompleteActivityModal({ activity, flow, project, onClose, onComplete }) {
      const [note, setNote] = useState('');
      const [taggedUserIds, setTaggedUserIds] = useState([]);
      const orderedStages = useMemo(() => getOrderedStages(flow), [flow]);
      const currentStage = useMemo(() => {
        if (!activity) return null;
        const stageId = activity.currentStageId || activity.stageId || getActivityDefaultStageId(activity, orderedStages);
        return stageId ? orderedStages.find(stage => getStageIdentity(stage) === stageId) || null : null;
      }, [activity, orderedStages]);
      const stageId = currentStage ? getStageIdentity(currentStage) : null;
      const nextStageId = currentStage ? getNextStageId(orderedStages, getStageIdentity(currentStage), activity?.skippedStages || []) : null;
      const nextStage = nextStageId ? orderedStages.find(stage => getStageIdentity(stage) === nextStageId) || null : null;
      const currentEntry = stageId ? getLatestStageHistoryEntry(activity?.stageHistory, stageId) : null;
      const stageLog = currentEntry?.log || [];
      const projectUsers = project?.users || [];

      useEffect(() => {
        setNote('');
        setTaggedUserIds([]);
      }, [activity?.id]);

      const toggleTaggedUser = (userId) => {
        setTaggedUserIds(prev => prev.includes(userId)
          ? prev.filter(id => id !== userId)
          : [...prev, userId]);
      };

      const renderTaggedHistoryUsers = (ids) => {
        const values = Array.isArray(ids) ? ids.filter(Boolean) : [];
        if (values.length === 0) return null;
        return (
          <div className="flex flex-wrap gap-1 text-[10px] text-[var(--info)] mt-1">
            {values.map(id => {
              const user = projectUsers.find(u => u.id === id);
              const label = user?.name || 'Unknown user';
              return (
                <span key={id} className="inline-flex items-center gap-1 bg-[var(--info)]/40 border border-[var(--info)]/50 px-2 py-0.5 rounded">
                  <span className="font-semibold">{getUserInitials(user?.name || '')}</span>
                  {label}
                </span>
              );
            })}
          </div>
        );
      };

      const handleSubmit = (skipStage = false) => {
        const trimmed = note.trim();
        onComplete({ skipStage, note: trimmed || null, taggedUserIds });
      };

      return (
        <Modal onClose={onClose} title="Advance Stage" size="large">
          <div className="space-y-4">
            <div className="bg-[var(--surface)] rounded-lg p-4">
              <h3 className="font-medium text-[var(--text-strong)]">{activity?.title}</h3>
              {currentStage && <p className="text-sm text-[var(--text)] mt-1">Mark the <span className="font-semibold text-[var(--text-strong)]">{currentStage.name}</span> stage as complete or skipped.</p>}
            </div>
            {currentStage && (
              <div className="bg-[var(--surface)]/40 border border-[var(--border)] rounded-lg p-4 space-y-3">
                <div className="flex items-center justify-between text-sm text-[var(--text)]">
                  <span>Current stage</span>
                  <span className="text-[var(--text-strong)] font-medium">{currentStage.name}</span>
                </div>
                {currentStage.conditions && <div className="text-xs text-[var(--info)] bg-[var(--info)]/30 border border-[var(--info)]/40 rounded px-3 py-2">Conditions: {currentStage.conditions}</div>}
                <div className="text-xs text-[var(--text-muted)]">
                  {nextStage ? (
                    <p>Advancing will move this activity to <span className="text-[var(--text-strong)]">{nextStage.name}</span>.</p>
                  ) : (
                    <p>Advancing will complete this activity.</p>
                  )}
                </div>
                {stageLog.length > 0 && (
                  <div className="text-xs text-[var(--text-muted)]">
                    <div className="uppercase tracking-wide text-[var(--text-muted)] mb-2">Recent stage history</div>
                    <ul className="space-y-1">
                      {stageLog.slice(-5).reverse().map(entry => (
                        <li key={entry.id} className="space-y-0.5">
                          <div className="flex items-center justify-between gap-3">
                            <span>{entry.text}</span>
                            <span className="text-[10px] text-[var(--text-muted)]">{formatRelativeTime(entry.timestamp)}</span>
                          </div>
                          {renderTaggedHistoryUsers(entry.taggedUserIds)}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            )}
            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Notes (optional)</label>
              <textarea value={note} onChange={(e) => setNote(e.target.value)} rows={3} placeholder="Add any context about this stage completion" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-500" />
            </div>
            <div>
              <label className="block text-sm text-[var(--text)] mb-2">Tag Users (optional)</label>
              {projectUsers.length === 0 ? (
                <div className="text-xs text-[var(--text-muted)] bg-[var(--surface)]/50 border border-[var(--border)] rounded px-3 py-2">
                  Add users in the dashboard to enable tagging.
                </div>
              ) : (
                <div className="space-y-2 max-h-48 overflow-y-auto">
                  {projectUsers.map(user => {
                    const selected = taggedUserIds.includes(user.id);
                    return (
                      <label
                        key={user.id}
                        className={`flex items-center gap-3 p-2 rounded border transition-colors cursor-pointer ${selected ? 'border-[var(--accent)] bg-[var(--info)]/30' : 'border-[var(--border)] bg-[var(--surface)]/40 hover:border-[var(--border)]'}`}
                      >
                        <input
                          type="checkbox"
                          checked={selected}
                          onChange={() => toggleTaggedUser(user.id)}
                          className="accent-[var(--accent)]"
                        />
                        <div className="w-9 h-9 rounded-full bg-gradient-to-br from-[var(--accent)] to-[color:oklch(from_var(--accent)_0.68_0.12_260)] text-white text-xs font-semibold flex items-center justify-center overflow-hidden">
                          {user.avatar ? (
                            <img src={user.avatar} alt={user.name || 'User avatar'} className="w-full h-full object-cover" />
                          ) : (
                            <span>{getUserInitials(user.name)}</span>
                          )}
                        </div>
                        <div className="flex-1">
                          <div className="text-sm text-[var(--text-strong)]">{user.name || 'Unnamed User'}</div>
                          {(user.relationship || user.role) && (
                            <div className="text-[11px] text-[var(--text-muted)]">
                              {[user.relationship, user.role].filter(Boolean).join(' â€¢ ')}
                            </div>
                          )}
                        </div>
                      </label>
                    );
                  })}
                </div>
              )}
              {taggedUserIds.length > 0 && (
                <div className="text-xs text-[var(--info)] mt-2">
                  Tagging {taggedUserIds.length} {taggedUserIds.length === 1 ? 'user' : 'users'}.
                </div>
              )}
            </div>
            <div className="grid md:grid-cols-3 gap-3 pt-2">
              <button onClick={onClose} className="bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button>
              <button onClick={() => handleSubmit(true)} className="bg-[var(--warn)] hover:opacity-90 text-white py-2 rounded transition-colors">Skip Stage</button>
              <button onClick={() => handleSubmit(false)} className="bg-[var(--ok)] hover:opacity-90 py-2 rounded transition-colors">Mark Stage Complete</button>
            </div>
          </div>
        </Modal>
      );
    }

    function WireActivityModal({ project, activity, flow, onClose, onWire, onCreate }) {
      const [mode, setMode] = useState('existing');
      const [targetId, setTargetId] = useState('');
      const [edgeType, setEdgeType] = useState('enables');
      const [newTitle, setNewTitle] = useState('');
      const [newDeliverable, setNewDeliverable] = useState('');
      const orderedStages = useMemo(() => getOrderedStages(flow), [flow]);
      const stageOptions = useMemo(() => orderedStages.map(stage => ({ id: getStageIdentity(stage), name: stage.name, skipped: stage.skipped })), [orderedStages]);
      const defaultSrcStageId = useMemo(() => {
        if (activity) {
          return activity.currentStageId || activity.stageId || getActivityDefaultStageId(activity, orderedStages) || (stageOptions[0]?.id || '');
        }
        return stageOptions[0]?.id || '';
      }, [activity, orderedStages, stageOptions]);
      const [srcStageId, setSrcStageId] = useState(defaultSrcStageId);
      const [dstStageId, setDstStageId] = useState(stageOptions[0]?.id || '');
      const [newInitialStageId, setNewInitialStageId] = useState(stageOptions[0]?.id || '');

      const availableActivities = flow.activities.filter(a => a.id !== activity.id && !a.completedAt);
      const targetActivity = useMemo(() => availableActivities.find(a => a.id === targetId) || null, [availableActivities, targetId]);

      useEffect(() => {
        setSrcStageId(defaultSrcStageId);
      }, [defaultSrcStageId]);

      useEffect(() => {
        if (targetActivity) {
          const inferred = targetActivity.currentStageId || targetActivity.stageId || getActivityDefaultStageId(targetActivity, orderedStages) || stageOptions[0]?.id || '';
          setDstStageId(inferred || '');
        } else if (stageOptions[0]) {
          setDstStageId(stageOptions[0].id);
        }
      }, [targetActivity, orderedStages, stageOptions]);

      useEffect(() => {
        if (mode === 'new') {
          setDstStageId(newInitialStageId || stageOptions[0]?.id || '');
        }
      }, [mode, newInitialStageId, stageOptions]);

      const canWireExisting = Boolean(targetId && srcStageId && dstStageId);
      const canCreateNew = Boolean(newTitle && srcStageId && newInitialStageId && dstStageId);

      return (
        <Modal onClose={onClose} title="Wire Activity" size="large">
          <div className="space-y-4">
            <div className="bg-[var(--surface)] rounded-lg p-4"><h3 className="font-medium text-[var(--text-strong)]">{activity?.title}</h3><p className="text-sm text-[var(--text)] mt-1">Connect this activity to another</p></div>
            <div><label className="block text-sm text-[var(--text)] mb-2">Connection type</label><select value={edgeType} onChange={(e) => setEdgeType(e.target.value)} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)]"><option value="enables">Enables (this unlocks the other)</option><option value="requires">Requires (this depends on the other)</option></select></div>
            <div className="grid md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm text-[var(--text)] mb-2">Source stage</label>
                <select value={srcStageId} onChange={(e) => setSrcStageId(e.target.value)} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)]">
                  <option value="">Choose...</option>
                  {stageOptions.map(option => (
                    <option key={option.id} value={option.id}>{option.name}{option.skipped ? ' (skipped)' : ''}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm text-[var(--text)] mb-2">{mode === 'existing' ? 'Target stage' : 'Dependency stage'}</label>
                <select value={dstStageId} onChange={(e) => setDstStageId(e.target.value)} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)]">
                  <option value="">Choose...</option>
                  {stageOptions.map(option => (
                    <option key={option.id} value={option.id}>{option.name}{option.skipped ? ' (skipped)' : ''}</option>
                  ))}
                </select>
                {mode === 'existing' && !targetActivity && <p className="text-xs text-[var(--text-muted)] mt-1">Select a target activity to prefill its current stage.</p>}
              </div>
            </div>
            <div className="flex gap-2 p-2 bg-[var(--elevated)] rounded"><button onClick={() => setMode('existing')} className={`flex-1 py-2 px-3 rounded text-sm transition-colors ${mode === 'existing' ? 'bg-[var(--accent)]' : 'bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)]'}`}>Existing Activity</button><button onClick={() => setMode('new')} className={`flex-1 py-2 px-3 rounded text-sm transition-colors ${mode === 'new' ? 'bg-[var(--accent)]' : 'bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)]'}`}>Create New</button></div>
            {mode === 'existing' ? (
              <>
                <div><label className="block text-sm text-[var(--text)] mb-2">Select activity</label><select value={targetId} onChange={(e) => setTargetId(e.target.value)} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)]"><option value="">Choose...</option>{availableActivities.map(a => <option key={a.id} value={a.id}>{a.title}</option>)}</select></div>
                <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (canWireExisting) onWire({ targetId, edgeType, srcStageId, dstStageId }); }} disabled={!canWireExisting} className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors">Wire</button></div>
              </>
            ) : (
              <>
                <div>
                  <label className="block text-sm text-[var(--text)] mb-2">New activity starts at</label>
                  <select value={newInitialStageId} onChange={(e) => setNewInitialStageId(e.target.value)} className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)]">
                    <option value="">Choose...</option>
                    {stageOptions.map(option => (
                      <option key={option.id} value={option.id}>{option.name}{option.skipped ? ' (skipped)' : ''}</option>
                    ))}
                  </select>
                </div>
                <div><label className="block text-sm text-[var(--text)] mb-2">New activity title</label><input type="text" value={newTitle} onChange={(e) => setNewTitle(e.target.value)} placeholder="e.g., Review article" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400" /></div>
                <div><label className="block text-sm text-[var(--text)] mb-2">Deliverable (optional)</label><input type="text" value={newDeliverable} onChange={(e) => setNewDeliverable(e.target.value)} placeholder="e.g., Reviewed draft" className="w-full bg-[var(--elevated)] border border-[var(--border)] rounded px-4 py-2 text-[var(--text-strong)] placeholder-gray-400" /></div>
                <div className="flex gap-3 pt-4"><button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button><button onClick={() => { if (canCreateNew) onCreate({ title: newTitle, deliverable: newDeliverable, edgeType, srcStageId, dstStageId, initialStageId: newInitialStageId }); }} disabled={!canCreateNew} className="flex-1 bg-[var(--accent)] hover:opacity-90 disabled:bg-[color:oklch(from_var(--text)_0.82_0_0)] py-2 rounded transition-colors">Create & Wire</button></div>
              </>
            )}
          </div>
        </Modal>
      );
    }

    function AssignStageTeamsModal({ project, flow, stageId, onClose, onUpdate }) {
      const stageConfig = getFlowStageConfig(flow);
      const stage = getOrderedStages(flow).find(s => getStageIdentity(s) === stageId || s.operatorKey === stageId || s.key === stageId);
      const stageKey = stage ? (stage.operatorKey || stage.key || getStageIdentity(stage)) : stageId;
      const config = stageConfig.find(sc => sc.stageKey === stageKey);
      const [selectedTeamIds, setSelectedTeamIds] = useState(config?.assignedTeamIds || []);
      const [selectedUserIds, setSelectedUserIds] = useState(config?.assignedUserIds || []);

      useEffect(() => {
        setSelectedTeamIds(config?.assignedTeamIds || []);
        setSelectedUserIds(config?.assignedUserIds || []);
      }, [stageKey, config?.assignedTeamIds, config?.assignedUserIds]);

      const teams = project.teams || [];

      const toggleTeam = (teamId) => {
        setSelectedTeamIds(prev =>
          prev.includes(teamId)
            ? prev.filter(id => id !== teamId)
            : [...prev, teamId]
        );
      };

      const toggleUser = (userId) => {
        setSelectedUserIds(prev =>
          prev.includes(userId)
            ? prev.filter(id => id !== userId)
            : [...prev, userId]
        );
      };

      const handleSave = () => {
        onUpdate(stageKey, {
          assignedTeamIds: selectedTeamIds,
          assignedUserIds: selectedUserIds
        });
        onClose();
      };

      return (
        <Modal onClose={onClose} title={`Assign Teams: ${stage?.name || stageId}`} size="large">
          <div className="space-y-6">
            <div className="bg-[var(--info)]/30 border border-[var(--info)]/50 rounded p-4">
              <p className="text-sm text-[var(--text-strong)]">
                Choose which teams can work on activities when they reach this stage. You can also assign individual users if needed.
              </p>
            </div>

            <div>
              <h3 className="text-sm font-semibold text-[var(--text)] mb-3">Assign Teams</h3>
              {teams.length === 0 ? (
                <p className="text-sm text-[var(--text-muted)]">No teams yet. Create teams in the dashboard.</p>
              ) : (
                <div className="space-y-2">
                  {teams.map(team => (
                    <label key={team.id} className="flex items-center gap-3 p-3 bg-[var(--elevated)] border border-[var(--border)] rounded cursor-pointer hover:border-[var(--border)]">
                      <input type="checkbox" checked={selectedTeamIds.includes(team.id)} onChange={() => toggleTeam(team.id)} />
                      <div
                        className="w-3 h-3 rounded-full"
                        style={{ backgroundColor: TEAM_COLOR_MAP[team.color] || 'var(--accent)' }}
                      ></div>
                      <div className="flex-1">
                        <div className="text-sm text-[var(--text-strong)]">{team.name}</div>
                        <div className="text-xs text-[var(--text-muted)]">
                          {team.userIds.length} members:{' '}
                          {team.userIds
                            .map(uid => project.users.find(u => u.id === uid)?.name)
                            .filter(Boolean)
                            .join(', ')}
                        </div>
                      </div>
                    </label>
                  ))}
                </div>
              )}
            </div>

            <div className="border-t border-[var(--border)] pt-6">
              <h3 className="text-sm font-semibold text-[var(--text)] mb-3">Or assign individual users</h3>
              <p className="text-xs text-[var(--text-muted)] mb-3">For small flows, you can skip teams and assign users directly.</p>
              <div className="space-y-2 max-h-48 overflow-y-auto">
                {project.users.map(user => (
                  <label key={user.id} className="flex items-center gap-3 p-3 bg-[var(--elevated)] border border-[var(--border)] rounded cursor-pointer hover:border-[var(--border)]">
                    <input type="checkbox" checked={selectedUserIds.includes(user.id)} onChange={() => toggleUser(user.id)} />
                    <span className="text-sm text-[var(--text-strong)]">{user.name}</span>
                  </label>
                ))}
              </div>
            </div>

            <div className="flex gap-3 pt-4 border-t border-[var(--border)]">
              <button onClick={onClose} className="flex-1 bg-[color:oklch(from_var(--text)_0.82_0_0)] hover:bg-[color:oklch(from_var(--text)_0.74_0_0)] py-2 rounded transition-colors">Cancel</button>
              <button onClick={handleSave} className="flex-1 bg-[var(--accent)] hover:opacity-90 py-2 rounded transition-colors">Save Assignment</button>
            </div>
          </div>
        </Modal>
      );
    }

    function Modal({ children, onClose, title, size = 'medium' }) {
      const sizeClasses = { medium: 'max-w-2xl', large: 'max-w-4xl' };
      return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center p-6 z-50">
          <div className={`bg-[var(--surface)] rounded-lg border border-[var(--border)] w-full ${sizeClasses[size]} max-h-[90vh] overflow-y-auto`}>
            <div className="sticky top-0 bg-[var(--surface)] border-b border-[var(--border)] p-6 flex items-center justify-between">
              <h2 className="text-xl font-semibold text-[var(--text-strong)]">{title}</h2>
              <button onClick={onClose} className="text-[var(--text)] hover:text-[var(--text-strong)] transition-colors"><XIcon className="w-5 h-5" /></button>
            </div>
            <div className="p-6">{children}</div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<EventOperator />);
  </script>
</body>
</html>
