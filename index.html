<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Secure P2P Workspace</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #e4e4e7;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #27272a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .hidden {
            display: none !important;
        }

        /* Layout */
        .app-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.connected {
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .status-dot.connecting {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .workspace-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-author {
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .message-time {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-left: 0.5rem;
        }

        .message-input-container {
            padding: 1rem;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
        }

        .message-input-wrapper {
            display: flex;
            gap: 0.5rem;
        }

        /* Forms */
        .card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            width: 100%;
            max-width: 420px;
            border: 1px solid var(--border);
            margin: 2rem auto;
        }

        h1 {
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        button.secondary:hover:not(:disabled) {
            background: var(--bg-tertiary);
        }

        input, textarea {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: inherit;
        }

        input:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .input-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        /* Verification UI */
        .verification-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .verification-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
        }

        .fingerprint-display {
            background: var(--bg-primary);
            padding: 1.5rem;
            border-radius: 8px;
            font-family: monospace;
            font-size: 2rem;
            text-align: center;
            margin: 1.5rem 0;
            letter-spacing: 0.2em;
            border: 2px solid var(--accent);
        }

        .emoji-display {
            font-size: 3rem;
            text-align: center;
            padding: 1rem;
            background: var(--bg-primary);
            border-radius: 8px;
            margin: 1rem 0;
            letter-spacing: 0.5em;
        }

        .trust-indicator {
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .trust-new {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent);
        }

        .trust-verified {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }

        .trust-warning {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--danger);
            color: var(--danger);
        }

        .peer-list {
            padding: 1rem;
            border-left: 1px solid var(--border);
            width: 250px;
            background: var(--bg-secondary);
        }

        .peer-item {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .peer-status {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Landing Screen -->
        <div id="landing-screen" class="screen">
            <div class="card">
                <h1>Secure P2P Workspace</h1>
                <p style="text-align: center; color: var(--text-secondary); margin-bottom: 2rem;">
                    End-to-end encrypted • Peer-to-peer • No servers
                </p>
                
                <button onclick="app.showCreateScreen()" style="width: 100%; margin-bottom: 1rem;">
                    Create New Workspace
                </button>
                
                <button class="secondary" onclick="app.showJoinScreen()" style="width: 100%;">
                    Join with Invite Link
                </button>
            </div>
        </div>

        <!-- Create Screen -->
        <div id="create-screen" class="screen hidden">
            <div class="card">
                <h1>Create Workspace</h1>
                
                <div class="input-group">
                    <label>Workspace ID</label>
                    <input type="text" id="workspace-id" readonly style="font-family: monospace;">
                </div>
                
                <div class="input-group">
                    <label>Your Name</label>
                    <input type="text" id="creator-name" placeholder="Enter your display name">
                </div>
                
                <button onclick="app.createWorkspace()" style="width: 100%;">
                    Create Workspace
                </button>
                
                <button class="secondary" onclick="app.showLandingScreen()" style="width: 100%; margin-top: 0.5rem;">
                    Back
                </button>
            </div>
        </div>

        <!-- Join Screen -->
        <div id="join-screen" class="screen hidden">
            <div class="card">
                <h1>Join Workspace</h1>
                
                <div class="input-group">
                    <label>Your Name</label>
                    <input type="text" id="joiner-name" placeholder="Enter your display name">
                </div>
                
                <button onclick="app.joinWorkspace()" style="width: 100%;">
                    Join Workspace
                </button>
                
                <button class="secondary" onclick="app.showLandingScreen()" style="width: 100%; margin-top: 0.5rem;">
                    Back
                </button>
            </div>
        </div>

        <!-- Main Workspace -->
        <div id="workspace-screen" class="screen hidden">
            <div class="header">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <h2 id="workspace-title">Workspace</h2>
                    <button class="secondary" onclick="app.copyInviteLink()" style="padding: 0.5rem 1rem; font-size: 0.875rem;">
                        Copy Invite
                    </button>
                </div>
                <div class="connection-status">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="connection-status">Disconnected</span>
                </div>
            </div>
            
            <div class="main-content">
                <div class="workspace-area">
                    <div class="messages-container" id="messages-container"></div>
                    
                    <div class="message-input-container">
                        <div class="message-input-wrapper">
                            <input 
                                type="text" 
                                id="message-input" 
                                placeholder="Type a message..."
                                onkeydown="if(event.key === 'Enter') app.sendMessage()"
                            >
                            <button onclick="app.sendMessage()">Send</button>
                        </div>
                    </div>
                </div>
                
                <div class="peer-list">
                    <h3 style="margin-bottom: 1rem;">Connected Peers</h3>
                    <div id="peer-list"></div>
                </div>
            </div>
        </div>

        <!-- Verification Modal -->
        <div id="verification-modal" class="verification-modal hidden">
            <div class="verification-card">
                <h2>Verify Connection</h2>
                <div id="trust-status" class="trust-indicator trust-new">
                    New connection
                </div>
                
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    Compare this code with your peer:
                </p>
                
                <div class="fingerprint-display" id="verification-code">0000</div>
                
                <div class="emoji-display" id="verification-emoji">🔒 🔒 🔒</div>
                
                <p style="text-align: center; color: var(--text-muted); margin-bottom: 1.5rem;">
                    Ask: "Is your code <span id="code-spoken">zero-zero-zero-zero</span>?"
                </p>
                
                <div style="display: flex; gap: 0.5rem;">
                    <button onclick="app.acceptVerification()" style="flex: 1;">
                        Codes Match ✓
                    </button>
                    <button class="secondary" onclick="app.rejectVerification()" style="flex: 1;">
                        No Match ✗
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main Application
        class P2PWorkspaceApp {
            constructor() {
                this.workspaceId = null;
                this.userName = null;
                this.workspaceKey = null;
                this.peers = new Map();
                this.messages = [];
                this.eventLog = [];
                this.trustedFingerprints = new Map();
                this.signaler = null;
                this.isHost = false;
                
                // Initialize
                this.initializeApp();
            }

            initializeApp() {
                // Check for invite hash
                const hash = window.location.hash.slice(1);
                if (hash) {
                    this.showJoinScreen();
                    this.parseInvite(hash);
                }
                
                // Initialize local storage
                this.loadLocalData();
            }

            // Storage
            async loadLocalData() {
                const stored = localStorage.getItem('workspace');
                if (stored) {
                    const data = JSON.parse(stored);
                    this.workspaceId = data.workspaceId;
                    this.userName = data.userName;
                    this.workspaceKey = data.workspaceKey;
                    this.isHost = data.isHost;
                    
                    // Load trusted fingerprints
                    const trusted = localStorage.getItem('trustedFingerprints');
                    if (trusted) {
                        this.trustedFingerprints = new Map(JSON.parse(trusted));
                    }
                    
                    // Load event log
                    const events = localStorage.getItem('eventLog');
                    if (events) {
                        this.eventLog = JSON.parse(events);
                    }
                }
            }

            saveLocalData() {
                localStorage.setItem('workspace', JSON.stringify({
                    workspaceId: this.workspaceId,
                    userName: this.userName,
                    workspaceKey: this.workspaceKey,
                    isHost: this.isHost,
                    timestamp: Date.now()
                }));
                
                localStorage.setItem('trustedFingerprints', 
                    JSON.stringify([...this.trustedFingerprints])
                );
                
                localStorage.setItem('eventLog', JSON.stringify(this.eventLog));
            }

            // Event Sourcing
            appendEvent(event) {
                const e = {
                    id: `E/${this.generateId()}`,
                    s: event.subject,
                    p: event.predicate,
                    o: event.object,
                    at: new Date().toISOString(),
                    recorded_at: new Date().toISOString(),
                    meta: event.meta || {}
                };
                
                this.eventLog.push(e);
                this.saveLocalData();
                
                // Broadcast to peers
                this.broadcastEvent(e);
                
                return e;
            }

            broadcastEvent(event) {
                this.peers.forEach(peer => {
                    if (peer.dataChannel && peer.dataChannel.readyState === 'open') {
                        peer.dataChannel.send(JSON.stringify({
                            type: 'event',
                            event: event
                        }));
                    }
                });
            }

            // UI Navigation
            showLandingScreen() {
                this.hideAllScreens();
                document.getElementById('landing-screen').classList.remove('hidden');
            }

            showCreateScreen() {
                this.hideAllScreens();
                document.getElementById('create-screen').classList.remove('hidden');
                
                // Generate workspace ID
                const id = this.generateWorkspaceName();
                document.getElementById('workspace-id').value = id;
                this.workspaceId = id;
            }

            showJoinScreen() {
                this.hideAllScreens();
                document.getElementById('join-screen').classList.remove('hidden');
            }

            showWorkspaceScreen() {
                this.hideAllScreens();
                document.getElementById('workspace-screen').classList.remove('hidden');
                document.getElementById('workspace-title').textContent = this.workspaceId;
                
                // Start signaling
                this.startSignaling();
            }

            hideAllScreens() {
                document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            }

            // Workspace Creation
            async createWorkspace() {
                const name = document.getElementById('creator-name').value.trim();
                if (!name) {
                    alert('Please enter your name');
                    return;
                }
                
                this.userName = name;
                this.isHost = true;
                this.workspaceKey = this.generateKey();
                
                // Create genesis event
                this.appendEvent({
                    subject: this.userName,
                    predicate: 'created',
                    object: this.workspaceId,
                    meta: { host: true }
                });
                
                this.saveLocalData();
                this.showWorkspaceScreen();
                
                // Copy invite link
                this.copyInviteLink();
            }

            async joinWorkspace() {
                const name = document.getElementById('joiner-name').value.trim();
                if (!name) {
                    alert('Please enter your name');
                    return;
                }
                
                this.userName = name;
                this.isHost = false;
                
                // Join event
                this.appendEvent({
                    subject: this.userName,
                    predicate: 'joined',
                    object: this.workspaceId
                });
                
                this.saveLocalData();
                this.showWorkspaceScreen();
            }

            // Invite Management
            generateInviteLink() {
                const inviteData = {
                    workspaceId: this.workspaceId,
                    key: this.workspaceKey,
                    signal: window.location.origin // In production, use actual signal server
                };
                
                const encoded = btoa(JSON.stringify(inviteData));
                return `${window.location.origin}${window.location.pathname}#${encoded}`;
            }

            parseInvite(hash) {
                try {
                    const decoded = atob(hash);
                    const inviteData = JSON.parse(decoded);
                    this.workspaceId = inviteData.workspaceId;
                    this.workspaceKey = inviteData.key;
                    return inviteData;
                } catch (e) {
                    console.error('Invalid invite link');
                    return null;
                }
            }

            copyInviteLink() {
                const link = this.generateInviteLink();
                navigator.clipboard.writeText(link).then(() => {
                    alert('Invite link copied to clipboard!');
                });
            }

            // WebRTC Connection
            async createPeerConnection(peerId) {
                const config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                };
                
                const pc = new RTCPeerConnection(config);
                const peer = {
                    id: peerId,
                    connection: pc,
                    dataChannel: null,
                    fingerprint: null,
                    verified: false
                };
                
                // Set up data channel
                if (this.isHost) {
                    peer.dataChannel = pc.createDataChannel('data');
                    this.setupDataChannel(peer);
                } else {
                    pc.ondatachannel = (event) => {
                        peer.dataChannel = event.channel;
                        this.setupDataChannel(peer);
                    };
                }
                
                // Handle ICE candidates
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignal(peerId, {
                            type: 'ice',
                            candidate: event.candidate
                        });
                    }
                };
                
                // Monitor connection state
                pc.onconnectionstatechange = () => {
                    this.updateConnectionStatus();
                    if (pc.connectionState === 'connected') {
                        this.verifyPeer(peer);
                    }
                };
                
                this.peers.set(peerId, peer);
                return peer;
            }

            setupDataChannel(peer) {
                const dc = peer.dataChannel;
                
                dc.onopen = () => {
                    console.log('Data channel opened with', peer.id);
                    this.updatePeerList();
                    
                    // Send initial sync
                    dc.send(JSON.stringify({
                        type: 'sync',
                        userName: this.userName,
                        eventLog: this.eventLog
                    }));
                };
                
                dc.onmessage = (event) => {
                    this.handlePeerMessage(peer, JSON.parse(event.data));
                };
                
                dc.onclose = () => {
                    console.log('Data channel closed with', peer.id);
                    this.updatePeerList();
                };
            }

            handlePeerMessage(peer, message) {
                switch (message.type) {
                    case 'sync':
                        this.syncEvents(message.eventLog);
                        if (!this.peers.get(peer.id).userName) {
                            this.peers.get(peer.id).userName = message.userName;
                            this.updatePeerList();
                        }
                        break;
                        
                    case 'event':
                        this.receiveEvent(message.event);
                        break;
                        
                    case 'message':
                        this.receiveMessage(message);
                        break;
                }
            }

            syncEvents(remoteEvents) {
                // Merge remote events with local
                const localIds = new Set(this.eventLog.map(e => e.id));
                const newEvents = remoteEvents.filter(e => !localIds.has(e.id));
                
                this.eventLog.push(...newEvents);
                this.eventLog.sort((a, b) => a.at.localeCompare(b.at));
                this.saveLocalData();
                
                // Process events to rebuild state
                this.rebuildStateFromEvents();
            }

            receiveEvent(event) {
                if (!this.eventLog.find(e => e.id === event.id)) {
                    this.eventLog.push(event);
                    this.saveLocalData();
                    this.processEvent(event);
                }
            }

            processEvent(event) {
                // Handle different event types
                if (event.p === 'sent_message') {
                    this.displayMessage({
                        author: event.s,
                        text: event.meta.text,
                        timestamp: event.at
                    });
                }
            }

            rebuildStateFromEvents() {
                // Clear current state
                document.getElementById('messages-container').innerHTML = '';
                
                // Replay all events
                this.eventLog.forEach(event => {
                    this.processEvent(event);
                });
            }

            // Verification
            async verifyPeer(peer) {
                const stats = await peer.connection.getStats();
                let localFp, remoteFp;
                
                stats.forEach(stat => {
                    if (stat.type === 'certificate' && stat.fingerprint) {
                        localFp = stat.fingerprint;
                    }
                });
                
                // For demo, generate simple fingerprint
                const combined = this.workspaceKey + peer.id;
                const hash = await this.hashString(combined);
                const code = this.generateVerificationCode(hash);
                
                peer.fingerprint = code.hex;
                
                // Check trust
                const trusted = this.trustedFingerprints.get(peer.id);
                let trustStatus = 'new';
                
                if (trusted === peer.fingerprint) {
                    trustStatus = 'verified';
                    peer.verified = true;
                } else if (trusted && trusted !== peer.fingerprint) {
                    trustStatus = 'warning';
                }
                
                // Show verification UI
                if (trustStatus !== 'verified') {
                    this.showVerification(peer, code, trustStatus);
                }
            }

            showVerification(peer, code, trustStatus) {
                const modal = document.getElementById('verification-modal');
                modal.classList.remove('hidden');
                
                // Update UI
                document.getElementById('verification-code').textContent = code.number;
                document.getElementById('verification-emoji').textContent = code.emoji;
                document.getElementById('code-spoken').textContent = code.spoken;
                
                // Update trust indicator
                const indicator = document.getElementById('trust-status');
                indicator.className = `trust-indicator trust-${trustStatus}`;
                indicator.textContent = trustStatus === 'new' ? 
                    `New connection with ${peer.userName || 'peer'}` :
                    `⚠️ Fingerprint changed for ${peer.userName || 'peer'}!`;
                
                // Store current verification
                this.currentVerification = { peer, code };
            }

            acceptVerification() {
                const { peer } = this.currentVerification;
                peer.verified = true;
                this.trustedFingerprints.set(peer.id, peer.fingerprint);
                this.saveLocalData();
                
                document.getElementById('verification-modal').classList.add('hidden');
                this.currentVerification = null;
            }

            rejectVerification() {
                const { peer } = this.currentVerification;
                peer.connection.close();
                this.peers.delete(peer.id);
                
                document.getElementById('verification-modal').classList.add('hidden');
                this.currentVerification = null;
                
                alert('Connection rejected due to verification failure');
            }

            // Messaging
            sendMessage() {
                const input = document.getElementById('message-input');
                const text = input.value.trim();
                
                if (!text) return;
                
                // Create message event
                const event = this.appendEvent({
                    subject: this.userName,
                    predicate: 'sent_message',
                    object: this.workspaceId,
                    meta: { text }
                });
                
                // Display locally
                this.displayMessage({
                    author: this.userName,
                    text,
                    timestamp: event.at
                });
                
                // Clear input
                input.value = '';
            }

            receiveMessage(message) {
                this.displayMessage(message);
            }

            displayMessage(message) {
                const container = document.getElementById('messages-container');
                const messageEl = document.createElement('div');
                messageEl.className = 'message';
                
                const time = new Date(message.timestamp).toLocaleTimeString();
                
                messageEl.innerHTML = `
                    <div class="message-author">
                        ${message.author}
                        <span class="message-time">${time}</span>
                    </div>
                    <div>${message.text}</div>
                `;
                
                container.appendChild(messageEl);
                container.scrollTop = container.scrollHeight;
            }

            // UI Updates
            updateConnectionStatus() {
                const connected = [...this.peers.values()].some(p => 
                    p.connection.connectionState === 'connected'
                );
                
                const statusDot = document.getElementById('status-dot');
                const statusText = document.getElementById('connection-status');
                
                if (connected) {
                    statusDot.className = 'status-dot connected';
                    statusText.textContent = 'Connected';
                } else if ([...this.peers.values()].some(p => 
                    p.connection.connectionState === 'connecting')) {
                    statusDot.className = 'status-dot connecting';
                    statusText.textContent = 'Connecting...';
                } else {
                    statusDot.className = 'status-dot';
                    statusText.textContent = 'Disconnected';
                }
            }

            updatePeerList() {
                const container = document.getElementById('peer-list');
                container.innerHTML = '';
                
                this.peers.forEach(peer => {
                    if (peer.connection.connectionState === 'connected') {
                        const peerEl = document.createElement('div');
                        peerEl.className = 'peer-item';
                        peerEl.innerHTML = `
                            <div class="peer-status"></div>
                            <div>${peer.userName || 'Connecting...'}</div>
                            ${peer.verified ? '✓' : ''}
                        `;
                        container.appendChild(peerEl);
                    }
                });
            }

            // Signaling (simplified - use WebSocket in production)
            startSignaling() {
                // For demo, use BroadcastChannel for local testing
                this.signaler = new BroadcastChannel(`workspace-${this.workspaceId}`);
                
                this.signaler.onmessage = async (event) => {
                    const { from, to, data } = event.data;
                    
                    if (to !== this.userName && to !== '*') return;
                    if (from === this.userName) return;
                    
                    switch (data.type) {
                        case 'announce':
                            // Someone joined, connect to them
                            if (this.isHost) {
                                this.connectToPeer(from);
                            }
                            break;
                            
                        case 'offer':
                            await this.handleOffer(from, data.offer);
                            break;
                            
                        case 'answer':
                            await this.handleAnswer(from, data.answer);
                            break;
                            
                        case 'ice':
                            await this.handleIceCandidate(from, data.candidate);
                            break;
                    }
                };
                
                // Announce presence
                this.sendSignal('*', { type: 'announce' });
            }

            sendSignal(to, data) {
                if (this.signaler) {
                    this.signaler.postMessage({
                        from: this.userName,
                        to,
                        data
                    });
                }
            }

            async connectToPeer(peerId) {
                const peer = await this.createPeerConnection(peerId);
                const offer = await peer.connection.createOffer();
                await peer.connection.setLocalDescription(offer);
                
                this.sendSignal(peerId, {
                    type: 'offer',
                    offer
                });
            }

            async handleOffer(from, offer) {
                const peer = await this.createPeerConnection(from);
                await peer.connection.setRemoteDescription(offer);
                
                const answer = await peer.connection.createAnswer();
                await peer.connection.setLocalDescription(answer);
                
                this.sendSignal(from, {
                    type: 'answer',
                    answer
                });
            }

            async handleAnswer(from, answer) {
                const peer = this.peers.get(from);
                if (peer) {
                    await peer.connection.setRemoteDescription(answer);
                }
            }

            async handleIceCandidate(from, candidate) {
                const peer = this.peers.get(from);
                if (peer) {
                    await peer.connection.addIceCandidate(candidate);
                }
            }

            // Utilities
            generateWorkspaceName() {
                const adjectives = ['quantum', 'stellar', 'crystal', 'nebula'];
                const nouns = ['nexus', 'prism', 'cipher', 'beacon'];
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                const num = Math.floor(Math.random() * 9000) + 1000;
                return `${adj}-${noun}-${num}`;
            }

            generateKey() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return btoa(String.fromCharCode(...array));
            }

            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            }

            async hashString(str) {
                const encoder = new TextEncoder();
                const data = encoder.encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                return new Uint8Array(hashBuffer);
            }

            generateVerificationCode(hash) {
                const bytes = Array.from(hash);
                
                // 4-digit number
                const number = ((bytes[0] << 8) | bytes[1]) % 10000;
                const numberStr = number.toString().padStart(4, '0');
                
                // Spoken version
                const spoken = numberStr.split('').map(d => {
                    const words = ['zero', 'one', 'two', 'three', 'four', 
                                  'five', 'six', 'seven', 'eight', 'nine'];
                    return words[parseInt(d)];
                }).join('-');
                
                // Emoji version
                const emojis = ['🔒', '🔑', '🛡️', '⚡', '🌟', '🎯', '🚀', '💎'];
                const emojiCode = [
                    emojis[bytes[0] % 8],
                    emojis[bytes[1] % 8],
                    emojis[bytes[2] % 8]
                ].join(' ');
                
                // Hex version
                const hex = bytes.slice(0, 4)
                    .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                    .join(':');
                
                return {
                    number: numberStr,
                    spoken,
                    emoji: emojiCode,
                    hex
                };
            }
        }

        // Initialize app
        const app = new P2PWorkspaceApp();
    </script>
</body>
</html>
